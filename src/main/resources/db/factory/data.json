{
  "tags": [
    "java",
    ".net",
    "spring boot",
    "spring mvc",
    "rest api",
    "react js",
    "angular",
    "javascript",
    "es6",
    "jquery",
    "nodejs",
    "python",
    "mongodb",
    "mysql",
    "postgresql",
    "java core",
    ".net core",
    "asp.net mvc",
    "ruby",
    "R",
    "dart",
    "kotlin",
    "android",
    "IOS",
    "react native",
    "flutter",
    "reactive programming",
    "java lambda expression",
    "java project lombok",
    "jsp and servlet",
    "thymeleaf",
    "fremarker",
    "velocity",
    "spring data jpa",
    "hibernate framework",
    "jdbc core and jdbc template"
  ],
  "posts": [
    {
      "title": "Một vài tips trong react native",
      "content": "<p>Điểm ch&iacute;nh của b&agrave;i viết n&agrave;y l&agrave; cung cấp cho bạn những lời khuy&ecirc;n sẽ hỗ trợ bạn v&agrave; nh&oacute;m của bạn trong c&aacute;c dự &aacute;n React Native của bạn. Một số trong những lời khuy&ecirc;n n&agrave;y ho&agrave;n to&agrave;n li&ecirc;n quan đến React Native, trong khi những lời khuy&ecirc;n kh&aacute;c thường thi&ecirc;n về ph&aacute;t triển ứng dụng di động hơn. H&atilde;y c&ugrave;ng bắt đầu!</p>\n\n<h2>1. Xo&aacute; logs trong c&aacute;c bản builds release</h2>\n\n<p>C&oacute; nhiều c&acirc;u lệnh console.log c&oacute; thể l&agrave;m chậm ứng dụng của bạn, đặc biệt nếu bạn đang sử dụng c&aacute;c thư viện ghi nhật k&yacute; như redux-logger. Đảm bảo tắt tất cả nhật k&yacute; (thủ c&ocirc;ng hoặc bằng tập lệnh) khi tạo bản ph&aacute;t h&agrave;nh, điều n&agrave;y cũng sẽ gi&uacute;p phần n&agrave;o ứng dụng của bạn mượt m&agrave; hơn mặc d&ugrave; đ&ocirc;i khi bạn sẽ kh&ocirc;ng thấy sự thay đổi qu&aacute; r&otilde; r&agrave;ng. Nhưng cứ đề ph&ograve;ng cũng chẳng thừa.</p>\n\n<h2>2. Sử dụng Flexbox nhiều hơn</h2>\n\n<p>Thật đ&aacute;ng buồn l&agrave; t&ocirc;i đ&atilde; thấy m&atilde; React Native sử dụng định vị phần tử tuyệt đối (absolute) thay v&igrave; flexbox, ph&aacute; vỡ bố cục v&agrave; kh&ocirc;ng cung cấp khả năng sử dụng lại. Bất kể y&ecirc;u cầu thiết kế của bạn l&agrave; g&igrave;, sử dụng flexbox hầu như lu&ocirc;n l&agrave; c&acirc;u trả lời ch&iacute;nh x&aacute;c. Đối với những người đến từ nền web: Flexbox trong React Native hoạt động gần như ch&iacute;nh x&aacute;c như CSS vậy, sự kh&aacute;c biệt quan trọng l&agrave; flexDirection mặc định th&agrave;nh cột thay v&igrave; h&agrave;ng trong React Native.</p>\n\n<h2>3. Đặt t&ecirc;n c&aacute;c object một c&aacute;ch nhất qu&aacute;n</h2>\n\n<p>Nếu một phần tử của bạn c&oacute; một đối tượng kiểu c&oacute; t&ecirc;n l&agrave; container, th&igrave; h&atilde;y sử dụng t&ecirc;n đ&oacute; cho mọi phần tử c&ugrave;ng cấp độ tr&ecirc;n dự &aacute;n. Nếu n&uacute;t gửi của bạn c&oacute; một đối tượng kiểu c&oacute; t&ecirc;n l&agrave; submitButton, th&igrave; h&atilde;y gắn b&oacute; với n&oacute; v&agrave; kh&ocirc;ng sử dụng saveButton, submitBtn hoặc gửi cho c&aacute;c trường hợp kh&aacute;c.</p>\n\n<h2>4. Sử dụng to&aacute;n tử ba ng&ocirc;i một c&aacute;ch chuẩn x&aacute;c</h2>\n\n<p>Viết như thế n&agrave;y&nbsp;<strong>color = error ? &lsquo;red&rsquo;: &lsquo;gray&rsquo;</strong>&nbsp;xem ra l&agrave; rất ngắn gọn v&agrave; dễ hiểu.</p>\n\n<p>Nhưng khi viết&nbsp;<strong>color = error ? (id === myID) ? &lsquo;red&rsquo; : &lsquo;black&rsquo; : &lsquo;gray&rsquo;</strong>&nbsp;th&igrave; kh&ocirc;ng. To&aacute;n tử ba ng&ocirc;i gi&uacute;p bạn r&uacute;t ngắn số lượng d&ograve;ng code nhưng tốt hơn hết l&agrave; kh&ocirc;ng bao giờ lồng to&aacute;n tử ba ng&ocirc;i v&agrave;o nhau bởi l&agrave;m thế sẽ khiến cho logic trở n&ecirc;n rối rắm v&agrave; kh&oacute; hiểu.</p>\n\n<h2>5.Đừng lạm dụng zIndex</h2>\n\n<p>Chỉ sử dụng zIndex khi bạn phải. V&iacute; dụ: nếu bạn muốn phủ một &lt;Text&gt; tr&ecirc;n &lt;Image&gt;, sử dụng zIndex l&agrave; c&aacute;ch l&agrave;m sai. Bạn n&ecirc;n sử dụng th&agrave;nh phần &lt;ImageBackground&gt; thay thế. Một nguy&ecirc;n tắc nhỏ l&agrave; nếu bạn nghĩ rằng bạn đang l&agrave;m phức tạp m&atilde; của m&igrave;nh với rất nhiều thuộc t&iacute;nh zIndex, th&igrave; c&oacute; lẽ bạn đ&atilde; đ&uacute;ng. Quay trở lại v&agrave; suy nghĩ lại về bố cục của bạn.</p>\n\n<h2>6. setState() l&agrave; kh&ocirc;ng đồng bộ</h2>\n\n<p>Đ&acirc;y phải l&agrave; một trong những lỗi phổ biến nhất cho người mới bắt đầu trong React Native. Mặc d&ugrave; việc thay đổi trạng th&aacute;i của một th&agrave;nh phần g&acirc;y ra việc render lại, nhưng nếu bạn viết một c&aacute;i g&igrave; đ&oacute; như setState({username: &#39;somevalue&#39;}), v&agrave; sau đ&oacute; thử đọc this.state.username trong d&ograve;ng m&atilde; tiếp theo, bạn sẽ kh&ocirc;ng đọc gi&aacute; trị ch&iacute;nh x&aacute;c, v&igrave; setState() l&agrave; một hoạt động kh&ocirc;ng đồng bộ. Sử dụng await setState ({username}) để tr&aacute;nh sự cố n&agrave;y hoặc c&oacute; thể sử dụng callback của setState.</p>\n\n<h2>7. Bạn c&oacute; thể dispatch 1 redux action trong một action kh&aacute;c</h2>\n\n<p>Một h&agrave;nh động kh&ocirc;ng được giới hạn trong một request API hoặc một thao t&aacute;c với dữ liệu. Bất kỳ h&agrave;nh động n&agrave;o cũng c&oacute; thể được gửi từ một h&agrave;nh động kh&aacute;c, từ c&ugrave;ng một tệp hoặc một tệp kh&aacute;c. Nghe c&oacute; vẻ r&otilde; r&agrave;ng nhưng c&oacute; thể bị bỏ qua.</p>\n\n<h2>8. Sử dụng Object destructuring</h2>\n\n<p>Chẳng ai muốn nh&igrave;n thấy c&aacute;i n&agrave;y&nbsp;<strong>this.props.navulation.state.params.username</strong>&nbsp;ở khắp mọi nơi. V&igrave; vậy, sử dụng object destructuring, N&oacute; l&agrave;m cho m&atilde; dễ đọc v&agrave; dễ hiểu hơn. V&agrave; bạn cũng c&oacute; thể (v&agrave; n&ecirc;n) sử dụng n&oacute; trong c&aacute;c tham số h&agrave;m, v&igrave; vậy thay v&igrave;</p>\n\n<pre>\n<code>    const MyComponent = (props) =&gt; {}\n</code></pre>\n\n<p>bạn c&oacute; thể viết</p>\n\n<pre>\n<code>    const MyComponent = ({username, userID}) =&gt; {}\n</code></pre>\n\n<p>Nhưng h&atilde;y cẩn thận một ch&uacute;t, destructuring một object c&oacute; chiều s&acirc;u lớn hơn 2 đ&ocirc;i khi sẽ g&acirc;y crash</p>\n\n<p>V&iacute; dụ</p>\n\n<pre>\n<code>const { data } = this.props\n    \nconst { username, firstName, lastName } = data\n</code></pre>\n\n<p>Tr&ocirc;ng c&oacute; vẻ kh&ocirc;ng c&oacute; g&igrave;, nhưng nếu&nbsp;<em>data</em>&nbsp;ở tr&ecirc;n l&agrave; null th&igrave; việc destructuring object data như ở dưới sẽ g&acirc;y lỗi.</p>\n\n<h2>9. Kh&ocirc;ng d&ugrave;ng TouchableWithoutFeedback nếu bạn kh&ocirc;ng c&oacute; l&yacute; do ch&iacute;nh đ&aacute;ng</h2>\n\n<p>Như t&agrave;i liệu React Native ch&iacute;nh thức n&ecirc;u r&otilde;, tất cả c&aacute;c yếu tố phản hồi n&ecirc;n c&oacute; phản hồi trực quan khi chạm v&agrave;o. H&atilde;y ghi nhớ điều n&agrave;y khi tạo c&aacute;c th&agrave;nh phần UI của bạn v&agrave; sử dụng &lt;TouchableWithoutFeedback&gt; một c&aacute;ch tiết kiệm.</p>\n\n<p>Một điểm đ&aacute;ng ch&uacute; &yacute; nữa l&agrave; TouchableWithoutFeedback chỉ chấp nhận c&oacute; duy nhất 1 phần tử children, h&atilde;y lưu &yacute; bọc c&aacute;c th&agrave;nh phần con của n&oacute; trong 1 wrapper để kh&ocirc;ng gặp lỗi đỏ cả m&agrave;n h&igrave;nh&nbsp;<img alt=\"\uD83D\uDE03\" src=\"https://twemoji.maxcdn.com/2/72x72/1f603.png\" />)</p>\n\n<h2>10. Sửa đổi nội dung của 1 array state sẽ kh&ocirc;ng g&acirc;y ra re-render</h2>\n\n<p>Chắc chắn đ&atilde; c&oacute; l&uacute;c bạn c&oacute; 1 state l&agrave; 1 array, khi bạn thay đổi state n&agrave;y nhưng flatList b&ecirc;n dưới sử dụng state n&agrave;y lại kh&ocirc;ng chịu render lại (v&iacute; dụ bạn xo&aacute; 1 phần tử trong array, nhưng flatList vẫn y như cũ, mặc d&ugrave; về l&yacute; l&agrave; state thay đổi th&igrave; view phải re-render). Sự thật th&igrave; kh&ocirc;ng, chỉnh sửa một phần tử của array state, sẽ kh&ocirc;ng l&agrave;m view re-render.</p>\n\n<p>Để tr&aacute;nh trường hợp n&agrave;y, thay v&igrave; d&ugrave;ng trực tiếp array state đ&oacute; để l&agrave;m data cho flatList h&atilde;y deep copy n&oacute; (c&oacute; thể sử dụng h&agrave;m cloneDeep của Lodash) hoặc đơn giản l&agrave; object assign ([...array]). V&agrave; rồi flatList hay view của bạn sẽ re-render như bạn muốn.</p>\n\n<p>Source:&nbsp;<a href=\"https://medium.com/mop-developers/50-react-native-tips-part-1-2-5cb12803228b\" target=\"_blank\">https://medium.com/mop-developers/50-react-native-tips-part-1-2-5cb12803228b</a></p>\n",
      "category_id": 1,
      "total_views": 100,
      "status": true,
      "image": "post-1.jpg",
      "tags": [
        "react native"
      ]
    },
    {
      "title": "So sánh Interface và Abstract trong lập trình hướng đối tượng.",
      "content": "<h1>Tổng quan</h1>\n\n<p><code>Interface</code>&nbsp;v&agrave;&nbsp;<code>Abstract</code>&nbsp;class l&agrave; 2 kh&aacute;i niệm cơ bản trong lập tr&igrave;nh OOP. Nhưng ph&acirc;n lớn mọi người cảm thấy mơ hồ v&agrave; lẫn lộn 2 kh&aacute;i niệm n&agrave;y. Vậy ch&uacute;ng l&agrave; g&igrave;, kh&aacute;c nhau như n&agrave;o? Tại sao d&ugrave;ng c&aacute;i n&agrave;y&nbsp;<code>Interface</code>&nbsp;m&agrave; kh&ocirc;ng phải&nbsp;<code>Abstract</code>&nbsp;v&agrave; ngược lại ???</p>\n\n<h1>Is-a v&agrave; Can-do</h1>\n\n<p>Bỏ qua tất cả những phần về l&yacute; thuyết của việc tạo một&nbsp;<code>abstract class</code>&nbsp;v&agrave;&nbsp;<code>interface</code>. Bạn kh&ocirc;ng cần quan t&acirc;m nhiều đến việc abstract c&oacute; thể khai b&aacute;o những g&igrave;, hay&nbsp;<code>interface</code>&nbsp;c&oacute; được ph&eacute;p định nghĩa nội dung phương thức hay kh&ocirc;ng. Điểm cơ bản khi bạn được hỏi về sự kh&aacute;c biệt giữa ch&uacute;ng l&agrave; g&igrave;? Đ&oacute; ch&iacute;nh l&agrave; mục đ&iacute;ch m&agrave; ch&uacute;ng được sử dụng:</p>\n\n<p>&ndash;&nbsp;<code>Abstract class</code>: l&agrave; một class cha cho tất cả c&aacute;c class c&oacute; c&ugrave;ng bản chất. Bản chất ở đ&acirc;y được hiểu l&agrave; kiểu, loại, nhiệm vụ của class. Hai class c&ugrave;ng hiện thực một interface c&oacute; thể ho&agrave;n to&agrave;n kh&aacute;c nhau về bản chất. Hiểu đơn giản như một thằng con (child class) chỉ c&oacute; thể l&agrave; con của một thằng cha, c&oacute; t&iacute;nh c&aacute;ch giống cha (abstract class) n&oacute;.</p>\n\n<p>&ndash;&nbsp;<code>Interface</code>: l&agrave; một&nbsp;<code>chức năng</code>&nbsp;m&agrave; bạn c&oacute; thể th&ecirc;m v&agrave; bất k&igrave; class n&agrave;o. Từ chức năng ở đ&acirc;y kh&ocirc;ng đồng nghĩa với phương thức (hoặc h&agrave;m). Interface c&oacute; thể bao gồm nhiều h&agrave;m/phương thức v&agrave; tất cả ch&uacute;ng c&ugrave;ng phục vụ cho một&nbsp;<code>chức năng</code>.</p>\n\n<p>Vậy, bạn kh&ocirc;ng n&ecirc;n nhầm lẫn khi n&oacute;i về việc một class được&nbsp;<code>implement</code>&nbsp;hay&nbsp;<code>extend</code>. Nhiều người thường hay đồng nhất l&agrave; kh&ocirc;ng ph&acirc;n biệt hai từ n&agrave;y, nhưng ch&iacute;nh ch&uacute;ng đ&atilde; n&oacute;i l&ecirc;n sự kh&aacute;c biệt giữa interface v&agrave; abstract class. Bạn chỉ c&oacute; thể thừa kế (extend) từ một class v&agrave; chỉ c&oacute; thể hiện thực (implement) c&aacute;c chức năng (interface) cho class của m&igrave;nh. Theo c&aacute;ch ngắn gọn, quan hệ giữa một class khi thừa kế một abstract class được gọi l&agrave;&nbsp;<code>is-a</code>, v&agrave; một class khi hiện thực một interface được gọi l&agrave;&nbsp;<code>can-do</code>&nbsp;(hoặc &ndash;<code>able</code>).</p>\n\n<p>H&atilde;y xem v&iacute; dụ sau, t&ocirc;i c&oacute;:</p>\n\n<ul>\n\t<li>Interface: Barkable, Runable, Flyable, Swimable.</li>\n\t<li>Abstract class Animal v&agrave; c&aacute;c sub class: Bolt, AngryBird v&agrave; Nemo.</li>\n\t<li>Abstract class Machine v&agrave; c&aacute;c sub class: McQueen, Siddeley.&nbsp;<img alt=\"\" src=\"https://viblo.asia/uploads/0b503d7f-4e21-4447-a0a2-9ae31856df3c.png\" /></li>\n</ul>\n\n<p>Như bạn thấy, mặc d&ugrave; cả McQueen v&agrave; Bolt đều được hiện thực interface Runable, nhưng ch&uacute;ng ho&agrave;n to&agrave;n thuộc hai loại kh&aacute;c nhau. V&agrave; tất nhi&ecirc;n một class c&oacute; thể&nbsp;<code>can-do</code>&nbsp;nhiều thứ, v&iacute; dụ như Bolt c&oacute; thể chạy v&agrave; sủa.</p>\n\n<p><img alt=\"\" src=\"https://viblo.asia/uploads/892cc67b-7f60-4228-9f67-849f0c8d0a94.png\" /></p>\n\n<p>D&ugrave;ng Interface như một &ldquo;bản thiết kế&rdquo; của class? Đ&acirc;y l&agrave; một điều thường được d&ugrave;ng để trả lời cho hai c&acirc;u hỏi:</p>\n\n<ul>\n\t<li><code>Interface</code>&nbsp;được d&ugrave;ng để l&agrave;m g&igrave;?</li>\n\t<li>Tại sao kh&ocirc;ng thể định nghĩa phần th&acirc;n cho c&aacute;c phương thức của&nbsp;<code>interface</code>.</li>\n</ul>\n\n<p>X&eacute;t ở một mức độ n&agrave;o đ&oacute; điều n&agrave;y l&agrave; hợp l&yacute;, nhưng như đ&atilde; n&oacute;i ở phần tr&ecirc;n, n&oacute; chỉ được d&ugrave;ng để m&ocirc; tả một&nbsp;<code>bản thiết kế</code>&nbsp;cho một&nbsp;<code>chức năng</code>&nbsp;của class. Nếu muốn tạo một bản thiết kế tổng thể, h&atilde;y sử dụng&nbsp;<code>abstract class</code>. Một bản thiết kế tổng thể tất nhi&ecirc;n sẽ c&oacute; những thứ đ&atilde; được dựng sẵn v&agrave; c&oacute; những thứ l&agrave;&nbsp;<code>abstract</code>.</p>\n\n<p>Một c&acirc;u trả lời c&oacute; thể l&yacute; giải phần n&agrave;o c&acirc;u hỏi thứ hai l&agrave; việc cho ph&eacute;p định nghĩa th&acirc;n phương thức trong c&aacute;c interface c&oacute; thể khiến cho hiệu suất bị giảm s&uacute;t. Nguy&ecirc;n nh&acirc;n l&agrave; việc t&igrave;m kiếm c&aacute;c phương thức sẽ diễn ra l&acirc;u hơn v&igrave; phải duyệt qua c&aacute;c interface, thay v&igrave; chỉ cần phải t&igrave;m trong class cha của n&oacute;.</p>\n\n<p>Về c&ocirc;ng dụng của&nbsp;<code>interface</code>, x&eacute;t ở mức ứng dụng, c&aacute;c interface c&oacute; thể được hiểu như c&aacute;c plugin hoặc thư viện/phần mềm&nbsp;<code>third-party</code>. Việc hiện thực một&nbsp;<code>interface</code>&nbsp;cho class cũng giống như c&agrave;i th&ecirc;m plugin cho một phần mềm vậy.</p>\n\n<h1>Bảng so s&aacute;nh</h1>\n\n<p>Cuối c&ugrave;ng, cũng n&ecirc;n liệt k&ecirc; c&aacute;c điểm kh&aacute;c biệt giữa hai kh&aacute;i niệm n&agrave;y để bạn c&oacute; thể sử dụng được khi cần thiết. C&aacute;c điểm kh&aacute;c biệt n&agrave;y c&oacute; thể kh&aacute;c nhau t&ugrave;y v&agrave;o ng&ocirc;n ngữ m&agrave; bạn sử dụng. V&igrave; vậy bạn chỉ cần nhớ c&aacute;c điểm căn bản sau:</p>\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>&nbsp;</th>\n\t\t\t<th>Interface</th>\n\t\t\t<th>Abstract class</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>Multiple inheritance</td>\n\t\t\t<td>Một class c&oacute; thể hiện thực nhiều interface.(tạm coi l&agrave; thừa kế)</td>\n\t\t\t<td>Kh&ocirc;ng hỗ trợ đa thừa kế</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Default implementation</td>\n\t\t\t<td>Kh&ocirc;ng thể định nghĩa code xử l&yacute;, chỉ c&oacute; thể khai b&aacute;o.</td>\n\t\t\t<td>C&oacute; thể định nghĩa th&acirc;n phương thức, property.</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Access Modifiers</td>\n\t\t\t<td>Mọi phương thức, property đều mặc định l&agrave; public.</td>\n\t\t\t<td>C&oacute; thể x&aacute;c định modifier.</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Adding functionality</td>\n\t\t\t<td>Mọi phương thức, property của interface cần được hiện thực trong class.</td>\n\t\t\t<td>Kh&ocirc;ng cần thiết.</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Fields and Constants</td>\n\t\t\t<td>Kh&ocirc;ng</td>\n\t\t\t<td>C&oacute;</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<h1>Tham khảo</h1>\n\n<ul>\n\t<li><a href=\"http://php.net/manual/en/language.oop5.abstract.php\" target=\"_blank\">http://php.net/manual/en/language.oop5.abstract.php</a></li>\n\t<li><a href=\"https://yinyangit.wordpress.com/2012/01/15/oop-interface-vs-abstract-class/\" target=\"_blank\">https://yinyangit.wordpress.com/2012/01/15/oop-interface-vs-abstract-class/</a></li>\n</ul>\n",
      "category_id": 1,
      "total_views": 200,
      "status": false,
      "image": "post-2.jpg",
      "tags": [
        "oop", "Interface"
      ]
    },
    {
      "title": "Tư duy về cách giải quyết vấn đề cho lập trình viên.",
      "content": "<p>Ch&acirc;n của bạn bắt đầu bị chuột r&uacute;t mười ph&uacute;t trước, nhưng dường như bạn kh&ocirc;ng cảm nhận được điều đ&oacute;.</p>\n\n<p>Cuộc tr&ograve; chuyện từ một chiếc TV ở xa kh&ocirc;ng c&oacute; g&igrave; ngo&agrave;i tiếng ồn, một lời nhắc nhở nhẹ nh&agrave;ng về thế giới b&ecirc;n ngo&agrave;i.</p>\n\n<p>Trọng t&acirc;m duy nhất của bạn l&agrave; &acirc;m thanh từ c&aacute;c n&uacute;t tr&ecirc;n b&agrave;n ph&iacute;m của bạn. Click Click Click...Tạo một đối tượng mới...Phương thức insert...Khoảnh khắc khi bạn kiểm tra c&aacute;c d&ograve;ng code m&agrave; bạn vừa th&ecirc;m v&agrave;o...Th&agrave;nh c&ocirc;ng! Tuyệt vời, v&agrave; b&acirc;y giờ bạn chỉ cần th&ecirc;m một chức năng cuối c&ugrave;ng...console.log...chạy...bị sai! C&aacute;i g&igrave; vậy? D&ograve;ng n&agrave;o g&acirc;y ra lỗi vậy?</p>\n\n<p>Viết code, d&ugrave; bạn c&oacute; bao nhi&ecirc;u kinh nghiệm về n&oacute;, cũng giống như đi tr&ecirc;n d&acirc;y vậy. Bạn đ&atilde; cố gắng c&acirc;n bằng nhất, dựa tr&ecirc;n kiến thức về ng&ocirc;n ngữ v&agrave; mức độ bạn c&oacute; thể x&acirc;y dựng một giải ph&aacute;p cho một vấn đề m&agrave; bạn nghĩ ra. B&ecirc;n tr&aacute;i v&agrave; b&ecirc;n hải của bạn, kh&ocirc;ng c&oacute; g&igrave; cả - chỉ l&agrave; một chương tr&igrave;nh bị sai v&agrave; xuất hiện th&ocirc;ng b&aacute;o lỗi. Khi bạn gặp n&oacute; (v&agrave; n&oacute; xảy ra với tất cả mọi người), một số th&ocirc;ng b&aacute;o lỗi c&oacute; thể gi&uacute;p bạn ph&aacute;t hiện được nơi ph&aacute;t sinh ra lỗi, c&ograve;n 1 số th&igrave; lại th&ocirc;ng b&aacute;o chung chung, rất kh&oacute; để gi&uacute;p bạn t&igrave;m ra điểm g&acirc;y ra bug. Th&ocirc;ng thường, chỉ cần 1 lần viết lại v&agrave; sửa lại chỗ ph&aacute;t sinh ra bug sẽ gi&uacute;p chương tr&igrave;nh hoạt động trở lại.</p>\n\n<p>Nhưng điều g&igrave; xảy ra khi bạn gặp bế tắc khi cố gắng giải quyết vấn đề? Nh&igrave;n v&agrave;o hơn 200 d&ograve;ng tr&ecirc;n m&aacute;y t&iacute;nh dường như rất quen thuộc với bạn chỉ một gi&acirc;y trước, nhưng ngay sau đ&oacute; th&igrave; mọi thứ đều trở n&ecirc;n lạ lẫm. L&agrave;m thế n&agrave;o để bạn l&agrave;m việc theo c&aacute;ch của m&igrave;nh, trong khi vẫn giữ cả những thay đổi v&agrave; những d&ograve;ng mới m&agrave; bạn vừa th&ecirc;m?</p>\n\n<h2>Step 0: Kiểm tra c&uacute; ph&aacute;p/ lỗi ch&iacute;nh tả</h2>\n\n<p>R&otilde; r&agrave;ng? Chắc chắn, nhưng t&ocirc;i nhận thấy rằng 98% sai lầm của t&ocirc;i đến từ một dấu phẩy bị đặt sai hoặc một lỗi sai ch&iacute;nh tả . Code l&agrave; một đoạn m&atilde; kh&ocirc;ng thể th&ecirc;m tuỳ tiện một chữ c&aacute;i hay c&uacute; ph&aacute;p bị thiếu c&oacute; thể ph&aacute; vỡ to&agrave;n bộ c&aacute;c tệp. Tin tốt l&agrave; hầu hết c&aacute;c IDE đều đi k&egrave;m c&aacute;c t&iacute;nh năng gi&uacute;p bạn bắt lỗi nhanh hơn. T&ocirc;i th&iacute;ch những điều sau đ&acirc;y: Tự động ho&agrave;n th&agrave;nh, ph&aacute;t hiện lỗi, m&atilde; ho&aacute; m&agrave;u. Điều cuốic c&ugrave;ng l&agrave;m t&ocirc;i ưa th&iacute;ch bởi v&igrave; điều đ&oacute; c&oacute; nghĩa t&ocirc;i lướt qua một chuỗi c&aacute;c đoạn văn bản m&agrave;u cam v&agrave; nhận thấy c&oacute; một stinker nhỏ m&agrave;u đỏ với dấu ngoặc k&eacute;p bị thiếu v&agrave; ngay lập tức t&ocirc;i c&oacute; thể sửa n&oacute; lu&ocirc;n. Nhưng nếu đ&atilde; sửa hết những lỗi n&agrave;y m&agrave; kh&ocirc;ng thấy th&agrave;nh c&ocirc;ng th&igrave; h&atilde;y tự hỏi bản th&acirc;n...</p>\n\n<h2>Step 1: Bạn biết g&igrave; về n&oacute;?</h2>\n\n<p>C&oacute; thể bạn cảm thấy bực bội khi sự tự tin của bạn bị ph&aacute; vỡ bởi những &quot;ERROR&quot; m&agrave;u đỏ tr&ecirc;n m&agrave;n h&igrave;nh. Nhưng bạn đ&atilde; tự b&igrave;nh tĩnh lại được, điều nay c&oacute; nghĩa l&agrave; bạn đủ biết để tự t&igrave;m ra c&aacute;ch sửa lỗi. V&igrave; vậy trước ti&ecirc;n bạn n&ecirc;n chọn ra th&ocirc;ng b&aacute;o lỗi v&agrave; ghi ch&uacute; lại.</p>\n\n<p>&ldquo;Syntax error&hellip;T&ocirc;i đ&atilde; nh&igrave;n thấy điều n&agrave;y trước đ&acirc;y v&agrave; lần cuối c&ugrave;ng n&oacute; chỉ l&agrave; một lỗi đ&aacute;nh m&aacute;y.&rdquo;</p>\n\n<p>&ldquo;Null value&hellip;.T&ocirc;i biết điều đ&oacute; c&oacute; nghĩa l&agrave; một số gi&aacute; trị kh&ocirc;ng được x&aacute;c định hoặc n&oacute; kh&ocirc;ng tồn tại. V&agrave; t&ocirc;i cũng biết rằng n&oacute; c&oacute; lẽ được coi l&agrave; &lsquo;false.&rdquo;</p>\n\n<p>Một điều kh&aacute;c m&agrave; bạn c&oacute; thể thử đ&oacute; l&agrave;, nếu bạn th&ecirc;m nhiều d&ograve;ng m&atilde; th&igrave; h&atilde;y thử t&aacute;ch ch&uacute;ng ra ri&ecirc;ng biệt rồi đọc ch&uacute;ng một c&aacute;ch lần lượt, tự hỏi bản th&acirc;n chức năng của từng d&ograve;ng v&agrave; nhắc nhở bản th&acirc;n về định nghĩa. C&oacute; thể bạn đ&atilde; qu&ecirc;n to&aacute;n tử &quot;OR&quot;, hay đ&atilde; qu&ecirc;n c&aacute;ch tạo h&agrave;m của một đối tượng. Điều n&agrave;y dẫn t&ocirc;i đến bước tiếp theo.</p>\n\n<h2>Step 2: Bạn c&oacute; bỏ lỡ điều g&igrave; kh&ocirc;ng?</h2>\n\n<p>Ở đ&acirc;y, c&oacute; thể thực sự hữu &iacute;ch để tạo một danh s&aacute;ch những g&igrave; bạn kh&ocirc;ng quen thuộc. Bạn c&oacute; biết d&ograve;ng m&atilde; n&agrave;o l&agrave; vấn đề kh&ocirc;ng? Nếu kh&ocirc;ng, kiểm tra lại th&ocirc;ng b&aacute;o lỗi để c&ocirc; lập vấn đề. C&oacute; từ mới n&agrave;o trong th&ocirc;ng b&aacute;o lỗi m&agrave; bạn đ&atilde; thấy trước đ&oacute; kh&ocirc;ng? Bạn c&oacute; đang thực h&agrave;nh một kh&aacute;i niệm mới, một kh&aacute;i niệm phức tạp v&agrave; c&oacute; thể tương t&aacute;c với đoạn m&atilde; của bạn theo c&aacute;ch m&agrave; bạn mong đợi kh&ocirc;ng? Nếu đ&oacute; l&agrave; trường hợp kh&aacute;c th&igrave; bạn c&oacute; thể cần bước tiếp theo...</p>\n\n<h2>Step 3: Nghi&ecirc;n cứu từ những nguồn mới</h2>\n\n<p>Đ&acirc;y l&agrave; phần thực h&agrave;nh y&ecirc;u th&iacute;ch của t&ocirc;i về tiền m&atilde; h&oacute;a. Mỗi ng&agrave;y bạn c&oacute; thể phải đối mặt với một thử th&aacute;ch mới v&agrave; mỗi ng&agrave;y thử th&aacute;ch đ&oacute; c&oacute; thể l&agrave; cơ hội để ph&aacute;t triển. Lượng t&agrave;i nguy&ecirc;n c&oacute; sẵn trực tuyến cho lập tr&igrave;nh m&aacute;y t&iacute;nh l&agrave; đ&aacute;ng kinh ngạc. Từ c&aacute;c b&agrave;i viết ph&aacute; vỡ c&aacute;c trường hợp rất cụ thể, tất cả c&aacute;c c&aacute;ch để ho&agrave;n th&agrave;nh c&aacute;c kh&oacute;a học Ivy League. Cố gắng đừng cảm thấy nản l&ograve;ng khi bạn gặp phải một ng&ocirc;n ngữ lập tr&igrave;nh / kh&aacute;i niệm mới rất lớn v&agrave; điều n&agrave;y c&oacute; thể xảy ra mỗi ng&agrave;y! Thay v&agrave;o đ&oacute;, h&atilde;y thử xem n&oacute; như một lời mời để nghi&ecirc;n cứu những thứ mới mẻ. Biết đ&acirc;u điều đọc thực sự khiến bạn cảm thấy hứng th&uacute;.</p>\n\n<h2>Step 4: T&igrave;m ai đ&oacute; chia sẻ về vấn của bạn.</h2>\n\n<p>Điều đầu ti&ecirc;n bạn n&ecirc;n lạc quan rằng, chắc chắn kh&ocirc;ng phải một m&igrave;nh bạn phải đối diện với n&oacute; đ&acirc;u. B&ecirc;n cạnh bạn, tại bất kỳ nơi bạn l&agrave;m việc n&agrave;o, cũng cũng những người đi trước, hoặc c&oacute; những &quot;si&ecirc;u nh&acirc;n&quot; để bạn c&oacute; thể mở lời để nhận được sự gi&uacute;p đỡ từ họ. B&ecirc;n cạnh đ&oacute;, bạn c&ograve;n c&oacute; cả một cộng đồng lập tr&igrave;nh vi&ecirc;n tr&ecirc;n to&agrave;n thế giới cũng với những diễn đ&agrave;n c&ocirc;ng nghệ giải đ&aacute;p mọi thắc mắc m&agrave; bạn găp phải. Chắc hẳn mọi lập tr&igrave;nh vi&ecirc;n đều biết đến StackOverFlow. Dường như mọi vấn đề bạn c&oacute; thể t&igrave;m ở đ&oacute;. Bạn cũng c&oacute; thể t&igrave;m những sự gi&uacute;p đỡ từ ch&iacute;nh những người đ&ograve;ng nghiệp của bạn. Bất kể bạn ở đ&acirc;u với sự ph&aacute;t triển chuy&ecirc;n nghiệp của m&igrave;nh, v&agrave; cho d&ugrave; bạn đang l&agrave;m g&igrave;, th&igrave; điều tốt nhất v&agrave; quan trọng nhất bạn c&oacute; thể l&agrave;m l&agrave; tiếp tục, v&agrave; kh&ocirc;ng bỏ cuộc. Mọi vấn đề đều c&oacute; c&aacute;ch giải quyết của n&oacute; hết.</p>\n\n<p>Nguồn t&agrave;i liệu:&nbsp;<a href=\"https://medium.com/@michaelchrupcala/dev-mindset-how-to-fix-a-new-problem-264e3125e7a3\" target=\"_blank\">https://medium.com/@michaelchrupcala/dev-mindset-how-to-fix-a-new-problem-264e3125e7a3</a></p>\n",
      "category_id": 1,
      "total_views": 456,
      "status": true,
      "image": "post-3.jpg",
      "tags": [
        "Mindset"
      ]
    },
    {
      "title": "Giới thiệu UUID trong Java",
      "content": "<h2>1. Đ&ocirc;i n&eacute;t</h2>\n\n<p>UUID (Viết tắt của Universally Unique Identifier), c&ograve;n được gọi l&agrave; GUID (Globally Unique Identifier) l&agrave; một gi&aacute; trị duy nhất d&agrave;i 128 bit. Một chuỗi UUID chuẩn sử dụng chữ số hex (octet):</p>\n\n<blockquote>\n<p>0710a5ca-f57e-11e9-802a-5aa538984bd8</p>\n</blockquote>\n\n<p><img alt=\"\" src=\"https://images.viblo.asia/74fbd277-6c7e-4d1f-9687-a52d21497c94.png\" />Mục đ&iacute;ch của UUID sinh ra l&agrave; bởi v&igrave;:</p>\n\n<ul>\n\t<li>Dữ liệu lớn, kiểu kh&oacute;a ch&iacute;nh auto imcrement cần nhiều byte để lưu hơn. V&agrave; kh&oacute;a ch&iacute;nh kiểu n&agrave;y kh&ocirc;ng ph&ugrave; hợp khi m&agrave; hệ thống c&oacute; nhiều server, nhiều client c&ugrave;ng l&uacute;c truy cập tr&ecirc;n to&agrave;n thế giới.</li>\n\t<li>Nếu d&ugrave;ng kh&oacute;a ch&iacute;nh kiểu auto imcrement, c&oacute; thể dễ d&agrave;ng truy ra được trong database c&oacute; bao nhi&ecirc;u record. Thường thấy ở đường dẫn kiểu &quot;<a href=\"http://domain.com/user/12345\" target=\"_blank\">domain.com/user/12345</a>&quot;.</li>\n</ul>\n\n<p>Bởi vậy UUID ra đời nhằm khắc phục những yếu điểm tr&ecirc;n. Vậy nếu bạn đủ sức x&acirc;y dựng một hệ thống với nhiều server, phục vụ h&agrave;ng tỉ tỉ user hoặc chỉ đơn giản l&agrave; kh&ocirc;ng muốn để lộ id ra ngo&agrave;i, h&atilde;y nghĩ tới UUID.</p>\n\n<p>Trong b&agrave;i n&agrave;y, ch&uacute;ng ta sẽ c&ugrave;ng t&igrave;m hiểu về UUID trong Java, th&ocirc;ng qua class UUID.</p>\n\n<h2>2. Cấu tr&uacute;c chuỗi UUID</h2>\n\n<p>Ch&uacute;ng ta c&ugrave;ng xem v&iacute; dụ về chuỗi UUID:</p>\n\n<pre>\n<code>123e4567-e89b-42d3-a456-556642440000\nxxxxxxxx-xxxx-Bxxx-Axxx-xxxxxxxxxxxx\n</code></pre>\n\n<p>A đại diện cho biến thể (variant) x&aacute;c định bố cục (layout) của UUID. Tất cả c&aacute;c bit kh&aacute;c trong UUID phụ thuộc v&agrave;o setting của c&aacute;c bit trong trường biến thể (variant field). Biến thể được x&aacute;c định bởi 3 bit quan trọng nhất của A:</p>\n\n<pre>\n<code>MSB1    MSB2    MSB3\n 0       X       X     reserved (0)\n 1       0       X     current variant (2)\n 1       1       0     reserved for Microsoft (6)\n 1       1       1     reserved for future (7)\n</code></pre>\n\n<p>Gi&aacute; trị của A trong UUID l&agrave; &#39;a &#39;. Tương đương nhị ph&acirc;n của &#39;a&#39; (=10xx) hiển thị biến thể l&agrave; 2. B đại diện cho phi&ecirc;n bản (version). Phi&ecirc;n bản trong UUID (gi&aacute; trị của B) l&agrave; 4.</p>\n\n<p>Java cung cấp c&aacute;c phương thức để lấy ra variant (biến thể) v&agrave; version (phi&ecirc;n bản) của UUID như sau:</p>\n\n<pre>\n<code>UUID uuid = UUID.randomUUID();\nint variant = uuid.variant();\nint version = uuid.version();\n</code></pre>\n\n<p>Đ&acirc;y l&agrave; 5 phi&ecirc;n bản kh&aacute;c nhau cho UUID biến thể 2: Time Based (UUIDv1), DCE Security (UUIDv2), Name Based (UUIDv3 v&agrave; UUIDv5), Random (UUIDv4).</p>\n\n<p>Java c&oacute; cung cấp một implementation cho v3 v&agrave; v4, nhưng cũng cung cấp một constructor để gi&uacute;p người d&ugrave;ng tạo bất kỳ loại UUID n&agrave;o:</p>\n\n<pre>\n<code>UUID uuid = new UUID(long mostSigBits, long leastSigBits);\n</code></pre>\n\n<h3>Version 3 &amp; 5</h3>\n\n<p>C&aacute;c UUID được tạo bằng c&aacute;ch sử dụng h&agrave;m băm của namespace v&agrave; name. C&aacute;c định danh namespace l&agrave; c&aacute;c UUID giống như Domain Name System (DNS), Object Identifiers (OIDs), URLs,...</p>\n\n<pre>\n<code>UUID = hash(NAMESPACE_IDENTIFIER + NAME)\n</code></pre>\n\n<p>Sự kh&aacute;c biệt duy nhất giữa UUIDv3 v&agrave; UUIDv5 l&agrave; Thuật to&aacute;n băm (Hashing Algorithm) - v3 sử dụng MD5 (128 bit) trong khi v5 sử dụng SHA-1 (160 bit). N&oacute;i một c&aacute;ch đơn giản, ch&uacute;ng ta cắt bớt kết quả băm th&agrave;nh 128 bit v&agrave; sau đ&oacute; thay thế 4 bit cho version (phi&ecirc;n bản) v&agrave; 2 bit cho variant (biến thể).</p>\n\n<p>V&agrave; đ&acirc;y l&agrave; c&aacute;ch tạo UUID loại 3 trong java:</p>\n\n<pre>\n<code>String source = namespace + name;\nbyte[] bytes = source.getBytes(&quot;UTF-8&quot;);\nUUID uuid = UUID.nameUUIDFromBytes(bytes);\n</code></pre>\n\n<p>Java kh&ocirc;ng cung cấp implementation cho UUID loại 5.</p>\n\n<h3>Version 4</h3>\n\n<p>Implementation của UUID v4 trong Java sử dụng c&aacute;c số ngẫu nhi&ecirc;n. Class được java implement l&agrave; SecureRandom. N&oacute; sử dụng một gi&aacute; trị kh&ocirc;ng thể đo&aacute;n trước để tạo ra c&aacute;c số ngẫu nhi&ecirc;n nhằm giảm tỷ lệ tr&ugrave;ng. Để sinh chuỗi UUID v4, bạn sử dụng:</p>\n\n<pre>\n<code>UUID uuid = UUID.randomUUID();\n</code></pre>\n\n<p>Bạn c&oacute; thể sinh unique key sử dụng &lsquo;SHA-256&#39; v&agrave; UUID như sau:</p>\n\n<pre>\n<code>MessageDigest salt = MessageDigest.getInstance(&quot;SHA-256&quot;);\nsalt.update(UUID.randomUUID().toString().getBytes(&quot;UTF-8&quot;));\nString digest = bytesToHex(salt.digest());\n</code></pre>\n\n<h2>3. Kết luận</h2>\n\n<p>Cả UUIDv3 v&agrave; UUIDv5 đều c&oacute; những điểm tốt m&agrave; c&aacute;c hệ thống kh&aacute;c nhau c&oacute; thể tạo ra c&ugrave;ng một UUID bằng c&aacute;ch sử dụng c&ugrave;ng một namespace v&agrave; name. Ch&uacute;ng cơ bản được sử dụng để tạo UUID ph&acirc;n cấp.</p>\n\n<p>V&igrave; cả hai h&agrave;m băm MD5 v&agrave; SHA1 đều bị hỏng, n&ecirc;n tốt nhất khuyện bạn sử dụng v5. Nếu bạn chỉ cần tạo UUID đơn giản, loại 4 c&oacute; thể đ&aacute;p ứng tốt cho ứng dụng của bạn.</p>\n",
      "category_id": 1,
      "total_views": 456,
      "status": true,
      "image": "post-3.jpg",
      "tags": [
        "UUID", "Java"
      ]
    },
    {
      "title": "Deploy nodejs application on heroku",
      "content": "<h3>1. Mở đầu:</h3>\n\n<p>B&agrave;i viết n&agrave;y với mục đ&iacute;ch gi&uacute;p c&aacute;c bạn mới bắt đầu muốn deploy 1 ứng dụng Nodejs l&ecirc;n Heroku. Heroku l&agrave; một cloud platform như một dịch vụ hỗ trợ một số ng&ocirc;n ngữ lập tr&igrave;nh được sử dụng l&agrave;m m&ocirc; h&igrave;nh triển khai ứng dụng web. Heroku l&agrave; một nền tảng dưới dạng dịch vụ (PaaS) cho ph&eacute;p c&aacute;c nh&agrave; ph&aacute;t triển x&acirc;y dựng, chạy v&agrave; vận h&agrave;nh c&aacute;c ứng dụng ho&agrave;n to&agrave;n trong đ&aacute;m m&acirc;y. Heroku l&agrave; một nền tảng ứng dụng đ&aacute;m m&acirc;y đa ng&ocirc;n ngữ cho ph&eacute;p c&aacute;c nh&agrave; ph&aacute;t triển triển khai, mở rộng v&agrave; quản l&yacute; c&aacute;c ứng dụng của họ.</p>\n\n<h3>2. Register on the Heroku platform:</h3>\n\n<p>Đầu ti&ecirc;n ch&uacute;ng ta cần phải tạo 1 account tr&ecirc;n Heroku (tất nhi&ecirc;n l&agrave; loại free rồi&nbsp;<img alt=\"\uD83D\uDE04\" src=\"https://twemoji.maxcdn.com/2/72x72/1f604.png\" />). Ch&uacute;ng ta truy cập v&agrave;o đường link sau để đăng k&iacute; :&nbsp;<a href=\"https://signup.heroku.com/\" target=\"_blank\">https://signup.heroku.com/</a></p>\n\n<h3>3. Download and install CLI Heroku:</h3>\n\n<p>Ch&uacute;ng ta truy cập v&agrave;o link :&nbsp;<a href=\"https://devcenter.heroku.com/articles/heroku-cli\" target=\"_blank\">https://devcenter.heroku.com/articles/heroku-cli</a>&nbsp;để download phi&ecirc;n bản d&ugrave;ng cho hệ điều h&agrave;nh của m&igrave;nh.&nbsp;<img alt=\"\" src=\"https://images.viblo.asia/7d484417-55bb-4667-8be5-ace4c748bf8d.png\" /></p>\n\n<h3>4.Deploying Your Node App:</h3>\n\n<p>Về phần source code NodeJs t&ocirc;i kh&ocirc;ng nhắc tới trong phần n&agrave;y. N&ecirc;n c&aacute;c bạn c&oacute; thể tự chuẩn bị trước nh&eacute;&nbsp;<img alt=\"\uD83D\uDE04\" src=\"https://twemoji.maxcdn.com/2/72x72/1f604.png\" />.</p>\n\n<p>Đầu ti&ecirc;n ch&uacute;ng ta login account đ&atilde; đăng k&iacute; ở bước 1 v&agrave;o :&nbsp;<a href=\"https://id.heroku.com/login\" target=\"_blank\">https://id.heroku.com/login</a></p>\n\n<p>Sau đ&oacute; ch&uacute;ng ta tạo 1 new app tr&ecirc;n Heroku:</p>\n\n<p><img alt=\"\" src=\"https://images.viblo.asia/333fd5cf-6783-42b5-a2e8-52e686710534.png\" /></p>\n\n<p><img alt=\"\" src=\"https://images.viblo.asia/39d75cde-6ad1-4bab-88c7-33095ab487b3.png\" /></p>\n\n<p>Tiếp theo ch&uacute;ng ta sẽ d&ugrave;ng Terminal để deploy source v&agrave;o new app ch&uacute;ng ta vừa mới tạo tr&ecirc;n Heroku</p>\n\n<p>Đầu ti&ecirc;n login v&agrave;o heroku bằng Terminal&nbsp;<code>heroku login</code>&nbsp;Sau đ&oacute; tạo a new Git repository</p>\n\n<pre>\n<code>git init\nheroku git:remote -a viablo-demo\n</code></pre>\n\n<p>Giờ ch&uacute;ng ta deploy application của m&igrave;nh</p>\n\n<pre>\n<code>git add .\ngit commit -am &quot;the first deploy on heroku&quot;\ngit push heroku master\n</code></pre>\n\n<p>V&agrave; kết quả của ch&uacute;ng ta bằng c&aacute;ch truy cập v&agrave;o trang :&nbsp;<a href=\"https://viablo-demo.herokuapp.com/\" target=\"_blank\">https://viablo-demo.herokuapp.com</a>.</p>\n\n<p><img alt=\"\" src=\"https://images.viblo.asia/5121c6ce-7a72-4b20-b90d-10333d52e637.png\" /></p>\n\n<h3>5. Lời kết:</h3>\n\n<p>Hy vọng với b&agrave;i viết nhỏ n&agrave;y sẽ gi&uacute;p cho những người mới c&oacute; thể deploy được application đầu ti&ecirc;n của m&igrave;nh tr&ecirc;n Heroku.Ch&uacute;ng c&aacute;c bạn th&agrave;nh c&ocirc;ng</p>\n",
      "category_id": 1,
      "total_views": 456,
      "status": true,
      "image": "post-3.jpg",
      "tags": [
        "UUID", "Java"
      ]
    }

  ]
}