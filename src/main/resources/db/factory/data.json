{
  "tags": [
    "java",
    ".net",
    "spring boot",
    "spring mvc",
    "rest api",
    "react js",
    "angular",
    "javascript",
    "es6",
    "jquery",
    "nodejs",
    "python",
    "mongodb",
    "mysql",
    "postgresql",
    "java core",
    ".net core",
    "asp.net mvc",
    "ruby",
    "R",
    "dart",
    "kotlin",
    "android",
    "IOS",
    "react native",
    "flutter",
    "reactive programming",
    "java lambda expression",
    "java project lombok",
    "jsp and servlet",
    "thymeleaf",
    "fremarker",
    "velocity",
    "spring data jpa",
    "hibernate framework",
    "jdbc core and jdbc template"
  ],
  "posts": [
    {
      "title": "NoSQL DBMS - 1000 câu hỏi vì sao",
      "content": "<p>Hẳn anh em ở đ&acirc;y kh&ocirc;ng xa lạ g&igrave; với NoSQL DBMS lẫn thế mạnh của n&oacute;. Nhưng liệu ch&uacute;ng ta c&oacute; thực sự hiểu n&oacute;? Trước ti&ecirc;n, ta c&ugrave;ng điểm qua những thế mạnh v&agrave; điểm trừ của NoSQL DBMS đ&atilde; nh&eacute;!</p>\n\n<h3>Những thế mạnh v&agrave; điểm trừ của NoSQL DBMS</h3>\n\n<p><strong>Thế mạnh</strong></p>\n\n<ul>\n\t<li>Flexible, Elastic Scalability</li>\n\t<li>High Performance</li>\n\t<li>Economical</li>\n\t<li>Flexible Data Model*</li>\n</ul>\n\n<p><strong>Điểm trừ</strong></p>\n\n<ul>\n\t<li>Not mature, poor documentation</li>\n\t<li>Less Support.</li>\n</ul>\n\n<h3>Đặt vấn đề</h3>\n\n<p>V&igrave; sao NoSQL DMBS lại c&oacute; elastic scalability?<br />\nV&igrave; sao lại high performance?<br />\nV&igrave; sao NoSQL DBMS lại c&oacute; những thế mạnh n&agrave;y m&agrave; RDBMS kh&ocirc;ng c&oacute;?<br />\nDựa v&agrave;o đ&acirc;u, cấu tr&uacute;c x&acirc;y dựng hay l&agrave; cơ chế hoạt động?<br />\nTại sao RDBMS kh&ocirc;ng học theo NoSQL DBMS để c&oacute; những thế mạnh n&agrave;y?<br />\n...<br />\nB&agrave;i viết của m&igrave;nh sẽ giải th&iacute;ch to&agrave;n bộ những vấn đề n&agrave;y. Nếu anh em n&agrave;o biết rồi th&igrave; gi&uacute;p m&igrave;nh improve b&agrave;i viết n&agrave;y với nh&eacute;!</p>\n\n<h3>Giải th&iacute;ch về điểm yếu</h3>\n\n<p>Trước ti&ecirc;n, ta đi v&agrave;o điểm yếu. Một điểm yếu ch&iacute; mạng của NoSQL DBMS l&agrave; less support? Tại sao lại less support? Ngay cả khi ta đồng &yacute; chi tiền th&igrave; cũng vẫn kh&ocirc;ng support mạnh được. V&igrave;:</p>\n\n<ul>\n\t<li>NoSQL DBMS tuổi đời chưa cao, số lượng dự &aacute;n d&ugrave;ng ch&uacute;ng v&agrave; developer hoạt động với ch&uacute;ng cũng kh&ocirc;ng nhiều. L&yacute; do n&agrave;y cũng giải th&iacute;ch điểm trừ thứ nhất của NoSQL DBMS - not mature, poor documentation lu&ocirc;n.</li>\n\t<li>Vả lại, NoSQL DBMS lại c&oacute; nhiều loại ( 4 loại ch&iacute;nh), v&agrave; cấu tr&uacute;c lẫn c&aacute;ch hoạt động của c&aacute;c loại cũng kh&aacute;c &iacute;t nhiều n&ecirc;n số lượng người d&ugrave;ng lại c&agrave;ng chia nhỏ ra nữa.\n\t<p><a href=\"https://s3-ap-southeast-1.amazonaws.com/kipalog.com/o2foll73tx_image.png\"><img alt=\"alt text\" src=\"https://s3-ap-southeast-1.amazonaws.com/kipalog.com/o2foll73tx_image.png\" /></a></p>\n\t</li>\n</ul>\n\n<p>Anh em c&oacute; thể check ở&nbsp;<a href=\"https://db-engines.com/en/ranking\">DB-Engines Ranking</a>&nbsp;để thấy ch&ecirc;nh lệch giữa NoSQL DBMS v&agrave; RDBMS. NoSQL DBMS ph&aacute;t triển rất nhanh nhưng vẫn c&ograve;n rất nhỏ b&eacute; so với RDBMS. V&igrave; vậy khi ta gặp vấn đề cần support th&igrave; rất hiếm người giải đ&aacute;p (stackoverflow can&#39;t help you&nbsp;<img alt=\":laughing:\" src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f606.png\" style=\"height:20px; width:20px\" />), n&ecirc;n tốt nhất ta n&ecirc;n nắm r&otilde; cơ chế hoạt động v&agrave; bản chất của n&oacute;, nắm được rồi sẽ kh&ocirc;ng ngại vấn đề g&igrave; cả.&nbsp;<strong>Hơn nữa, nếu ta nắm r&otilde; được c&aacute;c điều đ&oacute; th&igrave; những thế mạnh của NoSQL DBMS sẽ được ta tận dụng triệt để, hợp l&yacute; nhất.</strong></p>\n\n<p>M&igrave;nh đ&atilde; giải th&iacute;ch về điểm trừ, c&ograve;n thế mạnh th&igrave; kh&ocirc;ng dễ để giải th&iacute;ch như điểm trừ đ&acirc;u. M&igrave;nh sẽ n&oacute;i về architecture tổng thể v&agrave; mechanism của NoSQL DBMS trước. Anh em n&ecirc;n c&oacute; kiến thức về&nbsp;<a href=\"https://kipalog.com/posts/Tong-quan-ve-Distributed-system\">Distributed system</a>&nbsp;sương sương để dễ d&agrave;ng hiểu hơn nha! Sau đ&acirc;y l&agrave; architecture tổng thể của NoSQL DBMS (m&igrave;nh lấy của 1 NoSQL DBMS kh&aacute; nổi hiện giờ l&agrave; MongoDB, cấu tr&uacute;c của c&aacute;c NoSQL DBMS sẽ tương tự như thế n&agrave;y th&ocirc;i, cũng đều handle replicationing v&agrave; sharding)</p>\n\n<p>&nbsp;</p>\n\n<p><a href=\"https://s3-ap-southeast-1.amazonaws.com/kipalog.com/d0g6oy4jvs_image.png\"><img alt=\"alt text\" src=\"https://s3-ap-southeast-1.amazonaws.com/kipalog.com/d0g6oy4jvs_image.png\" /></a></p>\n\n<h3>Replication</h3>\n\n<p>C&oacute; nhiều thể loại, tuỳ v&agrave;o DBMS, thường th&igrave; l&agrave; Primary-Secondary (tương tự như Master-Slave). C&oacute; một số DBMS như MongoDB th&igrave; lại c&oacute; th&ecirc;m kiểu Replica Set nhưng bản chất vẫn l&agrave; Master-Slave th&ocirc;i, chỉ l&agrave; support th&ecirc;m t&iacute;nh năng như automatic failover (xử l&yacute; trường hợp master lỗi).</p>\n\n<p>&nbsp;</p>\n\n<p><a href=\"https://s3-ap-southeast-1.amazonaws.com/kipalog.com/4qpxpb8hg_image.png\"><img alt=\"alt text\" src=\"https://s3-ap-southeast-1.amazonaws.com/kipalog.com/4qpxpb8hg_image.png\" /></a></p>\n\n<p><br />\nCơ chế hoạt động v&agrave; những lợi &iacute;ch mang lại của replication th&igrave; anh em cũng biết rồi, m&igrave;nh cũng đ&atilde; giải th&iacute;ch ở&nbsp;<a href=\"https://kipalog.com/posts/Tong-quan-ve-Distributed-system#toc-replication\">đ&acirc;y</a>: availability, request latency, read bandwidth, solve bottle neck-deadlock, backup, geographic location. Lợi &iacute;ch quan trọng nhất vẫn l&agrave; availability v&agrave; back-up.<br />\nSong song với c&aacute;ch implement th&igrave; lu&ocirc;n lu&ocirc;n c&oacute; c&aacute;c vấn đề cần giải quyết, nổi trội nhất vẫn l&agrave; consistency, ngo&agrave;i ra c&ograve;n c&aacute;c vấn đề kh&aacute;c nữa như Master c&oacute; vấn đề (Slave c&oacute; vấn đề th&igrave; đơn giản rồi ). L&uacute;c đ&oacute; DBMS sẽ phải chọn Master mới trong số những Replication c&ograve;n lại để c&oacute; thể handle c&aacute;c request write, c&oacute; thể dựa v&agrave;o Arbiter. Anh em n&ecirc;n để &yacute; những case n&agrave;y nghen, nếu DBMS kh&ocirc;ng support th&igrave; phải tự handle, nếu DBMS support rồi th&igrave; thơm nhưng anh em n&ecirc;n hiểu r&otilde; n&oacute; để control được 100%.</p>\n\n<h3>Sharding</h3>\n\n<p>Cấu tr&uacute;c</p>\n\n<p>L&agrave; horizontal partitioning (tr&aacute;i ngược vertical partitioning - chia theo column). Sharding l&agrave;m một việc l&agrave; distribute những document ra tr&ecirc;n c&aacute;c shard ri&ecirc;ng. Anh em nh&igrave;n h&igrave;nh dưới n&egrave;:</p>\n\n<p>&nbsp;</p>\n\n<p><a href=\"https://s3-ap-southeast-1.amazonaws.com/kipalog.com/rlcjldoosy_image.png\"><img alt=\"alt text\" src=\"https://s3-ap-southeast-1.amazonaws.com/kipalog.com/rlcjldoosy_image.png\" /></a></p>\n\n<p><br />\n1 collection (tương đương 1 indices trong Elasticsearch, tuỳ c&aacute;ch đặt t&ecirc;n của c&aacute;c DBMS th&ocirc;i) tương đương với table trong RDBMS, l&agrave; tập hợp những document c&oacute; đặc điểm chung với nhau. Ri&ecirc;ng vụ t&ecirc;n của c&aacute;c DBMS th&ocirc;i đ&atilde; thấy đau đầu rồi anh em&nbsp;<img alt=\":laughing:\" src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f606.png\" style=\"height:20px; width:20px\" />, indices với index chả biết đường n&agrave;o m&agrave; lần.<br />\nCứ như vậy, h&agrave;ng trăm DBMS lại đặt t&ecirc;n kh&aacute;c nhau, c&oacute; c&uacute; ph&aacute;p kh&aacute;c nhau, th&agrave;nh ra m&igrave;nh&nbsp;<strong>n&ecirc;n nắm được bản chất</strong>&nbsp;chứ cũng đừng quan t&acirc;m qu&aacute; nhiều v&agrave;o những c&aacute;i t&ecirc;n, c&uacute; ph&aacute;p l&agrave;m g&igrave; cho mệt<img alt=\":yum:\" src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f60b.png\" style=\"height:20px; width:20px\" />&nbsp;!</p>\n\n<p>Cơ chế</p>\n\n<p>Insert</p>\n\n<p>Khi ta insert một document v&agrave;o th&igrave; document mới n&agrave;y sẽ được distribute v&agrave;o 1 trong c&aacute;c shard hiện thời.<br />\nTuỳ theo cơ chế của DBMS v&agrave; mối li&ecirc;n hệ với c&aacute;c document kh&aacute;c( NoSQL DBMS kh&ocirc;ng phải l&agrave; ho&agrave;n to&agrave;n kh&ocirc;ng c&oacute; relationship, vẫn tồn tại document link với document kh&aacute;c nha anh em, chỉ l&agrave; kh&ocirc;ng c&oacute; r&agrave;ng buộc kho&aacute; ngoại mạnh mẽ như RDBMS th&ocirc;i) m&agrave; router sẽ distribute những document ấy v&agrave;o c&ugrave;ng 1 shard. Mục ti&ecirc;u ở đ&acirc;y l&agrave; performance.</p>\n\n<p>Query</p>\n\n<p>&nbsp;</p>\n\n<p><a href=\"https://s3-ap-southeast-1.amazonaws.com/kipalog.com/zenppohpuu_image.png\"><img alt=\"alt text\" src=\"https://s3-ap-southeast-1.amazonaws.com/kipalog.com/zenppohpuu_image.png\" /></a></p>\n\n<p><br />\nKhi xử l&yacute; một c&acirc;u query, th&igrave; router sẽ chuyển query cho c&aacute;c shard. Sau đ&oacute;, c&aacute;c shard thực hiện query ri&ecirc;ng lẻ v&agrave; responds kết quả về router. L&uacute;c n&agrave;y router server c&oacute; nhiệm vụ merge c&aacute;c kết quả lại v&agrave; trả về cho người d&ugrave;ng.<br />\nHiện nay th&igrave; nền c&ocirc;ng nghiệp của m&igrave;nh đ&atilde; hiện đại hơn xưa rất nhiều rồi, m&aacute;y t&iacute;nh giờ con n&agrave;o con nấy 8 core 16 core hết, thậm ch&iacute; c&ograve;n nhiều processor nữa, n&ecirc;n 1 m&aacute;y t&iacute;nh sẽ c&oacute; nhiều thread. V&igrave; NoSQL DBMS implement sharding, n&ecirc;n mỗi thread handle 1 request cho mỗi shard. Vậy th&igrave; lợi &iacute;ch qu&aacute; r&otilde; r&agrave;ng rồi: performance.</p>\n\n<p>Lợi &iacute;ch</p>\n\n<p>Như n&atilde;y giờ giải th&iacute;ch, high performance l&agrave; mục ti&ecirc;u lớn nhất của sharding.<br />\nNữa, anh em h&atilde;y đối chiếu với distributed system, c&oacute; thể thấy sharding sẽ rất thuận tiện cho scalability. L&uacute;c dữ liệu qu&aacute; nhiều, th&igrave; partitioning sẽ l&agrave; cần thiết. Đối với RDBMS, việc partitioning sẽ kh&oacute; hơn rất nhiều so với NoSQL DBMS. L&yacute; do l&agrave; data trong RDBMS c&oacute; r&agrave;ng buộc, li&ecirc;n kết với nhau n&ecirc;n khi partition th&igrave; sẽ phải l&agrave;m sao cho những data c&oacute; li&ecirc;n quan với nhau v&agrave;o 1 part, nếu kh&ocirc;ng th&igrave; sẽ ảnh hưởng đến performance. Việc n&agrave;y cực kh&oacute; khăn v&agrave; cực kỳ tổn hại đến performance l&uacute;c write, n&ecirc;n gần như RDBMS hiện tại kh&ocirc;ng hỗ trợ, nếu muốn th&igrave; ta sẽ phải tự handle, việc n&agrave;y c&oacute; chi ph&iacute; về economic lẫn performance kh&ocirc;ng nhỏ. N&ecirc;n ta mới n&oacute;i, NoSQL support automatically sharding sẽ đơn giản rất nhiều việc, kh&ocirc;ng phải handle manual nhiều, thu&ecirc; DevOps n&agrave;y kia nhiều nữa.</p>\n\n<h3>Segment</h3>\n\n<p>L&agrave; unit chứa c&aacute;c information cần thiết của data, được d&ugrave;ng trong in-memory buffer v&agrave; disk.</p>\n\n<p>Hẳn l&agrave; anh em c&oacute; nghe đến in-memory của NoSQL DBMS rồi đ&uacute;ng kh&ocirc;ng? N&oacute; l&agrave; để cải thiện performance? Đ&uacute;ng, nhưng bằng c&aacute;ch n&agrave;o?</p>\n\n<p>Trong&nbsp;<strong>một số</strong>&nbsp;NoSQL DBMS hỗ trợ mạnh về in-memory( v&iacute; dụ như Redis, Memcached trong Key-value Store, Elasticsearch trong Search Engine), muốn search/get th&igrave; ta phải đ&aacute;nh index cho c&aacute;c field của document l&uacute;c document đ&oacute; l&uacute;c được insert. Anh em c&oacute; thể t&igrave;m hiểu th&ecirc;m về c&aacute;ch đ&aacute;nh index của DBMS anh em đang x&agrave;i.</p>\n\n<p>Near-realtime</p>\n\n<p>Khi insert 1 document v&agrave;o th&igrave; DBMS sẽ kh&ocirc;ng insert v&agrave;o disk ngay, m&agrave; sẽ lưu ở memory buffer. C&oacute; l&uacute;c n&agrave;o anh em insert 1 document, sau khi DBMS trả về response th&ocirc;ng b&aacute;o th&agrave;nh c&ocirc;ng, nhưng khi get/search th&igrave; anh em lại kh&ocirc;ng thấy document n&agrave;y trong result m&agrave; sau một thời gian mới c&oacute;. L&uacute;c đ&oacute; anh em m&igrave;nh sẽ d&egrave; ra chửi&nbsp;<em>&quot;N&oacute; ngu g&igrave; đ&acirc;u &yacute;! Cứ chậm chậm thế n&agrave;o!&quot;</em><br />\nThực ra, những data mới của anh em đ&atilde; được lưu ở memory buffer, chứ kh&ocirc;ng insert v&agrave;o disk ngay. Thứ nhất, việc n&agrave;y sẽ done request sớm hơn. Thứ 2, việc insert nhỏ lẻ v&agrave;o disk l&agrave; một việc rất tốn t&agrave;i nguy&ecirc;n v&agrave; ảnh hưởng đến performance. Khi data tr&ecirc;n segment đ&atilde; đủ lớn (hoặc thời gian đủ d&agrave;i, việc n&agrave;y anh em c&oacute; thể config được), DBMS sẽ flush, ghi tất cả data tr&ecirc;n tất cả segment v&agrave;o dish v&agrave; memory buffer được clear ngay.</p>\n\n<p>Nếu mất điện hoặc xảy ra vấn đề l&uacute;c data chưa đứa insert xuống disk th&igrave; sao?<br />\nĐ&atilde; c&oacute; transaction log lo, khi c&oacute; data mới th&igrave; đồng thời lưu ở in-memory buffer v&agrave; append v&agrave;o transaction log lu&ocirc;n, khi mất điện th&igrave; dữ liệu trong memory sẽ mất hết, nhưng transaction log th&igrave; kh&ocirc;ng mất, l&uacute;c hệ thống hoạt động lại th&igrave; translog sẽ được check v&agrave; insert to&agrave;n bộ data trong n&oacute; v&agrave;o disk.<br />\nTất cả những việc n&agrave;y gọi l&agrave; near-realtime hay near-persistent, đổi lại l&agrave; performance.</p>\n\n<p>&nbsp;</p>\n\n<p><a href=\"https://s3-ap-southeast-1.amazonaws.com/kipalog.com/sax7p2yh1i_image.png\"><img alt=\"alt text\" src=\"https://s3-ap-southeast-1.amazonaws.com/kipalog.com/sax7p2yh1i_image.png\" /></a></p>\n\n<p><br />\n<em>Khi insert data</em></p>\n\n<p><a href=\"https://s3-ap-southeast-1.amazonaws.com/kipalog.com/mw2i4y2nej_image.png\"><img alt=\"alt text\" src=\"https://s3-ap-southeast-1.amazonaws.com/kipalog.com/mw2i4y2nej_image.png\" /></a></p>\n\n<p><br />\n<em>Khi đ&atilde; flush data</em></p>\n\n<p>Immutable</p>\n\n<p>Khi search/get th&igrave; DBMS cũng sẽ cache lại trong memory, mục đ&iacute;ch ở đ&acirc;y vẫn l&agrave; tăng performance.<br />\nNhưng để c&oacute; được điều đ&oacute;, ta phải giải quyết v&agrave;i vấn đề. Vấn đề nan giải nhất l&agrave; phải giữ in-memory buffer lu&ocirc;n lu&ocirc;n đ&aacute;ng tin v&agrave; kh&ocirc;ng xảy ra exception, nghĩa l&agrave; những inverted index trong memory đừng c&oacute; sai. Nếu data tr&ecirc;n memory v&agrave; disk kh&aacute;c nhau th&igrave; sẽ ăn h&agrave;nh ngay! Thử tưởng tượng trong memory c&oacute; document A nhưng trong disk th&igrave; document A đ&atilde; bị update hoặc delete xem nghen<img alt=\":laughing:\" src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f606.png\" style=\"height:20px; width:20px\" />.<br />\nĐể giải quyết vấn đề n&agrave;y th&igrave; inverted index tr&ecirc;n disk phải immutable, nghĩa l&agrave; đ&atilde; insert v&agrave;o rồi th&igrave; kh&ocirc;ng bao giờ thay đổi. Đồng thời nếu implement immutable data th&igrave; sẽ kh&ocirc;ng cần lock data (thử tưởng tượng inverted index bị update th&igrave; sẽ xảy ra chuyện locking, blocking như RDBMS vậy). C&aacute;ch giải quyết:</p>\n\n<ul>\n\t<li>Khi delete document th&igrave; sẽ kh&ocirc;ng x&oacute;a document đ&oacute; đi m&agrave; đ&aacute;nh dấu l&agrave; &quot;is deleted&quot;.</li>\n\t<li>Tương tự khi update document th&igrave; đ&aacute;nh dấu document đ&oacute; trong disk l&agrave; &quot;is deleted&quot; v&agrave; insert v&agrave;o version mới của document.</li>\n</ul>\n\n<p>Bằng c&aacute;ch n&agrave;y, data của ta sẽ lu&ocirc;n immutable. C&ograve;n anh em đừng sợ l&uacute;c query th&igrave; ta phải mất c&ocirc;ng qu&eacute;t qua những document đ&atilde; bị đ&aacute;nh dấu l&agrave; &quot;is deleted&quot;, v&igrave; đ&atilde; được đ&aacute;nh index n&ecirc;n việc query rất nhanh, l&uacute;c tổng hợp kết quả th&igrave; DBMS chỉ cần x&oacute;a những document được đ&aacute;nh dấu l&agrave; &quot;is deleted&quot; l&agrave; xong.</p>\n\n<p>Ủa, l&agrave;m đủ thứ như vậy để l&agrave;m g&igrave;&nbsp;<img alt=\":confused:\" src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f615.png\" style=\"height:20px; width:20px\" />??<br />\nCuối c&ugrave;ng vẫn l&agrave; để support cho&nbsp;<strong>in-memory buffer</strong>&nbsp;m&agrave; th&ocirc;i&nbsp;<img alt=\":smile:\" src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f604.png\" style=\"height:20px; width:20px\" />!<br />\nM&agrave; in-memory để l&agrave;m g&igrave;&nbsp;<img alt=\":confused:\" src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f615.png\" style=\"height:20px; width:20px\" />??<br />\n<strong>Improve Performance&nbsp;<img alt=\":smile:\" src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f604.png\" style=\"height:20px; width:20px\" />!</strong></p>\n\n<h3>Trả lời c&acirc;u hỏi</h3>\n\n<p>Ch&uacute;ng ta đ&atilde; c&ugrave;ng nhau đi qua gian kh&oacute; trong b&agrave;i n&agrave;y rồi, giờ l&agrave; l&uacute;c để kiểm chứng lại v&agrave; clear hết những nghi vấn, thắc mắc từ đầu đến giờ nha anh em!</p>\n\n<ul>\n\t<li><strong>Tại sao NoSQL DBMS hỗ trợ elastic scalability?</strong></li>\n</ul>\n\n<p><strong>Trả lời:</strong>&nbsp;V&igrave; NoSQL DBMS support sharding rất dễ d&agrave;ng v&agrave; tự động. Tưởng tượng data nhiều th&igrave; ta lại config th&agrave;nh nhiều shard hơn, distribute tr&ecirc;n nhiều machine.</p>\n\n<ul>\n\t<li><strong>Tại sao NoSQL DBMS high performance?</strong></li>\n</ul>\n\n<p><strong>Trả lời:</strong></p>\n\n<ul>\n\t<li>Write request:\n\t<ul>\n\t\t<li>Flexible data model: l&uacute;c insert sẽ chẳng check g&igrave; cả. L&uacute;c insert th&igrave; DBMS sẽ đơn giản l&agrave; lấy body của request l&agrave;m value, c&ograve;n key sẽ tự generate(c&oacute; thể explicit key nhưng sẽ bị performance v&igrave; DBMS phải check to&agrave;n bộ key c&oacute; sẵn để tr&aacute;nh tr&ugrave;ng).</li>\n\t\t<li>In-memory: kh&ocirc;ng ghi disk ngay m&agrave; ghi ở memory trước.</li>\n\t</ul>\n\t</li>\n\t<li>\n\t<p>Query request:</p>\n\n\t<ul>\n\t\t<li>Less relationship: kh&ocirc;ng phải retrieve data ở nhiều chỗ.</li>\n\t\t<li>Shard: thực hiện concurrency.</li>\n\t\t<li>In-memory: nếu đ&atilde; cache th&igrave; trả data về, kh&ocirc;ng cần đọc ở disk.</li>\n\t</ul>\n\t</li>\n\t<li>\n\t<p><strong>Tại sao NoSQL DBMS high availability?</strong></p>\n\t</li>\n</ul>\n\n<p><strong>Trả lời:</strong>&nbsp;Replication.</p>\n\n<ul>\n\t<li><strong>Tại sao NoSQL DBMS Economical?</strong></li>\n</ul>\n\n<p><strong>Trả lời:</strong>&nbsp;NoSQL DBMS support sharding lẫn replicationing tự động v&agrave; c&oacute; cơ chế handle những case cần thiết (như chọn master mới l&uacute;c master node bị lỗi), rất dễ d&agrave;ng n&ecirc;n kh&ocirc;ng cần DevOps nhiều lẫn chi ph&iacute; những extra tool để l&agrave;m những việc n&agrave;y. Nữa l&agrave; rất nhiều NoSQL DBMS l&agrave; Open-source n&ecirc;n ta sẽ giảm được chi ph&iacute; chi trả cho lisences.</p>\n\n<p><em>Tiếp theo l&agrave; một số c&acirc;u hỏi của anh em trong &quot;ng&agrave;nh&quot; đ&atilde; đưa ra</em></p>\n\n<ul>\n\t<li><strong>M&igrave;nh hơi thắc mắc về sự phối hợp giữa replication với sharding trong NoSQL DBMS</strong></li>\n</ul>\n\n<p><strong>Trả lời:</strong>&nbsp;Cấu tr&uacute;c v&agrave; cơ chế của replica v&agrave; shard th&igrave; anh em đ&atilde; nắm r&otilde; rồi, m&igrave;nh kh&ocirc;ng giải th&iacute;ch lại nữa. C&ograve;n sự phối hợp th&igrave; mỗi shard trong NoSQL DBMS sẽ c&oacute; thể l&agrave; primary-shard (master) hoặc l&agrave; secondary-shard (slave). M&igrave;nh mượn c&aacute;i h&igrave;nh của 1 NoSQL DBMS kh&aacute; nổi hiện giờ l&agrave; MongoDB.</p>\n\n<p>&nbsp;</p>\n\n<p><a href=\"https://s3-ap-southeast-1.amazonaws.com/kipalog.com/6h8ofvos9b_image.png\"><img alt=\"alt text\" src=\"https://s3-ap-southeast-1.amazonaws.com/kipalog.com/6h8ofvos9b_image.png\" /></a></p>\n\n<p><br />\nAnh em nh&igrave;n th&ecirc;m h&igrave;nh architecture của MongoDB ở phần&nbsp;<strong>Đặt vấn đề</strong>&nbsp;để tưởng tượng lại cơ chế hoạt động nha.<br />\nArchitecture của c&aacute;c NoSQL DBMS sẽ kh&aacute;c đ&ocirc;i ch&uacute;t, v&iacute; dụ l&agrave; Elasticsearch l&agrave; c&oacute; th&ecirc;m sự tồn tại của node (đ&oacute;ng vai 1 server trong distributed system) v&agrave; cluster. Nhưng về structure cơ bản, mechanism lẫn lợi &iacute;ch của replica v&agrave; shard th&igrave; kh&ocirc;ng thay đổi n&ecirc;n anh em chỉ cần nắm r&otilde; được bản chất th&igrave; DBMS n&agrave;o cũng kh&ocirc;ng ng&aacute;n.</p>\n\n<ul>\n\t<li><strong>Sharding c&oacute; phải l&agrave; mỗi shard lu&ocirc;n lu&ocirc;n nằm tr&ecirc;n từng server ri&ecirc;ng lẻ kh&ocirc;ng?</strong></li>\n</ul>\n\n<p><strong>Trả lời:</strong>&nbsp;Tr&ecirc;n local machine của m&igrave;nh th&igrave; tất cả shard nằm chung. Nhưng trong m&ocirc;i trường thực tế y&ecirc;u cầu data lớn th&igrave; DevOps sẽ implement shard nằm ri&ecirc;ng tr&ecirc;n từng server.Anh em c&oacute; thể xem th&ecirc;m ở&nbsp;<a href=\"https://en.wikipedia.org/wiki/Shard_(database_architecture)\">đ&acirc;y</a>&nbsp;để nắm r&otilde; hơn.</p>\n\n<ul>\n\t<li><strong>RDBMS (SQL DBMS) c&oacute; support distribution, partition data kh&ocirc;ng? V&iacute; dụ như microservice th&igrave; n&oacute; lại c&oacute; chia nhỏ data ra ri&ecirc;ng.</strong></li>\n</ul>\n\n<p><strong>Trả lời:</strong>&nbsp;RDBMS kh&ocirc;ng support partitioning data tự động. V&agrave; việc partition data trong RDBMS th&igrave; thường l&agrave; vertical partitioning chứ kh&ocirc;ng phải horizontal partitioning như NoSQL DBMS (l&yacute; do th&igrave; l&agrave; tại relationship), v&agrave; việc partition data manual cũng kh&oacute; khăn.<br />\n&ldquo;Microservice chia nhỏ data ra ri&ecirc;ng&rdquo;: việc distribute data đ&oacute; l&agrave; do architecture, kh&ocirc;ng phải do RDBMS.</p>\n\n<p>&nbsp;</p>\n\n<p><a href=\"https://s3-ap-southeast-1.amazonaws.com/kipalog.com/r44awwcrej_image.png\"><img alt=\"alt text\" src=\"https://s3-ap-southeast-1.amazonaws.com/kipalog.com/r44awwcrej_image.png\" /></a></p>\n\n<p><br />\nTr&ecirc;n thực tế, mỗi service c&oacute; thể d&ugrave;ng NoSQL DBMS hay l&agrave; RDBMS tuỳ th&iacute;ch. Người ta sẽ lấy những data cần thiết v&agrave; c&oacute; m&ocirc; h&igrave;nh dữ liệu kh&aacute;c nhau (tuỳ bounded context) cho từng service ri&ecirc;ng, như h&igrave;nh tr&ecirc;n, chứ kh&ocirc;ng phải distribute data ra nhỏ lẻ theo kiểu horizontal partitioning (chia to&agrave;n bộ document của collection ra tr&ecirc;n nhiều shard nhỏ lẻ).<br />\nNgo&agrave;i lề 1 x&iacute;u, distribution kh&aacute;c với replication. V&agrave; RDBMS chả support những việc n&agrave;y automatic m&agrave; tất cả l&agrave; manual, do architecture v&agrave; c&aacute;c engine kh&aacute;c định đoạt.</p>\n\n<ul>\n\t<li><strong>Mọi NoSQL DBMS khi update với delete document đều l&agrave; soft delete chứ kh&ocirc;ng xo&aacute; hẳn hả?</strong></li>\n</ul>\n\n<p><strong>Trả lời:</strong>&nbsp;Kh&ocirc;ng, cơ chế đ&oacute; l&agrave; chỉ để support in-memory feature. Tuỳ NoSQL DBMS m&agrave; sẽ c&oacute; c&aacute;ch handle kh&aacute;c nhau đ&ocirc;i ch&uacute;t, m&igrave;nh kh&ocirc;ng t&igrave;m hiểu tất cả NoSQL DBMS được, nhưng cũng tương tự nhau m&agrave; th&ocirc;i. Nếu kh&ocirc;ng handle kiểu như m&igrave;nh n&oacute;i th&igrave; trường hợp 1 l&agrave; database sẽ c&oacute; một v&agrave;i thời điểm data kh&ocirc;ng reliable, trường hợp 2 l&agrave; NoSQL DBMS đ&oacute; chả support in-memory feature lu&ocirc;n.</p>\n\n<ul>\n\t<li><strong>Mấy cơ chế của NoSQL DBMS n&ecirc;u n&atilde;y giờ l&agrave; n&oacute; implement hết hả, hay ta phải tự implement?</strong></li>\n</ul>\n\n<p><strong>Trả lời:</strong>&nbsp;C&aacute;c NoSQL DBMS đ&atilde; implement hết rồi, ta chỉ cần hiểu r&otilde; cấu tr&uacute;c v&agrave; cơ chế hoạt động nữa để x&agrave;i cho chuẩn th&ocirc;i. C&ograve;n một số thứ advanced như scale database ra tr&ecirc;n mỗi server th&igrave; phải lấn s&acirc;n qua DevOps 1 x&iacute;u.</p>\n\n<ul>\n\t<li><strong>Chia bao nhi&ecirc;u shard l&agrave; do m&igrave;nh cấu h&igrave;nh, hay n&oacute; sẽ tự động chia số lượng shard hợp l&yacute;? Replica nữa?</strong></li>\n</ul>\n\n<p><strong>Trả lời:</strong>&nbsp;Đ&atilde; c&oacute; default sẵn, nhưng c&oacute; thể custom config lại được. V&iacute; dụ như trong Elasticsearch th&igrave; l&agrave; 5 shard, v&agrave; 1 replica cho mỗi shard =&gt; t&iacute;nh ra l&agrave; 10 shard (<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/6.4/indices-create-index.html\">link</a>). T&oacute;m lại, ta muốn th&igrave; c&oacute; thể config số lượng của replica v&agrave; shard, mọi việc c&ograve;n lại như distribute data, distribute query... th&igrave; để DBMS lo, qu&aacute; sướng.</p>\n\n<h3>Kết b&agrave;i</h3>\n\n<p>B&agrave;i viết n&agrave;y n&oacute;i về cấu tr&uacute;c tổng quan v&agrave; cơ chế hoạt động của NoSQL DBMS m&agrave; anh em n&ecirc;n biết.</p>\n\n<p>Để viết một b&agrave;i viết vừa đ&aacute;p ứng c&oacute; sự tổng qu&aacute;t cho mọi NoSQL DBMS, lại vừa cụ thể để c&oacute; thể dễ d&agrave;ng hiểu được th&igrave; c&oacute; khả năng cao l&agrave; m&igrave;nh đ&atilde; bỏ s&oacute;t chỗ n&agrave;o đ&oacute;, hoặc l&agrave; c&oacute; chỗ n&agrave;o đ&oacute; hơi kh&aacute;c so với một v&agrave;i DBMS, th&igrave; anh em th&ocirc;ng cảm cho m&igrave;nh nh&eacute;! Hi vọng anh em cũng g&oacute;p &yacute; cho m&igrave;nh để b&agrave;i chia sẻ n&agrave;y được tốt hơn!</p>\n\n<p>Hi vọng b&agrave;i viết n&agrave;y sẽ gi&uacute;p anh em thấu hiểu DBMS anh em đang x&agrave;i hơn, kh&ocirc;ng &quot;chửi feature&quot; v&agrave; c&oacute; thể tận dụng được sức mạnh của c&aacute;c NoSQL DMBS một c&aacute;ch triệt để, hợp l&yacute; nh&eacute;&nbsp;<img alt=\":smile:\" src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f604.png\" style=\"height:20px; width:20px\" />!</p>\n",
      "total_views": 100,
      "status": true,
      "tags": [
        "NoSQL", "Database"
      ]
    },
    {
      "title": "Instagram đã sinh ra ID trong database của họ như thế nào",
      "content": "<p>Đối với những hệ thống nhỏ chỉ cần 1 Database th&igrave; chắc chẳng mấy ai quan t&acirc;m đến việc tạo ra ID cho bản ghi. V&igrave; d&ugrave;ng auto increment trong MySQL l&agrave; c&oacute; thể l&agrave;m được rồi, chẳng cần phải l&agrave;m g&igrave; th&ecirc;m. Thế nhưng với dữ liệu c&agrave;ng ng&agrave;y c&agrave;ng to ra th&igrave; hệ thống chỉ c&oacute; 1 database duy nhất c&oacute; thể sẽ kh&ocirc;ng thể đ&aacute;p ứng được. Bởi v&igrave; traffic đang tập trung hết v&agrave;o database đ&oacute;. Để giải quyết b&agrave;i to&aacute;n đ&oacute; th&igrave; người ta đ&atilde; t&aacute;ch database ra th&agrave;nh nhiều database kh&aacute;c nhau, v&agrave; mỗi database đ&oacute; sẽ chứa 1 phần dữ liệu. V&iacute; dụ db_01 chứa th&ocirc;ng tin user từ 1 đến 1000, db_02 chứa th&ocirc;ng tin user từ 1001 đến 2000 chẳng hạn. V&agrave; khi query sẽ t&igrave;m xem user thuộc database n&agrave;o v&agrave; thực hiện truy vấn. V&agrave; kĩ thuật n&agrave;y người ta gọi l&agrave; sharding. Thế nhưng c&oacute; vấn đề xảy ra ở đ&acirc;y l&agrave; l&agrave;m thế n&agrave;o sinh ra ID cho user m&agrave; kh&ocirc;ng bị tr&ugrave;ng lặp giữa c&aacute;c database đ&oacute;? D&ugrave;ng auto increment mặc định của database c&oacute; giải quyết được kh&ocirc;ng? L&agrave;m thế n&agrave;o để từ 2 ID c&oacute; thể ph&aacute;n đo&aacute;n c&aacute;i n&agrave;o được sinh ra trước, c&aacute;i n&agrave;o được sinh ra sau? Vậy c&ugrave;ng đọc b&agrave;i n&agrave;y xem c&aacute;c kĩ sư Instagram đ&atilde; giải quyết b&agrave;i to&aacute;n n&agrave;y thế n&agrave;o nh&eacute;. Mục ti&ecirc;u b&agrave;i viết: Hiểu th&ecirc;m được 1 cơ chế sinh ID mới. C&oacute; thể &aacute;p dụng v&agrave;o c&aacute;c b&agrave;i to&aacute;n sharding data trong database. Bối cảnh Instagram l&agrave; 1 trong những mạng x&atilde; hội chia sẻ ảnh nổi tiếng nhất c&aacute;i h&agrave;nh tinh n&agrave;y. Theo thống k&ecirc; năm 2016 th&igrave; cứ mỗi gi&acirc;y sẽ c&oacute; 915 photos, 1k post được tạo ra. Qu&aacute; khủng khiếp phải kh&ocirc;ng n&agrave;o. Khi dữ liệu tăng l&ecirc;n kinh khủng như thế th&igrave; 1 database sẽ kh&ocirc;ng thể lưu trữ hết được dữ liệu, c&ugrave;ng với tốc độ truy vấn sẽ trở n&ecirc;n &igrave; ạch v&agrave; tốn nhiều dung lượng bộ nhớ. Để đảm bảo tất cả dữ liệu quan trọng lu&ocirc;n được lưu trữ tr&ecirc;n memory, v&agrave; sẵn s&agrave;ng trả về kết quả nhanh nhất cho người d&ugrave;ng th&igrave; Instagram bắt đầu thực hiện Sharding dữ liệu. Ảnh b&ecirc;n dưới l&agrave; 1 v&iacute; dụ về sharding trong database. Database sẽ được t&aacute;ch ra th&agrave;nh nhiều database kh&aacute;c nhau, mỗi database sẽ chứa 1 phần dữ liệu. Như v&iacute; dụ b&ecirc;n dưới l&agrave; t&aacute;ch bảng user ra th&agrave;nh nhiều database, mỗi database sẽ chứa 1 phần dữ liệu của bảng user. Người ta gọi mỗi database t&aacute;ch biệt n&agrave;y l&agrave; &ldquo;Shard&ldquo;. Tuy nhi&ecirc;n tại thời điểm n&agrave;y c&oacute; 1 b&agrave;i to&aacute;n được đặt ra. L&agrave;m thế n&agrave;o c&oacute; thể sinh ra ID duy nhất tr&ecirc;n từng shard m&agrave; kh&ocirc;ng sợ bị tr&ugrave;ng lặp (V&iacute; dụ như mỗi photo được upload v&agrave;o trong hệ thống)? C&ugrave;ng đi đọc tiếp phần tiếp theo nh&eacute;. Y&ecirc;u cầu về mặt chức năng Trước khi đi v&agrave;o giải quyết b&agrave;i to&aacute;n b&ecirc;n tr&ecirc;n, th&igrave; c&ugrave;ng xem hệ thống Instagram y&ecirc;u cầu những g&igrave; về ID của từng shard nh&eacute;. ID được tạo ra phải được sắp xếp theo thời gian. V&iacute; dụ như với 2 ID th&igrave; c&oacute; thể ph&aacute;n đo&aacute;n được ID n&agrave;o tạo ra trước, ID n&agrave;o tạo ra sau. ID sẽ bao gồm 64 bits. (V&igrave; sao lại cần 64 bits? V&igrave; n&oacute; tương th&iacute;ch với c&aacute;c hệ thống như Redis &hellip;) Thuật to&aacute;n sinh ra ID phải đơn giản, dễ hiểu v&agrave; đặc biệt kh&ocirc;ng được l&agrave;m thay đổi architecture server của Instagram. 1 số giải ph&aacute;p generate ID Hiện tại c&oacute; rất nhiều giải ph&aacute;p cho việc sinh ra ID unique. Cụ thể như: Sử dụng auto increment trong database Về chức năng n&agrave;y th&igrave; ai cũng biết rồi. L&uacute;c tạo bảng chỉ cần khai b&aacute;o auto increment l&agrave; xong. Ưu điểm: C&aacute;ch d&ugrave;ng đơn giản. Nhược điểm: Chỉ tập trung v&agrave;o 1 database v&agrave; kh&ocirc;ng thể ph&acirc;n chia sang database kh&aacute;c được. Kh&ocirc;ng thể đảm bảo rằng việc sinh ID ở nhiều database l&agrave; kh&ocirc;ng bị tr&ugrave;ng nhau. Sử dụng UUID Đ&acirc;y cũng l&agrave; 1 c&aacute;ch kh&aacute; hay để giải quyết b&agrave;i to&aacute;n. UUID l&agrave; 1 chuẩn chung nhằm sinh ra chuỗi random kh&ocirc;ng tr&ugrave;ng nhau (x&aacute;c suất gần như bằng 0). V&iacute; dụ như: b875d561-20fd-498d-8452-5d5ffa879856. Thế nhưng c&ugrave;ng xem n&oacute; c&oacute; ưu điểm nhược điểm g&igrave; nh&eacute;. Ưu điểm: Cho d&ugrave; chạy tr&ecirc;n nhiều m&aacute;y t&iacute;nh c&ugrave;ng thời điểm đi chăng nữa th&igrave; x&aacute;c suất c&aacute;c string đ&oacute; tr&ugrave;ng nhau dường như gần bằng 0. Nhược điểm: N&oacute; bao gồm 128 bits n&ecirc;n hơi to, kh&ocirc;ng ph&ugrave; hợp với y&ecirc;u cầu của hệ thống (l&agrave; 64 bits) Với 2 ID th&igrave; kh&ocirc;ng thể ph&acirc;n biệt ID n&agrave;o tạo trước, ID n&agrave;o tạo sau. Snowflake Đ&acirc;y ch&iacute;nh l&agrave; 1 c&ocirc;ng cụ sinh ra ID random được ph&aacute;t triển bởi Twitter. C&aacute;i n&agrave;y sử dụng Apache Zookepper để phối hợp với c&aacute;c node để tạo ID 64 bit duy nhất. Ưu điểm: Snowflake ID c&oacute; 64 bit C&oacute; thể sử dụng time trong component đầu ti&ecirc;n của ID n&ecirc;n c&oacute; thể sắp xếp được Nhược điểm: Phải đưa ZooKeeper, Snowflake v&agrave;o trong kiến tr&uacute;c của Instagram. Giải ph&aacute;p của Instagram Những giải ph&aacute;p tr&ecirc;n đều kh&ocirc;ng đ&aacute;p ứng được y&ecirc;u cầu của Instagram n&ecirc;n họ quyết định tự x&acirc;y dựng cho m&igrave;nh 1 giải ph&aacute;p ri&ecirc;ng. Họ sẽ d&ugrave;ng thuật to&aacute;n đơn giản để sinh ra 1 chuỗi ID random duy nhất từ 1 số input đầu v&agrave;o. V&agrave; từ chuỗi ID đ&oacute; c&oacute; thể decode ngược lại để lấy ra được input. ID ở đ&acirc;y ch&iacute;nh l&agrave; ID của photo, ID của posts chẳng hạn. Database họ sử dụng l&agrave; PostgreSQL. Cụ thể như sau. ID c&oacute; độ d&agrave;i 64 bits, sẽ bao gồm những bộ phận sau: 41 bits để lưu thời gian (đơn vị milliseconds). Khoảng thời gian n&agrave;y sẽ được t&iacute;nh từ ng&agrave;y 2011/01/01 00:00. 13 bits để lưu shard ID. (tối đa c&oacute; thể tạo ra được 2^13 = 8192 shard) 10 bits để lưu auto-incrementing sequence, sau đ&oacute; module 1024. (V&igrave; sao lại l&agrave; 1024 v&igrave; tối đa c&oacute; 10 bit th&ocirc;i, m&agrave; 2^10 = 1024). Điều đ&oacute; c&oacute; nghĩa l&agrave; c&oacute; thể tạo ra 1024 IDs tr&ecirc;n 1 shard, tr&ecirc;n millisecond. C&acirc;u hỏi đặt ra l&agrave; nếu tạo upload qu&aacute; 1024 bức ảnh trong 1ms c&oacute; được kh&ocirc;ng? C&acirc;u trả lời l&agrave; kh&ocirc;ng nh&eacute;. V&igrave; l&uacute;c đ&oacute; thằng thứ 1025 sinh ra ID sẽ bị tr&ugrave;ng với thằng thứ 1. Với cả ID l&agrave; kho&aacute; ch&iacute;nh n&ecirc;n khi insert v&agrave;o sẽ bị lỗi. N&ecirc;n l&uacute;c đ&oacute; chỉ cần try cach đoạn đ&oacute; l&agrave; ok. C&ocirc;ng thức sinh ID như sau: ID = (time &lt;&lt; 23) | (shardID &lt;&lt; 10) | (seqId &lt;&lt;0) Trong đ&oacute;: ・time = now - instagram_epoch_time (2011/01/01 00:00) ・shardId = userId % 2000 ・seqId = (currentSeqID + 1) % 1024 Từ c&ocirc;ng thức tr&ecirc;n ta c&oacute; thể thấy ID được tạo ra bằng c&aacute;ch: ID = (Dịch tr&aacute;i time sang tr&aacute;i 23 bit) bitwise OR (dịch tr&aacute;i shardID 10 bit) bitwise OR (dịch tr&aacute;i seqID 0 bit) Để m&igrave;nh tổng hợp lại kiến thức về bitwise cho mọi người hiểu nh&eacute;: Dịch tr&aacute;i, dịch phải n&oacute; cũng giống như ch&uacute;ng ta k&eacute;o cảnh cửa sang tr&aacute;i, sang phải th&ocirc;i. Nếu dịch tr&aacute;i n bit tức l&agrave; sẽ điền n số 0 v&agrave;o sau số đ&oacute;. V&iacute; dụ như dịch tr&aacute;i số 7 (dạng nhị ph&acirc;n l&agrave; 110) sang tr&aacute;i 5 bit, khi đ&oacute; n&oacute; sẽ th&agrave;nh: 11000000 bitwise OR tức l&agrave; thực hiện OR từng bit 1 của 2 số từ phải sang tr&aacute;i. Nếu 2 bit đều l&agrave; 1 th&igrave; sẽ cho kết quả l&agrave; 1, ngược lại sẽ cho kết quả l&agrave; 0. V&iacute; dụ như 7 (dạng nhị ph&acirc;n l&agrave; 110) OR 8 (dạng nhị ph&acirc;n l&agrave; 111) khi đ&oacute; kết quả l&agrave;: 110 OR 111 = 110. V&iacute; dụ: Giả sử như người d&ugrave;ng c&oacute; user_id l&agrave; 5001, post bức ảnh l&ecirc;n instagram v&agrave;o thời điểm 2019/05/19 00:00. Tại thời điểm đ&oacute; sequence hiện tại của table đang l&agrave; 9000. C&aacute;ch t&iacute;nh: Do thời gian được t&iacute;nh từ ng&agrave;y 2011/01/01 00:00 n&ecirc;n từ thời điểm đ&oacute; đến ng&agrave;y 2019/05/19 00:00 c&oacute; time = 264384000000 ms. =&gt; ID = 264384000000 &lt;&lt; 23 (dịch sang tr&aacute;i 23 bit) Do user_id = 5001, v&agrave; instagram chỉ c&oacute; 2000 shard. N&ecirc;n shardId = 5001 % 2000 = 1001 =&gt; ID |= 1001 &lt;&lt; 10 sequence hiện tại của table đang l&agrave; 9000, khi đ&oacute; next_sequence_id l&agrave; 9001. vậy seqId = 9001 % 1024 = 809 =&gt; ID |= (809) &lt;&lt; 0 Sau khi t&iacute;nh ch&uacute;ng ta ra kết quả ID = 2217813737473025832. Vậy l&agrave;m thế n&agrave;o m&agrave; từ số 2217813737473025832 ch&uacute;ng ta c&oacute; thể decode ngược lại ra time l&agrave; 264384000000, shardId l&agrave; 1001, seqId l&agrave; 809? Đ&acirc;y c&oacute; lẽ l&agrave; phần m&igrave;nh thấy hay nhất. Ch&uacute;ng ta c&ugrave;ng xem tiếp nh&eacute;: Time = (2217813737473025832 &gt;&gt; 23) &amp; 0x1FFFFFFFFFF = 264384000000 Shard ID = (2217813737473025832 &gt;&gt; 10) &amp; 0x1FFF = 1001 seqID = (2217813737473025832 &gt;&gt; 0) &amp; 0x3FF = 809 Từ c&ocirc;ng thức tr&ecirc;n ta c&oacute; thể thấy được: Time sẽ được t&iacute;nh bằng c&aacute;ch dịch sang phải ID 23 bit, sau đ&oacute; thực hiện AND với 1 số 41 bit to&agrave;n số 1. C&aacute;i số 41 bit to&agrave;n số 1 n&agrave;y chuyển sang dạng hex sẽ l&agrave; 0x2FFFFFFFFFF. ShardID v&agrave; seqId cũng được decode tương tự. Đ&acirc;y l&agrave; 1 example về encode v&agrave; decode m&igrave;nh đ&atilde; chuẩn bị được. D&agrave;nh cho ai muốn test: <!--?php\n\n$uuid = 0;\n\n$userId = 5001;\n$currentSequenceId = 9000;\n$time = 264384000000;\n\n// ENCODE\n\n$shardId = $userId % 2000;\n$seqId = $currentSequenceId % 1024;\n\n$uuid = $time << 23;\n$uuid = $uuid | ($shardId << 10);\n$uuid = $uuid | ($seqId);\n\necho $uuid . PHP_EOL;\n\n// DECODE\n\n$time = ($uuid -->&gt; 23) &amp; 0x1FFFFFFFFFF; $shardId = ($uuid &gt;&gt; 10) &amp; 0x1FFF; $seqId = ($uuid &gt;&gt; 0) &amp; 0x3FF; echo $time . PHP_EOL; echo $shardId . PHP_EOL; echo $seqId . PHP_EOL; Sau khi lấy được shardId l&agrave; ch&uacute;ng ta c&oacute; thể dễ d&agrave;ng truy cập v&agrave;o từng shard để lấy ra record dựa v&agrave;o ID (photo_id, post_id &hellip;) được rồi. M&agrave; chẳng phải tốn c&ocirc;ng đi join, select l&agrave;m g&igrave; cho mệt cả. Hơn nữa n&oacute; thao t&aacute;c giữa c&aacute;c bit n&ecirc;n cứ gọi l&agrave; nhanh đừng hỏi. V&agrave; đ&acirc;y l&agrave; v&iacute; dụ về PL/PGSQL trong PostgreSQL: CREATE OR REPLACE FUNCTION insta5.next_id(OUT result bigint) AS $$ DECLARE our_epoch bigint := 1293843600000; seq_id bigint; now_millis bigint; shard_id int := 5; BEGIN SELECT nextval(&#39;insta5.table_id_seq&#39;) %% 1024 INTO seq_id; SELECT FLOOR(EXTRACT(EPOCH FROM clock_timestamp()) * 1000) INTO now_millis; result := (now_millis - our_epoch) &lt;&lt; 23; result := result | (shard_id &lt;&lt;10); result := result | (seq_id); END; $$ LANGUAGE PLPGSQL; Khi tạo bảng sẽ l&agrave;m như sau: CREATE TABLE insta5.our_table ( &quot;id&quot; bigint NOT NULL DEFAULT insta5.next_id(), ...rest of table schema... ) Kết luận Từ 1 con số m&agrave; c&oacute; thể dễ d&agrave;ng decode n&oacute; ra để lấy c&aacute;c th&ocirc;ng tin b&ecirc;n trong n&oacute;. Đoạn n&agrave;y m&igrave;nh thấy thật vi diệu. Đ&uacute;ng l&agrave; mấy anh kĩ sư c&oacute; kinh nghiệm về design mấy bo mạch, chip c&aacute;c thứ &aacute;p dụng v&agrave;o thấy n&oacute; kh&aacute;c bọt thật. Hi vọng qua b&agrave;i n&agrave;y sẽ gi&uacute;p c&aacute;c bạn c&oacute; 1 kiến thức mới về việc sinh ra ID random, v&agrave; decode ngược lại. Nguồn: https://nghethuatcoding.com/2019/05/19/instagram-da-sinh-ra-id-trong-database-cua-ho-nhu-the-nao/</p>\n",
      "total_views": 200,
      "status": false,
      "tags": []
    },
    {
      "title": "Tôi đi tìm lại tin nhắn tình yêu đầu tiên trên Facebook",
      "content": "<p>Ho&agrave;i niệm Ngồi một g&oacute;c nhỏ cafe, lại nhớ về một ch&uacute;t kỷ niệm g&igrave; của qu&aacute; khứ. Một người bạn của qu&aacute; khứ hay đ&ocirc;i khi l&agrave; những tin nhắn sến sẩm với b&agrave; x&atilde;. Rồi tự hỏi, 2 đứa từng nhắn tin với nhau từ bao giờ ? L&ocirc;i điện thoại ra k&eacute;o ngược d&ograve;ng qu&aacute; khứ, sao mệt dữ vậy. T&igrave;m sao được c&aacute;i n&agrave;y đầu ti&ecirc;n nhắn tin tỏ t&igrave;nh nhỉ ? T&igrave;m lại k&yacute; ức y&ecirc;u B&oacute; tay sao ? &Yacute; tưởng trong t&ocirc;i lại l&oacute;e l&ecirc;n. Kiếm c&aacute;i Facebook API : Read inbox messages cho n&oacute; nhanh. alt text Thế l&agrave; ra đi rồi &ocirc;ng gi&aacute;o ạ. alt text B&oacute; tay tiếp ? Firebug Đ&agrave;nh d&ugrave;ng Firebug v&agrave;o phần messenger (fb.com/messages) kiểm tra tiếp vậy, t&igrave;m tất tần tật c&aacute;i API n&agrave;o type n&oacute; trả về json. alt text Ra ngay em n&agrave;y : https://www.facebook.com/api/graphqlbatch/ - method POST T&igrave;m một người bạn v&agrave; trace theo API n&agrave;y xem n&oacute; ra l&agrave;m sao ? alt text Đo&aacute;n gi&agrave; đo&aacute;n non, th&igrave; c&aacute;i __dyn kia n&oacute; l&agrave; token rồi, kiểm tra th&ecirc;m về hoạt động của token n&agrave;y xem sao. M&igrave;nh gửi lại một request bằng Edit and Resend, thay đổi nội dung Request Body một ch&uacute;t. Ồ, n&oacute; vẫn trả về json m&agrave; kh&ocirc;ng lầm lỗi g&igrave;, vậy l&agrave; token n&agrave;y vẫn sống, c&oacute; thể t&aacute;i sử dụng được. L&ecirc;n &yacute; tưởng cho một Chrome Extension. Ph&acirc;n t&iacute;ch B&agrave;i to&aacute;n : T&igrave;m c&aacute;c tin nhắn đầu ti&ecirc;n với một người bạn. Input : Một id của người bạn, một mốc thời gian (timestamp: t&igrave;m tin nhắn trước ng&agrave;y n&agrave;y), số tin nhắn cần lấy. alt text Kiểm tra qua một request, thấy đầu v&agrave;o ngo&agrave;i c&aacute;c tham số chung th&igrave; c&oacute; c&aacute;c tham số thay đổi như l&agrave; id, message_limit, before Output: Danh s&aacute;ch c&aacute;c tin nhắn, hiển thị ra m&agrave;n h&igrave;nh. Phương thức : findUserId: T&igrave;m userid từ một url khi chuột phải v&agrave;o. getTokenSample: Lấy token template từ một request get messages đầu ti&ecirc;n, sau đ&oacute; lưu lại để thay đổi c&aacute;c tham số đầu v&agrave;o gửi l&ecirc;n. fetchMessage : T&igrave;m c&aacute;c tin nhắn từ ng&agrave;y hiện tại cho đến tin nhắn đầu ti&ecirc;n. C&aacute;c request đều trả về một biến has_previous_page, do đ&oacute; x&aacute;c định dễ d&agrave;ng được page cuối c&ugrave;ng. Đệ quy phương thức n&agrave;y cho tới hết, tham số truyển v&agrave;o l&agrave; mốc thời gian của node cuối c&ugrave;ng trong danh s&aacute;ch tin nhắn trước đ&oacute;. alt text Source code Google với keyword chrome extension webpack github: chrome-extension-webpack-boilerplate l&agrave; ra một bộ source tha hồ biến tấu. Viết code 1 . Get userId alt text 2 . Capture token, mở một tab tr&ecirc;n tr&igrave;nh duyệt, sau đ&oacute; bắt request mẫu để lưu lại c&aacute;c tham số input v&agrave;o localstorage getTokenFriend() { chrome.tabs.create({ url: `https://www.facebook.com/messages/t/${this.aliasUser}` }, (tab) =&gt; { db.set(&#39;__tabCachedMessenger&#39;, tab); }); } alt text 3 . Fetch messages bao gồm 2 options: duyệt dữ liệu từ đầu v&agrave; duyệt dữ liệu từ request cuối c&ugrave;ng. this.lastQuery = db.get(`__fuserId:${this.aliasUser}:last_query`); async fetchMessage(timestamp) { let sample = db.get(&#39;__messengerSamplePost&#39;); if (sample &amp;&amp; db.get(&#39;__isBusy&#39;) == &quot;false&quot;) { db.set(&#39;__isBusy&#39;, &quot;true&quot;); let queries = { &quot;o0&quot;: { &quot;doc_id&quot;: &quot;2335490819851618&quot;, &quot;query_params&quot;: { &quot;id&quot;: `${this.userId}`, &quot;message_limit&quot;: MAX_MESSAGE, &quot;load_messages&quot;: true, &quot;load_read_receipts&quot;: true, &quot;load_delivery_receipts&quot;: true, &quot;before&quot;: `${timestamp}` } } }; sample.queries = JSON.stringify(queries); const body = await helper.post(&#39;https://www.facebook.com/api/graphqlbatch/&#39;, (this.lastQuery || sample)); var lines = body.split(/\\n/); let result = JSON.parse(lines[0]); result = result &amp;&amp; result.o0 &amp;&amp; result.o0.data &amp;&amp; result.o0.data.message_thread; if (!result || !result.messages || result.messages.nodes.length &lt;= 0) { return helper.info(&#39;errorRelationShip&#39;, &#39;Chưa nhắn tin với nhau bao giờ&#39;); } this.indexMessage += result.messages.nodes.length; db.set(&#39;__isBusy&#39;, &quot;false&quot;); if (result &amp;&amp; result.messages.page_info.has_previous_page == false) { if (!this.isView) { this.openView(); helper.info(&#39;fetchToken&#39;, `Hai bạn đ&atilde; từng qua lại với nhau ${result.messages_count} tin nhắn.`); db.set(`__fuserId:${this.aliasUser}:last_query`, sample); } return result; } else { let __timestamp = result.messages.nodes[0].timestamp_precise; helper.info(&#39;fetchToken&#39;, `Đ&atilde; qu&eacute;t ${Math.floor(this.indexMessage / result.messages_count * 100)}% tin nhắn`); return await this.fetchMessage(__timestamp); } } } 4 . Hiển thị ra view alt text Để c&aacute;c request tới api của facebook kh&ocirc;ng bị bắt lỗi vặt, m&igrave;nh fake lại header của c&aacute;c request alt text Tạo menu alt text Th&agrave;nh quả Chọn chế độ ph&aacute;t triển v&agrave; load extension v&agrave;o. alt text t&igrave;m tin nhắn đầu ti&ecirc;n fb Lần đầu ti&ecirc;n với Ngọc Trinh. alt text Xuất bản tr&ecirc;n Chrome Extension Store: https://chrome.google.com/webstore/detail/messenger-viewer/jlgoljebdmafabnmlhgfkmofbdonlcjd alt text T&igrave;m lại tin nhắn của vợ th&igrave; n&oacute; phải như thế n&agrave;y : alt text Bản build cho mọi người test thử : 0.0.229 : Fix một số lỗi về tr&ugrave;ng lặp truy vấn. 0.0.239: Th&ecirc;m mốc thời gian của cuộc hội thoại. Chỉ việc giải n&eacute;n, load thư mục v&agrave;o chrome dưới chế độ ph&aacute;t triển. Tool vẫn c&ograve;n bug đ&acirc;u đ&oacute;, mong anh em bạn b&egrave; d&ugrave;ng thử report bug để m&igrave;nh fix :lmao: Nhắn nhủ Tr&ecirc;n đ&acirc;y m&igrave;nh kh&ocirc;ng d&aacute;m đi qu&aacute; s&acirc;u v&agrave;o từng d&ograve;ng code, chỉ cặn kẽ chi tiết như một hướng dẫn, m&igrave;nh chỉ vẽ ra một case study cho mọi người c&ugrave;ng tham khảo. Mọi th&ocirc;ng tin c&aacute; nh&acirc;n của bạn chỉ bạn nh&igrave;n thấy th&ocirc;i. C&aacute;i kết /!\\ Lợi bất cập hại, chắc tool n&agrave;y kh&ocirc;ng ph&ugrave; hợp cho anh em n&agrave;o hay m&ograve; mẫm đ&ecirc;m khuya. D&ugrave;ng tool n&agrave;y lại tan cửa n&aacute;t nh&agrave;, khuyến c&aacute;o trước nh&eacute; :lol:</p>\n",
      "total_views": 456,
      "status": true,
      "tags": [
        "Messenger", "Chrome Extension", "Facebook"
      ]
    },
    {
      "title": "Quét sạch dữ liệu của insecam.org bằng Google AppScript",
      "content": "<p>insecam.org l&agrave; website lưu trữ dữ liệu về c&aacute;c IPCam bị public (The world biggest directory of online surveillance security cameras.) Để bản đồ h&oacute;a dữ liệu IPCam tr&ecirc;n to&agrave;n thế giới, m&igrave;nh tiến h&agrave;nh x&acirc;y dựng bot c&agrave;o dữ liệu. alt text Demo : http://findcam.glitch.me/ Kế hoạch alt text Dự định x&acirc;y dựng bot lấy từ ngo&agrave;i v&agrave;o trong, tức l&agrave; theo chuy&ecirc;n mục rồi đi s&acirc;u v&agrave;o từng đường dẫn IPCam chi tiết. Khi chạy qua từng trang chuy&ecirc;n mục, bot sẽ: Lưu chỉ mục c&aacute;c đường dẫn b&agrave;i viết chi tiết ( tạm đặt t&ecirc;n l&agrave; IPCamView) v&agrave;o table IPCam Lưu c&aacute;c chỉ mục chuy&ecirc;n mục v&agrave;o table Links Lưu c&aacute;c chỉ mục trang (page) v&agrave;o table Links Update lại th&ocirc;ng tin cho c&aacute;c chỉ mục IPCamView C&aacute;c chỉ mục đề được gắn cờ để kiểm tra việc đ&atilde; được bot chạy qua hay chưa. Nhũng chỉ mục đ&atilde; được chạy gắn cờ isRun l&agrave; 1 Những chỉ mục chưa được chạy gắn cờ isRun l&agrave; 0 C&aacute;c function sẽ x&acirc;y dựng một c&aacute;ch độc lập: đọc dữ liệu l&ecirc;n để fetchData theo cờ isRun. Việc sử dụng cronjob (trigger) sẽ g&acirc;y n&ecirc;n bất đồng bộ dữ liệu (tr&ugrave;ng dữ liệu). Tiến h&agrave;nh x&acirc;y dựng một class DB để xử l&yacute; dữ liệu. Thư viện sử dụng : Cheerio (1ReeQ6WO8kKNxoaA_O0XEQ589cIrRvEBA9qcWpNqdOP17i47u6N9M5Xh0) Tiến h&agrave;nh 1 . Class DB (Quản l&yacute; dữ liệu theo sheet : th&ecirc;m, sửa, x&oacute;a ) function DB(sheetName) { this.db = SpreadsheetApp.getActiveSpreadsheet(); if (sheetName) this.sheet = this.db.getSheetByName(sheetName); } DB.prototype = { set sheetName(sheetName) { this.sheet = this.db.getSheetByName(sheetName); }, set header(headerContent) { if (this.sheet.getLastRow() == 0) { this.add(headerContent); } }, getValueByIndex: function (columIndex, value) { var index = this.findByIndex(columIndex, value); if (index &lt;= 0) return; var lastCol = this.sheet.getLastColumn(); return this.sheet.getRange(index, 1, 1, lastCol).getValues()[0]; }, findByIndex: function (columIndex, value) { var lastRow = this.sheet.getLastRow(), index = -1; if (lastRow &gt; 0) { this.sheet.getRange(1, columIndex, lastRow, 1) .getValues() .forEach(function (item, i) { if (item == value &amp;&amp; index == -1) index = i; }); } return index + 1; }, hasId: function (id) { return this.findId(id) &gt; 0; }, findId: function (id) { return this.findByIndex(1, id); }, add: function (rowContents) { return this.sheet.appendRow(rowContents); }, update: function (id, rowContents) { var index = this.findId(id); var lastColumn = this.sheet.getLastColumn(); if (index &gt; 0) { return this.sheet .getRange(index, 1, 1, lastColumn) .setValues([rowContents]); } } } 2 . Helper Array.prototype.fLabel = function (label) { var item = this.find(function (x) { return x.label == label }); if (!item) return &quot;&quot;; return item.value; } 3 . Module IPCam function IPCam() { this.BASE_URL = &quot;https://www.insecam.org&quot;; this.listId = []; var db = new DB(); db.sheetName = &quot;IPCam&quot;; db.header = [ &quot;ID&quot;, &quot;COUNTRY&quot;, &quot;COUNTRYCODE&quot;, &quot;COUNTRY&quot;, &quot;REGION&quot;, &quot;CITY&quot;, &quot;LATITUDE&quot;, &quot;LONGITUDE&quot;, &quot;ZIP&quot;, &quot;TIMEZONE&quot;, &quot;MANUFACTURER&quot;, &quot;TAGS&quot;, &quot;SOURCE&quot;, &quot;IS_RUN&quot; ]; db.sheetName = &quot;Links&quot;; db.header = [ &quot;ID&quot;, &quot;HREF&quot;, &quot;TEXT&quot;, &quot;IS_RUN&quot; ]; if (db.hasId(Utilities.base64Encode(&quot;/en/&quot;))) return; db.add([ Utilities.base64Encode(&quot;/en/&quot;), &quot;/en/&quot;, &quot;Home page&quot;, 0 ]); } IPCam.prototype = { set html(html) { this.source = html; }, fetch: function (url) { var content = UrlFetchApp.fetch(url); var html = content.getContentText(); this.html = html; return Cheerio.load(html); }, // Input: url ipcam fetchInDetail: function () { var db = new DB(); db.sheetName = &quot;IPCam&quot;; var row = db.getValueByIndex(14, 0); if (row) { var id = row[0]; var $ = this.fetch(&quot;https://www.insecam.org/en/view/&quot; + id + &quot;/&quot;); var tags = this.source &amp;&amp; this.source.match(/addtagset\\(&quot;(\\w+)&quot;\\)/gi) if (tags) { tags = tags.map(function (tag) { tag = tag.match(/addtagset\\(&quot;(\\w+)&quot;\\)/); return tag &amp;&amp; tag[1]; }); } var fields = $(&quot;.camera-details__row&quot;).map(function (i, item) { var cell = $(this).find(&quot;.camera-details__cell&quot;); var label = cell.first().text().toUpperCase().replace(/\\W+/gi, &quot;&quot;); var value = cell.first().next().text().trim(); return { label: label, value: value }; }).get(); fields.push({ label: &quot;TAGS&quot;, value: tags &amp;&amp; tags.join(&quot;,&quot;) || &quot;&quot; }); fields.push({ label: &quot;SOURCE&quot;, value: $(&quot;#image0&quot;).attr(&quot;src&quot;) || &quot;&quot; }); db.update(id, [ id, fields.fLabel(&quot;COUNTRY&quot;), fields.fLabel(&quot;COUNTRYCODE&quot;), fields.fLabel(&quot;COUNTRY&quot;), fields.fLabel(&quot;REGION&quot;), fields.fLabel(&quot;CITY&quot;), fields.fLabel(&quot;LATITUDE&quot;), fields.fLabel(&quot;LONGITUDE&quot;), fields.fLabel(&quot;ZIP&quot;), &quot;&#39;&quot; + fields.fLabel(&quot;TIMEZONE&quot;), fields.fLabel(&quot;MANUFACTURER&quot;), fields.fLabel(&quot;TAGS&quot;), fields.fLabel(&quot;SOURCE&quot;), 1 ]); } }, creatDetail: function (id) { var db = new DB(); db.sheetName = &quot;IPCam&quot;; if (db.hasId(id)) return; db.add([ id, &quot;&quot;, //fields.fLabel(&quot;COUNTRY&quot;), &quot;&quot;, // fields.fLabel(&quot;COUNTRYCODE&quot;), &quot;&quot;, // fields.fLabel(&quot;COUNTRY&quot;), &quot;&quot;, // fields.fLabel(&quot;REGION&quot;), &quot;&quot;, // fields.fLabel(&quot;CITY&quot;), &quot;&quot;, // fields.fLabel(&quot;LATITUDE&quot;), &quot;&quot;, // fields.fLabel(&quot;LONGITUDE&quot;), &quot;&quot;, // fields.fLabel(&quot;ZIP&quot;), &quot;&quot;, // fields.fLabel(&quot;TIMEZONE&quot;), &quot;&quot;, // fields.fLabel(&quot;MANUFACTURER&quot;), &quot;&quot;, // fields.fLabel(&quot;TAGS&quot;), &quot;&quot;, // fields.fLabel(&quot;SOURCE&quot;), 0 ]); }, // Input: page next, category url fetchInCategory: function () { var vm = this; var db = new DB(); db.sheetName = &quot;Links&quot;; var row = db.getValueByIndex(4, 0); if (row) { var idRow = row[0]; row[3] = 1; db.update(idRow, row); } var slug = row &amp;&amp; row[1]; var url = this.BASE_URL + slug; var $ = this.fetch(url); // get link view $(&#39;[href*=&quot;/en/view/&quot;]&#39;).map(function (i, item) { var href = $(item).attr(&quot;href&quot;); //Logger.log(&quot;Href:&quot; + href); var id = href.match(/(\\d+)/)[1]; //Logger.log(&quot;Id:&quot; + id); if (id) { vm.creatDetail(id); vm.listId.push(id); } }); // get other link $(&#39;[rel=&quot;index&quot;][href^=&quot;/en/&quot;]&#39;).map(function (i, item) { var href = $(item).attr(&quot;href&quot;); var id = Utilities.base64Encode(href); if (!db.hasId(id)) { var text = $(item).text().trim(); db.add([id, href, text, 0]); }; }); // pagenavigator if (slug) { var f = vm.source.match(/pagenavigator\\((&quot;\\?page=&quot;, ([\\d]+), ([\\d]+))\\);/); var from = f &amp;&amp; f.length &gt; 3 &amp;&amp; f[3], to = f &amp;&amp; f.length &gt; 2 &amp;&amp; f[2]; for (var i = from; i &lt;= to; i++) { if (i) { var href = slug + &quot;?page=&quot; + i; // Logger.log(&quot;Href:&quot; + href); var id = Utilities.base64Encode(href); if (!db.hasId(id)) { var text = i; db.add([id, href, text, 0]); }; } } } } }; 4 . WorkFlow (trigger) // c&agrave;o chỉ mục chuy&ecirc;n mục, đặt thời gian t&aacute;i k&iacute;ch hoạt l&agrave; 1 ph&uacute;t function workflow() { var i = new IPCam(); i.fetchInCategory(); } // c&agrave;o chỉ mục b&agrave;i viết chi tiết, đặt thời gian t&aacute;i k&iacute;ch hoạt l&agrave; 1 ph&uacute;t function detail() { var ip = new IPCam(); for(var i = 0; i &lt;= 6; i++){ ip.fetchInDetail(); } } Kết quả alt text Bot vẫn đang tiến h&agrave;nh c&agrave;o dữ liệu. https://docs.google.com/spreadsheets/d/1dABxJMpDCLSU-MpkQaR6wjXeWdIr3S8WqbRiTkWMjmo/edit?usp=sharing (*) B&agrave;i viết hơi sơ s&agrave;i, tỉnh ngủ sẽ update lại th&ecirc;m cho đỡ nhạt hơn, mong qu&yacute; bạn th&ocirc;ng cảm.</p>\n",
      "status": true,
      "tags": [
        "insecam.org", "Database", "Google AppScript"
      ]
    },
    {
      "title": "Engineer JAV thực hiện test theo cách kinh điển nhất như thế nào",
      "content": "<p>H&ocirc;m qua đọc được b&agrave;i kh&aacute; hay về 1 thanh ni&ecirc;n nhật (t&ecirc;n miwa) chia sẻ c&aacute;ch m&agrave; engineer trong c&ocirc;ng ty của họ test như thế n&agrave;o. Đọc xong thấy c&ocirc;ng nhận kh&acirc;m phục thật. C&ocirc;ng ty họ chạy theo c&aacute;ch đ&oacute; được gần hơn chục năm rồi. V&agrave; gần như sản phẩm chạy rất kh&oacute; ra bug. C&ugrave;ng nhau đọc xem họ l&agrave;m kiểu g&igrave; nh&eacute;. Bối cảnh C&ocirc;ng ty n&agrave;y chuy&ecirc;n ph&aacute;t triển về c&aacute;c phần mềm cho lĩnh vực y tế v&agrave; cũng chạy được gần 30 năm rồi. Hiện tại anh Miwa cũng đ&atilde; từng tham gia v&agrave;o nhiều dự &aacute;n, l&agrave;m với rất nhiều c&aacute;c kĩ sư nhưng team hiện tại m&agrave; a đang l&agrave;m th&igrave; quả thực năng lực test của c&aacute;c engineer kh&aacute; l&agrave; đỉnh. Vậy tại sao họ lại test đỉnh như vậy? C&oacute; rất nhiều yếu tố gi&uacute;p họ l&agrave;m được điều đ&oacute;, nhưng m&agrave; trong những thứ đ&oacute; c&oacute; 1 thứ l&agrave;m m&igrave;nh thực sự ấn tượng đ&oacute; l&agrave;: Mỗi ng&agrave;y mọi kĩ sư bỏ ra 1 tiếng để test hệ thống. Từ trước đến giờ quả thực chưa gặp c&ocirc;ng ty n&agrave;o ki&ecirc;n tr&igrave; như c&ocirc;ng ty n&agrave;y. Kĩ sư th&igrave; m&igrave;nh nghĩ ai ai cũng gh&eacute;t test cả, ai cũng muốn l&agrave;m cho xong. Nhưng m&agrave; c&ocirc;ng ty n&agrave;y đ&atilde; l&agrave;m được, v&agrave; l&agrave;m được tr&ecirc;n 15 năm mới kinh khủng. Mọi engineer mỗi ng&agrave;y phải d&agrave;nh ra 1 tiếng để test hệ thống Hằng ng&agrave;y, bất k&igrave; ai trong team cũng phải bỏ ra 1 tiếng để test. Thời gian test th&igrave; sẽ từ 10:00 ~ 17:00 mỗi ng&agrave;y. Kh&ocirc;ng phải l&agrave; trong khoảng thời gian đ&oacute; ai th&iacute;ch test l&uacute;c n&agrave;o th&igrave; test m&agrave; thời gian n&agrave;y sẽ được fix từ trước c&ugrave;ng với PC để test. V&iacute; dụ như A sẽ test từ 10:00 ~ 11:00 sử dụng PC-01. B sẽ test từ 11:00 ~ 12:00 sử dụng PC-02 V&agrave; cứ thế cho đến hết member th&igrave; th&ocirc;i. PC test ở đ&acirc;y được c&agrave;i đặt sẵn chương tr&igrave;nh để test rồi. Việc test n&agrave;y cũng giống như kh&aacute;ch h&agrave;ng đang sử dụng sản phẩm thật vậy. Test case th&igrave; đ&atilde; được chuẩn bị từ trước v&agrave; cứ thế l&agrave;m theo. Test từng case 1 v&agrave; x&aacute;c nhận xem kết quả c&oacute; như mong đợi hay kh&ocirc;ng v&agrave; ghi lại kết quả đ&atilde; test. Đương nhi&ecirc;n c&oacute; thể free test. Cứ miễn l&agrave; t&igrave;m ra bug th&igrave; th&ocirc;i. Cứ hết thời gian l&agrave; kết th&uacute;c qu&aacute; tr&igrave;nh test, kể cả chưa test xong đi chăng nữa. Kết quả thu được sau qu&aacute; tr&igrave;nh test hệ thống C&oacute; thể biết được những chức năng hay sản phẩm m&agrave; bản th&acirc;n m&igrave;nh kh&ocirc;ng tham gia ph&aacute;t triển. Biết được workflow m&agrave; kh&aacute;ch h&agrave;ng sử dụng hệ thống C&oacute; thể ph&aacute;t hiện được những bug tiềm t&agrave;ng. Biết được qu&aacute; tr&igrave;nh ph&aacute;t triển phần mềm như thế n&agrave;o? ai l&agrave; người đảm nhiệm, ai thiết kế &hellip; Ngo&agrave;i những test case được ghi trong bản đặc tả ra th&igrave; c&oacute; thể test tự do. Do đ&oacute; c&oacute; thể t&igrave;m ra được những bug m&agrave; &iacute;t ai để &yacute; đến. Kết luận Ai ai cũng gh&eacute;t test nhưng m&agrave; nếu l&agrave;m theo c&aacute;ch n&agrave;y quả thực chất lượng sản phẩm theo m&igrave;nh nghĩ sẽ được cải thiện r&otilde; rệt. 1 m&igrave;nh tester th&igrave; c&oacute; thể kh&ocirc;ng cover đủ hết tất tần tật c&aacute;c trường hợp nhưng nếu c&oacute; sự gi&uacute;p đỡ của c&aacute;c engineer th&igrave; điều đ&oacute; l&agrave; ho&agrave;n to&agrave;n c&oacute; thể. Nếu dự &aacute;n n&agrave;o đang gặp phải vấn đề về chất lượng th&igrave; hi vọng qua b&agrave;i n&agrave;y sẽ c&oacute; ch&uacute;t giải ph&aacute;p g&igrave; đ&oacute; cho c&aacute;c bạn. Ch&uacute;c c&aacute;c bạn th&agrave;nh c&ocirc;ng. Nguồn: https://nghethuatcoding.com/2019/06/27/engineer-jav-thuc-hien-test-theo-cach-kinh-dien-nhat/</p>\n",
      "total_views": 87,
      "status": true,
      "tags": [
        "JAV", "Engineer", "System Test"
      ]
    },
    {
      "title": "Tổng quan về Distributed system",
      "content": "<p>Ch&agrave;o anh em web developer! Hiện nay để một hệ thống web application c&oacute; thể th&agrave;nh c&ocirc;ng, nổi tiếng th&igrave; sẽ trải qua rất nhiều gian nan. Hệ thống của ch&uacute;ng ta cũng kh&ocirc;ng ngoại lệ. Sprint n&agrave;o ta cũng implement feature mới, fix bug để ho&agrave;n thiện business, logic của hệ thống. Nhưng cần phải biết, từng đ&oacute; chưa đủ để hệ thống của ch&uacute;ng ta th&agrave;nh c&ocirc;ng. L&uacute;c kh&aacute;ch h&agrave;ng sử dụng th&igrave; application của ch&uacute;ng ta nằm trong m&ocirc;i trường network, v&agrave; trong m&ocirc;i trường network th&igrave; tồn tại một kh&aacute;i niệm l&agrave; distributed system. Sớm muộn, hệ thống của ch&uacute;ng ta cũng l&agrave; distributed system. H&ocirc;m nay m&igrave;nh sẽ đi v&agrave;o tổng quan của distributed system v&agrave; l&agrave;m r&otilde; tại sao n&oacute; lại cần thiết. Thế giới quan web application trong mắt ch&uacute;ng ta Hẳn l&agrave; anh em đều biết fron-end, back-end, database. V&agrave; architecture lẫn flow sơ bộ th&igrave; anh em cũng đ&atilde; biết, n&oacute; như h&igrave;nh b&ecirc;n dưới. alt text Khi build một dự &aacute;n như tr&ecirc;n, anh em nghĩ sẽ c&oacute; chuyện g&igrave; xảy ra? Dự &aacute;n của ch&uacute;ng ta sẽ th&agrave;nh c&ocirc;ng vang dội. Kh&ocirc;ng! Tất nhi&ecirc;n, mọi thứ kh&ocirc;ng chỉ đơn giản như vậy. C&aacute;c vấn đề xảy ra v&agrave; c&aacute;ch giải quyết Nếu một ng&agrave;y server bỗng gặp vấn đề (về network hay hardware, application c&oacute; vấn đề g&igrave; đấy) th&igrave; sao? To&agrave;n bộ kh&aacute;ch h&agrave;ng đang d&ugrave;ng hệ thống của m&igrave;nh sẽ kh&ocirc;ng truy cập được. C&oacute; người đang lưu một th&ocirc;ng tin quan trọng th&igrave; server chết, th&ocirc;ng tin quan trọng đ&oacute; bị mất lu&ocirc;n :grimacing:. Nữa, tưởng tượng anh em c&oacute; một dự &aacute;n triển vọng (100 người d&ugrave;ng). OK, 100 người d&ugrave;ng:expressionless: Thấy ế ẩm qu&aacute;, anh em thu&ecirc; v&agrave;i b&agrave; chị marketing xịn về, v&agrave; kh&ocirc;ng biết mấy b&atilde; l&agrave;m c&aacute;i g&igrave; đ&oacute; (=)) :smiling_imp:) m&agrave; số người d&ugrave;ng hệ thống của anh em l&ecirc;n tới con số 500. Đ&uacute;ng &yacute; qu&aacute; rồi, như n&agrave;y mới gọi l&agrave; &quot;triển vọng&quot; chứ! L&uacute;c n&agrave;y, anh em sẽ nghĩ đến chuyện mở rộng bandwidth, nghĩ đến chuyện l&agrave;m sao server chịu được nhiều request hơn. Yeah, m&igrave;nh đang n&oacute;i đến Scalability đ&oacute; người anh em. C&oacute; thể chia th&agrave;nh 2 kiểu l&agrave; Horizontal scaling v&agrave; Vertical scaling. Vertical scaling chắc chắn l&agrave; suy nghĩ đầu ti&ecirc;n m&agrave; anh em nghĩ tới. Giờ hệ thống được y&ecirc;u cầu l&agrave; c&oacute; thể tiếp nhận đồng thời nhiều request hơn lẫn xử l&yacute; đồng thời cho nhiều request hơn (2 điều n&agrave;y kh&ocirc;ng giống nhau nha anh em), th&igrave; đương nhi&ecirc;n l&agrave; n&acirc;ng cấp con server của m&igrave;nh rồi. N&acirc;ng cấp hoặc th&ecirc;m processor, RAM, memory storage, thậm ch&iacute;, tậu hẳn một em server mới xịn hơn để thay thế em server cũ lu&ocirc;n. Rồi bẵng đi một thời gian, lượng người d&ugrave;ng của hệ thống đ&atilde; l&ecirc;n tới 2000 (I love marketing girls :heart_eyes:) Nhưng l&uacute;c n&agrave;y, ta kh&ocirc;ng thể n&acirc;ng cấp server nổi nữa, giờ phải t&igrave;m c&aacute;ch kh&aacute;c th&ocirc;i. 2 vấn đề tr&ecirc;n đ&ograve;i hỏi high availability v&agrave; large request covering. Horizontal scaling chứ g&igrave; nữa! Single machine chịu kh&ocirc;ng nổi th&igrave; chơi kiểu multi-machine vậy. Bằng c&aacute;ch n&agrave;y, d&ugrave; hệ thống c&oacute; mấy trăm ng&agrave;n người d&ugrave;ng th&igrave; ta vẫn triển được. Horizontal scaling Đại kh&aacute;i hệ thống của m&igrave;nh sẽ như n&agrave;y. alt text Khi 1 user send 1 c&aacute;i request th&igrave; Load Balancer sẽ distribute request đ&oacute; cho 1 trong những Web client( ch&iacute;nh l&agrave; thứ ch&uacute;ng ta hay gọi l&agrave; front-end). Tuỳ v&agrave;o request, nếu request y&ecirc;u cầu thay đổi data(write) th&igrave; ta sẽ gọi đến Master, c&ograve;n nếu chỉ y&ecirc;u cầu read th&igrave; gọi đến Slave. Master v&agrave; Slave ở đ&acirc;y đều được gọi chung l&agrave; Replica. Replication Replication ở Distributed system c&oacute; 2 loại: o Passive Replication: hay c&ograve;n gọi l&agrave; primary-backup hoặc master-slave, một số t&agrave;i liệu gọi l&agrave; High-availability replication(c&aacute;i t&ecirc;n n&oacute;i l&ecirc;n lợi &iacute;ch :stuck_out_tongue_closed_eyes:) . H&igrave;nh ph&iacute;a tr&ecirc;n thuộc dạng n&agrave;y đ&oacute; anh em. Master handle việc write, c&oacute; thể l&agrave; read nữa ( nhưng ph&iacute; lắm), c&ograve;n Slave handle việc read. Loại n&agrave;y sẽ c&oacute; 2 lợi &iacute;ch ch&iacute;nh: high availability v&agrave; back-up, nữa l&agrave; high performance. Nếu l&agrave;m r&otilde; ra th&igrave;: availability, request latency, read bandwidth, solve bottle neck-deadlock, backup, geographic location... o Active Replication: hay c&ograve;n gọi l&agrave; multi-primary hoặc multi-master, master-master lẫn Enterprise Replication đều được. Mọi master đều handle việc write. Trường hợp hệ thống m&igrave;nh c&oacute; nhiều client request y&ecirc;u cầu write database qu&aacute;, đến nỗi con master m&igrave;nh n&acirc;ng cấp hết mức rồi m&agrave; vẫn chả handle nổi, th&igrave; đ&acirc;y l&agrave; phương &aacute;n giải quyết. Nhưng giải ph&aacute;p n&agrave;y th&igrave; sẽ c&oacute; data conflict, cần ta c&oacute; những resolution tốt. Anh em nghĩ khi bị conflict data th&igrave; sẽ c&oacute; giải ph&aacute;p g&igrave;? Version? 2 master đều thay đổi 1 record đồng thời th&igrave; version kh&ocirc;ng gi&uacute;p &iacute;ch được g&igrave;. Time stamp? Kh&ocirc;ng được, v&igrave; trong distributed system kh&ocirc;ng c&oacute; global clock. C&aacute;ch giải quyết đơn giản nhất l&agrave; ignore, c&ograve;n nếu tất cả c&aacute;c server c&ugrave;ng nằm tr&ecirc;n 1 cluster c&oacute; d&ugrave;ng global time th&igrave; sẽ d&ugrave;ng global time để check. C&oacute; rất nhiều rule, anh em c&oacute; thể t&igrave;m hiểu th&ecirc;m ở Data conflict resolution để nắm r&otilde; hơn. Distributed system Distributed system l&agrave; g&igrave;? OK! V&ograve;ng v&egrave;o n&atilde;y giờ để đặt vấn đề v&agrave; t&igrave;m c&aacute;ch giải quyết. Vậy th&igrave; li&ecirc;n quan g&igrave; tới distributed system? Distributed system l&agrave; một hệ thống c&oacute; c&aacute;c th&agrave;nh phần được đặt tr&ecirc;n c&aacute;c m&aacute;y t&iacute;nh nối mạng kh&aacute;c nhau, giao tiếp v&agrave; phối hợp h&agrave;nh động của ch&uacute;ng bằng c&aacute;ch pass message cho nhau. N&oacute;i đến đ&acirc;y th&igrave; anh em đều ph&aacute;t hiện, m&ocirc; h&igrave;nh trong phần Horizontal Scaling cũng l&agrave; một dạng distributed system phải kh&ocirc;ng? Nghĩa l&agrave;, khi một system đủ lớn th&igrave; sẽ xuất hiện c&aacute;c vấn đề, v&agrave; c&aacute;ch giải quyết l&agrave; biến n&oacute; th&agrave;nh distributed system. Li&ecirc;n hệ với parallel system Parallel system kh&aacute; gần với distributed system: mọi processor d&ugrave;ng chung 1 memory. Bởi d&ugrave;ng chung n&ecirc;n chả cần phải pass message. Nhưng đ&atilde; l&agrave; d&ugrave;ng chung, th&igrave; sẽ c&oacute; tranh chấp t&agrave;i nguy&ecirc;n, dẫn tới t&igrave;nh trạng bottleneck, ảnh hưởng performance n&ecirc;n sẽ chậm hơn so với việc d&ugrave;ng t&agrave;i nguy&ecirc;n ri&ecirc;ng lẻ như trong distributed system. C&ograve;n distributed system c&oacute; h&igrave;nh thức kết hợp lỏng lẻo hơn (loosely coupled) parallel system, mỗi processor d&ugrave;ng ri&ecirc;ng một memory, data đều giống nhau( ch&iacute;nh x&aacute;c l&agrave; consistent với nhau), n&ecirc;n sẽ giải quyết được những vấn đề đ&oacute;. L&uacute;c n&agrave;y sẽ xuất hiện vấn đề l&agrave; c&aacute;c memory kh&ocirc;ng consistent. Ta phải l&agrave;m sao? C&aacute;ch 1, request đến tất cả c&aacute;c node, nếu fail th&igrave; fail tất cả, nhưng sẽ bị block 1 thời gian, performance sẽ giảm. C&aacute;ch 2, d&ugrave;ng message passing - c&aacute;ch được nhiều anh em chọn tr&ecirc;n to&agrave;n thế giới, tuy data sẽ kh&ocirc;ng consistent tại một v&agrave;i thời điểm nhưng đ&acirc;y l&agrave; c&aacute;ch đ&aacute;nh đổi hợp l&yacute;. alt text (a), (b): a distributed system. (c): a parallel system. Wiki Anh em xem h&igrave;nh tr&ecirc;n để dễ tưởng tượng nghen. Nếu l&agrave; parallel system th&igrave; ta sẽ chia sẻ resource, memory..., v&iacute; dụ như hệ thống c&oacute; nhiều server m&agrave; x&agrave;i chung database, hoặc nhiều processor x&agrave;i chung resource của computer vậy đ&oacute;, nhưng kiểu n&agrave;y sẽ gặp vấn đề về locking, blocking. C&ograve;n distributed system th&igrave; kh&ocirc;ng d&ugrave;ng chung resource, mỗi resource đều giống nhau( ch&iacute;nh x&aacute;c l&agrave; consistent với nhau), n&ecirc;n sẽ giải quyết được những vấn đề đ&oacute;. Như anh em hay nghe về CQRS đấy, nếu dự &aacute;n n&agrave;o t&aacute;ch việc write-read nhưng chẳng t&aacute;ch database ra th&igrave; vẫn l&agrave; parallel system th&ocirc;i, vẫn d&iacute;nh performance issue như thường, c&ograve;n nếu t&aacute;ch database ra ri&ecirc;ng th&igrave; sẽ l&agrave; distributed system. Microservices architecture Microservices cũng l&agrave; một dạng của distributed system. Ở microservices, người ta t&aacute;ch mỗi service ra ri&ecirc;ng v&agrave; thường th&igrave; kh&ocirc;ng references với nhau, l&uacute;c deploy th&igrave; mỗi service sẽ đ&oacute;ng vai l&agrave; 1 server, t&aacute;ch biệt với c&aacute;c service kh&aacute;c. Nhưng c&aacute;c service vẫn c&oacute; data li&ecirc;n quan với nhau (n&ecirc;n mới xảy ra chuyện pass message đ&oacute;, kh&ocirc;ng li&ecirc;n quan th&igrave; pass message l&agrave;m g&igrave;?), c&ograve;n data được hiểu như thế n&agrave;o, m&ocirc; h&igrave;nh dữ liệu như thế n&agrave;o th&igrave; t&ugrave;y v&agrave;o Bounded context (h&igrave;nh b&ecirc;n dưới). alt text L&uacute;c n&agrave;y nếu ta cho to&agrave;n bộ server kết nối với 1 database duy nhất th&igrave; hệ thống của ta l&agrave; parallel system, nhưng như n&atilde;y m&igrave;nh n&oacute;i đ&oacute;, sẽ bị c&aacute;c vấn đề về locking, blocking data khi d&ugrave;ng chung t&agrave;i nguy&ecirc;n. C&ograve;n nếu ta t&aacute;ch hẳn database ra th&agrave;nh nhiều phần, mỗi database d&ugrave;ng cho mỗi service th&igrave; l&uacute;c n&agrave;y hệ thống của ch&uacute;ng ta sẽ l&agrave; distributed system, sẽ kh&ocirc;ng gặp vấn đề đ&oacute; nữa. Nhưng sẽ nảy sinh ra vấn đề data tr&ecirc;n c&aacute;c service bị lỏng lẻo, kh&ocirc;ng consistent. V&agrave; đ&acirc;y cũng l&agrave; vấn đề lớn nhất, nan giải nhất ở m&ocirc; h&igrave;nh n&agrave;y, nếu kh&ocirc;ng handle tốt th&igrave; sẽ c&oacute; vấn đề lớn. Thường th&igrave; ta sẽ chấp nhận eventually consistency, cho ph&eacute;p c&oacute; một khoảng thời gian nhỏ data tr&ecirc;n to&agrave;n hệ thống kh&ocirc;ng consistent, nhưng sau khoảng thời gian đ&oacute; th&igrave; data tr&ecirc;n mọi replica sẽ trở về trạng th&aacute;i thống nhất với nhau. Microservices distribute về: Tr&aacute;ch nhiệm, chức năng: application của ta distribute ra nhiều service ri&ecirc;ng lẻ. Từ một business khổng lồ ta chia ra nhiều phần nhỏ, mỗi service l&atilde;nh một tr&aacute;ch nhiệm chuy&ecirc;n biệt. Code: theo đ&oacute;, code được distribute ra tr&ecirc;n nhiều service, v&agrave; deploy tr&ecirc;n nhiều server (mỗi service n&agrave;y c&oacute; thể nằm tr&ecirc;n 1 server ri&ecirc;ng m&agrave; vẫn hoạt động tốt). Data: mỗi service d&ugrave;ng mỗi database ri&ecirc;ng của ch&uacute;ng. Trong monolithic ta d&ugrave;ng 1 database chung chứa tất cả data của application, nhưng trong microservice th&igrave; được distribute ra, mỗi service d&ugrave;ng 1 database sao cho database của mỗi service l&agrave; vừa đủ để d&ugrave;ng. Nghĩa l&agrave; service cần th&ocirc;ng tin g&igrave; th&igrave; database của n&oacute; sẽ chứa th&ocirc;ng tin đ&oacute;, database của mỗi service kh&ocirc;ng chứa những th&ocirc;ng tin kh&ocirc;ng cần thiết, anh em c&oacute; thể nh&igrave;n h&igrave;nh ảnh ph&iacute;a tr&ecirc;n để dễ tưởng tượng hơn. Ch&iacute;nh s&aacute;ch &quot;chia để trị&quot; n&agrave;y sẽ dễ d&agrave;ng cho việc quản l&yacute; code, quản l&yacute; permission, giảm request latency, dễ d&agrave;ng ph&aacute;t triển, maintain lẫn kh&ocirc;ng phụ thuộc c&ocirc;ng nghệ lẫn nhau... Kết b&agrave;i Qua b&agrave;i viết cơ bản n&agrave;y, m&igrave;nh hi vọng anh em thấy được những vấn đề của hệ thống web application v&agrave; c&oacute; được c&aacute;i nh&igrave;n tổng quan về distributed system hơn. C&ograve;n những anh em n&agrave;o từ c&aacute;c b&agrave;i viết kh&aacute;c của m&igrave;nh tới đ&acirc;y th&igrave; m&igrave;nh mong anh em sẽ hiểu được tất cả những g&igrave; m&igrave;nh viết:smile:. V&agrave; m&igrave;nh cũng mong anh em g&oacute;p &yacute; để b&agrave;i viết được cải thiện hơn nh&eacute;! Ch&uacute;c anh em lu&ocirc;n vui vẻ!</p>\n",
      "total_views": 223,
      "status": true,
      "tags": [
         "Distributed system"
      ]
    },
    {
      "title": "Hiểu và chọn database trong NoSQL DBMS [Part1] - Các loại NoSQL DBMSt",
      "content": "<p>Ch&agrave;o những người anh em! Trong thời đại c&ocirc;ng nghệ hiện nay, c&oacute; rất nhiều hướng để giải quyết một b&agrave;i to&aacute;n. Database (ch&iacute;nh x&aacute;c l&agrave; DBMS - database management system) cũng vậy, c&agrave;ng ng&agrave;y c&agrave;ng ra những engine mới để đ&aacute;p ứng nhu cầu của người d&ugrave;ng. DBMS c&oacute; thể chia th&agrave;nh 2 loại l&agrave; RDBMS( relational database management system) v&agrave; NoSQL DBMS. NoSQL sinh sau đẻ muộn nhưng lại vươn l&ecirc;n kh&aacute; nhanh v&igrave; c&oacute; những t&iacute;nh chất, t&iacute;nh năng m&agrave; RDBMS kh&ocirc;ng hỗ trợ. Ở đ&acirc;y c&oacute; anh em n&agrave;o tiếp x&uacute;c với NoSQL DBMS hằng ng&agrave;y nhưng lại hơi mơ hồ, chưa c&oacute; c&aacute;i nh&igrave;n tổng qu&aacute;t lẫn cụ thể về n&oacute; kh&ocirc;ng? C&oacute; ai đang l&agrave;m tr&ecirc;n những hệ thống d&ugrave;ng MongoDB, Redis, nhưng lại kh&ocirc;ng thực sự hiểu ch&uacute;ng? C&oacute; ai đang build up dự &aacute;n nhưng lại đang ph&acirc;n v&acirc;n kh&ocirc;ng biết chọn loại database n&agrave;o ? Để giải quyết những vấn đề ấy th&igrave; m&igrave;nh sẽ n&oacute;i về c&aacute;c loại NoSQL, đi s&acirc;u v&agrave;o t&iacute;nh chất v&agrave; suy luận ra c&aacute;c trường hợp sử dụng của ch&uacute;ng nha. C&aacute;c loại NoSQL DBMS: &bull; Key-value store &bull; Document store &bull; Wide comlumn store &bull; Graph store Key-value store Định nghĩa: M&ocirc; h&igrave;nh dữ liệu đơn giản nhất. Khi m&igrave;nh biết key, th&igrave; m&ocirc; h&igrave;nh n&agrave;y l&agrave; c&aacute;ch nhanh nhất để lấy value. M&ocirc; h&igrave;nh n&agrave;y kh&ocirc;ng c&oacute; ng&ocirc;n ngữ truy vấn, nhưng n&oacute; vẫn cung cấp c&aacute;ch lưu trữ, truy xuất v&agrave; cập nhật dữ liệu bằng c&aacute;ch sử dụng c&aacute;c lệnh get, put v&agrave; delete đơn giản. V&iacute; dụ: DBMS: Redis, Amazon DynamoDB , FoundationDB. Twitter sử dụng Redis để ph&acirc;n phối Twitter timeline(Link) Pinterest sử dụng Redis để lưu trữ danh s&aacute;ch users, followers, unfollowers v&agrave; nhiều thứ nữa(Link) Redis thường xuy&ecirc;n được sử dụng l&agrave;m Caching database để tăng tốc tốc độ của ứng dụng. Trường hợp sử dụng: Chia sẻ dữ liệu giữa c&aacute;c ứng dụng như distributed cache hoặc để lưu trữ dữ liệu user session, user preference v&agrave; profile, shopping cart v&agrave; thậm ch&iacute; l&agrave; Real-time bidding (Đặt gi&aacute; thầu). Giải th&iacute;ch: Trong thời đại hiện nay, những application x&acirc;y dựng l&ecirc;n th&igrave; hay đi đ&ocirc;i với authentication/authorization, thậm ch&iacute; l&agrave; c&oacute; những hệ thống m&agrave; mọi application của n&oacute; d&ugrave;ng 1 identity server duy nhất để x&aacute;c thực, th&igrave; việc handle authentication/authorization rất quan trọng. 1 trong những c&aacute;ch đ&oacute; l&agrave; session store, anh em n&agrave;o biết session rồi th&igrave; pass qua c&acirc;u chuyện xạo ch&uacute;a m&agrave; m&igrave;nh sắp kể nh&eacute;: Hệ thống của ta chỉ implement theo kiểu basic authentication :expressionless:, hoặc l&agrave; chỉ d&ugrave;ng token th&ocirc;i, th&igrave; ph&iacute;a server của m&igrave;nh sướng, chả phải lưu trữ th&ecirc;m th&ocirc;ng tin đăng nhập của user g&igrave; cả. Rồi một ng&agrave;y c&oacute; 1 cuộc gọi từ 1 kh&aacute;ch h&agrave;ng *hịn của m&igrave;nh: Kh&aacute;ch xịn: -Em ơi c&oacute; đứa n&agrave;o n&oacute; đang x&agrave;i t&agrave;i khoản của anh, out ra gi&ugrave;m anh c&aacute;i. Ta: :unamused:Hmm, được kh&ocirc;ng ta... :scream: Sao m&agrave; out ra gi&ugrave;m được b&agrave; nội, hệ thống m&igrave;nh cho client lưu trữ th&ocirc;ng tin đăng nhập hết chứ c&oacute; giữ th&ocirc;ng tin n&agrave;y ở server đ&acirc;u, chỉ biết đợi phi&ecirc;n đăng nhập hết hạn th&ocirc;i. :dizzy_face: Kh&aacute;ch xịn: -Sao hả ch&uacute;, out được chưa? Ta: -Dạ để em implement th&ecirc;m đ&atilde;. Nửa năm sau nh&eacute; anh.:sweat_smile: Kh&aacute;ch xịn: -:triumph: Đấy, kh&aacute;ch h&agrave;ng l&agrave; thượng đế, ta phải chiều cả những kh&aacute;ch h&agrave;ng kh&oacute; t&iacute;nh. Nhưng m&agrave; kiểu g&igrave; th&igrave; kiểu, ta cũng phải bảo vệ người d&ugrave;ng của m&igrave;nh chứ! Trở lại vấn đề, nếu kh&ocirc;ng lưu trữ lại g&igrave; tr&ecirc;n server của m&igrave;nh th&igrave; l&agrave;m sao quản l&yacute; chặt được. Vậy ta sẽ lưu trữ session để quản l&yacute; mạnh về authentication/authorization. Với lại, tưởng tượng 1 người d&ugrave;ng đang sử dụng nhiều app của 1 hệ thống, rồi từ 1 trong những app đ&oacute; đăng xuất từ t&agrave;i khoản 1 v&agrave; đăng nhập v&agrave;o t&agrave;i khoản 2, th&igrave; c&aacute;c app kh&aacute;c vẫn đang x&agrave;i token của t&agrave;i khoản 1, kh&ocirc;ng đăng xuất cũng kh&ocirc;ng switch qua t&agrave;i khoản 2, l&uacute;c n&agrave;y c&aacute;c app của người d&ugrave;ng kh&ocirc;ng đồng bộ, thống nhất với nhau. Những vấn đề tr&ecirc;n đ&atilde; n&oacute;i l&ecirc;n việc lưu trữ user session hoặc c&aacute;c th&ocirc;ng tin của user( tuỳ c&aacute;ch handle, c&oacute; thể l&agrave; token lu&ocirc;n) ở ph&iacute;a server quan trọng như thế n&agrave;o. Hết chuyện session. Tiếp theo, biết l&agrave; việc lưu trữ user session quan trọng rồi đấy, nhưng tại sao ch&uacute;ng ta lại d&ugrave;ng c&aacute;i thằng Key-value store n&agrave;y chứ?:flushed: =&gt;Đơn giản v&igrave; n&oacute; đơn giản :D Kh&ocirc;ng cần query phức tạp m&agrave; chỉ cần lưu trữ session, l&uacute;c cần th&igrave; get, update value chỉ cần biết key. Trường hợp tiếp theo, m&ocirc; h&igrave;nh n&agrave;y được sử dụng cho shopping cart v&agrave; Real-time bidding, trong khi hồi xưa đến giờ ch&uacute;ng ta vẫn nghĩ mấy c&aacute;i li&ecirc;n quan đến tiền bạc n&agrave;y nọ th&igrave; chọn RDBMS đi chứ sao lại d&ugrave;ng NoSQL key-value g&igrave;?:confused: No,no. RDBMS rất mạnh về consistency, nhưng khi implement tr&ecirc;n hệ thống ph&acirc;n t&aacute;n th&igrave; vẫn l&agrave; eventually consistency m&agrave; th&ocirc;i, nghĩa l&agrave; ở 1 nơi th&igrave; check request sẽ thấy g&oacute;i m&igrave; t&ocirc;m với quả c&agrave; chua trong giỏ rồi, cứ đinh ninh l&agrave; sẽ ăn t&ocirc; m&igrave; như b&ecirc;n dưới, nhưng m&agrave; nơi kh&aacute;c check th&igrave; chỉ thấy mỗi quả c&agrave; chua kh&ocirc;ng (quả n&agrave;y m&agrave; mua h&agrave;ng th&igrave; về nh&agrave; chỉ c&oacute; ăn c&agrave; chua hấp :stuck_out_tongue_winking_eye:) alt text N&ecirc;n m&igrave;nh khẳng định NoSQL vẫn c&oacute; vị thế khi handle những hệ thống về real-time, n&oacute; lại hỗ trợ scale-out rất tốt n&ecirc;n chả c&oacute; g&igrave; ch&uacute;ng ta phải ngại. Anh em đang hỏi m&igrave;nh thằng key-value store n&agrave;y hanle kiểu g&igrave; hả? Chứ trong khi đặt thầu quan trọng đến từng khoảnh khắc, kh&ocirc;ng handle tốt th&igrave; 1 &ocirc;ng chốt gi&aacute; thấp lại thắng thầu &ocirc;ng gi&aacute; cao, hoặc l&agrave; kết quả thầu kh&aacute;c nhau tại c&aacute;c server tr&ecirc;n thế giới chứ chả chơi :joy: alt text Bởi v&igrave; nếu &aacute;p dụng m&ocirc; h&igrave;nh n&agrave;y th&igrave; near real-time, độ trễ lan truyền của c&aacute;c database rất l&agrave; thấp, nghĩa l&agrave; c&aacute;i thời gian m&agrave; c&aacute;c database kh&ocirc;ng consistent rất l&agrave; thấp. B&iacute; quyết của m&ocirc; h&igrave;nh n&agrave;y l&agrave; g&igrave;? Ch&iacute;nh l&agrave; nằm ở sự đơn giản của n&oacute;. Khi ta cầm một thứ b&ugrave;i nh&ugrave;i trong tay (gi&aacute; trị phức tạp) th&igrave; ch&uacute;ng ta sẽ kiểm tra, xử l&yacute;, rồi lại truyền tay cho người kh&aacute;c, rồi người đ&oacute; lại nghi ngờ, phải kiểm tra thứ b&ugrave;i nh&ugrave;i đ&oacute; c&oacute; kim ti&ecirc;m HIV kh&ocirc;ng :unamused: Hết cả thời gian! Giờ ch&uacute;ng ta chỉ sử dụng gi&aacute; trị cực đơn giản cho value, th&igrave; c&aacute;c hệ thống c&oacute; phải xử l&yacute;, kiểm tra nhiều kh&ocirc;ng? Kh&ocirc;ng! Nice choose :+1: Một số db server lại n&acirc;ng cao tốc độ hơn nữa bằng c&aacute;ch sử dụng ổ SSD hoặc flash storage, kiểu n&agrave;y th&igrave; sợ g&igrave; nữa c&aacute;c b&aacute;c :D Document store Định nghĩa: M&ocirc; h&igrave;nh dữ liệu để lưu trữ đối tượng t&agrave;i liệu theo kiểu semi-structured(b&aacute;n cấu tr&uacute;c) v&agrave; metadata(si&ecirc;u dữ liệu), schema-free nha anh em. M&ocirc; h&igrave;nh n&agrave;y cũng l&agrave; key-value th&ocirc;i nhưng m&agrave; value ở đ&acirc;y l&agrave; nguy&ecirc;n 1 c&aacute;i object phức tạp hơn kiểu key-value hồi n&atilde;y. Những datase theo m&ocirc; h&igrave;nh n&agrave;y th&igrave; thường d&ugrave;ng JSON format để thể hiện c&aacute;c đối tượng. Nhưng Json th&igrave; hỗ trợ type kh&ocirc;ng phong ph&uacute; bằng Bson, n&ecirc;n anh em để &yacute; th&ecirc;m vấn đề n&agrave;y nh&eacute;. Hiện tại th&igrave; m&igrave;nh biết MongoDB v&agrave; LiteDB hỗ trợ format Bson. V&iacute; dụ: DBMS: MongoDB, CouchDB, Elasticsearch, Solr. SEGA sử dụng MongoDB để xử l&yacute; h&agrave;ng chục triệu t&agrave;i khoản trong tr&ograve; chơi. Chicago sử dụng MongoDB để tạo ra app WindyGrid&rsquo;, gi&uacute;p quản l&yacute; th&agrave;nh phố một c&aacute;ch th&ocirc;ng minh, an to&agrave;n hơn(Link) EO Media Group: Tăng mức độ tương t&aacute;c trang web với t&iacute;nh năng Search mạnh mẽ (Link) Trường hợp sử dụng: Xử l&yacute; c&aacute;c đối tượng kh&ocirc;ng c&oacute; dữ liệu phức tạp, để nhanh ch&oacute;ng t&igrave;m kiếm hoặc lọc theo một số thuộc t&iacute;nh đối tượng. Giải th&iacute;ch: M&ocirc; h&igrave;nh n&agrave;y th&igrave; qu&aacute; th&ocirc;ng dụng trong NoSQL DBMS lu&ocirc;n. V&igrave; n&oacute; document oriented, m&agrave; mỗi document th&igrave; kh&ocirc;ng phải phụ thuộc v&agrave;o bố con thằng n&agrave;o, v&agrave; flexible - document n&agrave;y c&oacute; thể c&oacute; những thuộc t&iacute;nh n&agrave;y m&agrave; document kia c&oacute; thể kh&ocirc;ng c&oacute;, kh&ocirc;ng bắt buộc, v&agrave; cũng kh&ocirc;ng c&oacute; constraints lu&ocirc;n n&ecirc;n rất dễ thể hiện c&aacute;c object v&agrave; khi insert update th&igrave; cũng chả check fail g&igrave; v&igrave; chả c&oacute; r&agrave;ng buộc g&igrave; cả. M&ocirc; h&igrave;nh n&agrave;y cũng th&ocirc;ng dụng với anh em rồi, nhưng lưu &yacute; gi&ugrave;m m&igrave;nh d&ugrave; m&ocirc; h&igrave;nh n&agrave;y kh&aacute; tương tự với row based của RDBMS nhưng lại kh&aacute;c biệt rất lớn nha. Trong RDBMS th&igrave; dữ liệu &iacute;t tr&ugrave;ng lặp nhờ v&agrave;o foreign key nhưng cũng v&igrave; đ&oacute; c&oacute; rắc rối. V&iacute; dụ cập nhập dữ liệu của một row trong table n&agrave;y, nhưng database phải lock row đ&oacute; lại, hoặc lock page, thậm ch&iacute; l&agrave; lock table( tuỳ theo cơ chế của database hiện tại v&agrave; độ lớn, độ ảnh hưởng của sự thay đổi n&agrave;y) v&agrave; lock lu&ocirc;n những data sẽ ảnh hưởng tới. Rồi, việc thay đổi schemas cũng kh&oacute; khăn hơn so với NoSQL, m&agrave; nếu trong context distributed system th&igrave; sự thay đổi n&agrave;y sẽ k&eacute;o theo 1 đống anh em database thay đổi lu&ocirc;n (nếu ch&uacute;ng cũng x&agrave;i RDBMS). Tuy nhi&ecirc;n c&aacute;i g&igrave; cũng c&oacute; mặt lợi v&agrave; mặt hại của n&oacute;, schema-less, flexible nhưng phải k&egrave;m theo việc handle tốt. Thả r&ocirc;ng th&igrave; cũng phải giữ cho săn chắc chứ kh&ocirc;ng th&igrave; sệ c&oacute; ng&agrave;y đ&oacute; anh em :smiling_imp: Wide column store (Big table) Định nghĩa: Wide column store, hay c&ograve;n được gọi l&agrave; Big table, hay extensible record store, l&agrave; m&ocirc; h&igrave;nh dữ liệu để lưu trữ dữ liệu với khả năng chứa rất nhiều column(cột), v&agrave; column ở đ&acirc;y l&agrave; dynamic column. T&ecirc;n column c&oacute; thể thay đổi n&ecirc;n ta c&oacute; thể tưởng tượng ra m&ocirc; h&igrave;nh n&agrave;y như l&agrave; key-value store 2 chiều. 1 pair c&oacute; key l&agrave; id đối tượng v&agrave; t&ecirc;n column, c&ograve;n value l&agrave; th&ocirc;ng tin của đối tượng. V&iacute; dụ: DBMS: Cassandra, HBase,Microsoft Azure Cosmos DB. Spotify d&ugrave;ng Cassandra để lưu trữ c&aacute;c user profile v&agrave; metadata về c&aacute;c nghệ sĩ, b&agrave;i h&aacute;t, v.v để c&aacute; nh&acirc;n h&oacute;a tốt hơn (Link). Facebook: T&iacute;nh năng &quot;bạn b&egrave; gần đ&acirc;y&quot; v&agrave; lập chỉ mục t&igrave;m kiếm (Link). Trường hợp sử dụng: L&agrave;m việc tốt trong c&aacute;c distributed system. Khi ta c&oacute; qu&aacute; nhiều dữ liệu, đến mức m&agrave; nghĩ đến chuyện phải trải n&oacute; tr&ecirc;n nhiều m&aacute;y t&iacute;nh, th&igrave; n&ecirc;n xem x&eacute;t một database kiểu Wide column store. Giải th&iacute;ch: M&ocirc; h&igrave;nh n&agrave;y cũng c&oacute; những thứ tương tự Document oriented th&ocirc;i, cũng schema-free, v&agrave; vẫn t&igrave;m kiếm dựa tr&ecirc;n field được, nhưng implement rất kh&aacute;c nhau, anh em c&oacute; thể xem lại định nghĩa để hiểu r&otilde; nh&eacute;. alt text Ngo&agrave;i ph&acirc;n biệt với Document oriented, ta cũng cần tr&aacute;nh nhầm lẫn với column oriented storage của RDBMS. Đ&oacute; l&agrave; 1 dạng improve performance của RDBMS, focus theo column, lưu dữ liệu theo column thay v&igrave; row, c&acirc;u query của ch&uacute;ng vẫn giống nhau nhưng truy cập v&agrave;o đ&uacute;ng phần data m&agrave; m&igrave;nh muốn thay v&igrave; scan nguy&ecirc;n cả c&aacute;i row v&agrave; lấy lu&ocirc;n c&aacute;c data m&igrave;nh kh&ocirc;ng cần trong query rồi sau đ&oacute; l&agrave; lọc ra column m&igrave;nh muốn, rất lợi cho việc analysis ha. Graph store Định nghĩa: M&ocirc; h&igrave;nh được thiết kế cho dữ liệu c&oacute; quan hệ được biểu diễn tốt dưới dạng biểu đồ v&agrave; c&oacute; c&aacute;c yếu tố được li&ecirc;n kết với nhau, với số lượng quan hệ kh&ocirc;ng x&aacute;c định giữa ch&uacute;ng. alt text Trong h&igrave;nh tr&ecirc;n th&igrave; &ocirc; tr&ograve;n l&agrave; Node, c&ograve;n mấy c&aacute;i mũi t&ecirc;n l&agrave; Edge, th&ocirc;ng tin trong node l&agrave; Properties nha. Node: đại diện cho c&aacute;c thực thể như người, t&agrave;i khoản,.. Ch&uacute;ng gần tương đương với bản ghi, quan hệ hoặc h&agrave;ng trong cơ sở dữ liệu quan hệ hoặc document trong document store. Edge(cạnh): c&ograve;n được gọi l&agrave; relationships, l&agrave; c&aacute;c đường kết nối c&aacute;c node, đại diện cho mối quan hệ giữa ch&uacute;ng. C&aacute;c edge c&oacute; thể c&oacute; hướng hoặc v&ocirc; hướng. Trong một đồ thị v&ocirc; hướng, một cạnh từ điểm n&agrave;y đến điểm kh&aacute;c c&oacute; chung một &yacute; nghĩa. Trong đồ thị c&oacute; hướng, c&aacute;c cạnh nối hai điểm kh&aacute;c nhau c&oacute; &yacute; nghĩa kh&aacute;c nhau t&ugrave;y thuộc v&agrave;o hướng của ch&uacute;ng. C&aacute;c cạnh l&agrave; kh&aacute;i niệm ch&iacute;nh trong cơ sở dữ liệu đồ thị, thể hiện sự trừu tượng kh&ocirc;ng được triển khai trực tiếp trong m&ocirc; h&igrave;nh quan hệ hoặc m&ocirc; h&igrave;nh lưu trữ t&agrave;i liệu. Anh em c&oacute; thể &ocirc;n lại kiến thức về đồ thị v&ocirc; hướng nếu muốn hiểu s&acirc;u về m&ocirc; h&igrave;nh nha. Properties: l&agrave; th&ocirc;ng tin li&ecirc;n quan đến c&aacute;c node. Graph model chia ra 2 model nhỏ l&agrave;: RDF v&agrave; Labeled Property Graph Models. Graph DBMS lại c&oacute; nhiều kiểu như: Social graph, Intent graph, Consumption graph, Interest graph, Mobile graph. V&iacute; dụ: DBMS: Neo4j, Titan. Anh em c&oacute; biết đến Medium kh&ocirc;ng, chắc th&acirc;n thuộc lắm nhỉ? Medium sử dụng Neo4j để x&acirc;y dựng social graph. Nữa l&agrave; Walmart sử dụng Neo4j để recommend cho kh&aacute;ch h&agrave;ng c&aacute;c khuyến nghị v&agrave; khuyến m&atilde;i sản phẩm được c&aacute; nh&acirc;n h&oacute;a, c&oacute; li&ecirc;n quan. Trường hợp sử dụng: C&aacute;c hệ thống y&ecirc;u cầu dữ liệu với số lượng lớn c&aacute;c mối quan hệ linh hoạt, y&ecirc;u cầu cấu tr&uacute;c c&oacute; thể mở rộng để th&ecirc;m dữ liệu mới, y&ecirc;u cầu truy vấn c&aacute;c mối quan hệ in real-time. Giải th&iacute;ch: Labeled Property Graph Models: model n&agrave;y sẽ hợp với c&aacute;c system &iacute;t trao đổi hoặc publish data m&agrave; chỉ ch&uacute; trọng đến việc lưu trữ, lưu trữ hiệu quả sẽ cho ph&eacute;p truy vấn nhanh. C&aacute;c node c&oacute; ID duy nhất k&egrave;m theo một tập hợp key-value pair hoặc properties đặc trưng cho ch&uacute;ng. V&agrave; khi ch&uacute;ng ta biết được ID của node th&igrave; ta c&oacute; thể x&aacute;c định chắc chắn node đ&oacute; v&agrave; c&aacute;c gi&aacute; trị k&egrave;m theo- thứ ch&uacute;ng ta cần. V&iacute; dụ về m&ocirc; h&igrave;nh n&agrave;y: alt text Tiếp theo l&agrave; RDF( hay c&ograve;n gọi l&agrave; semantic graph database): model n&agrave;y li&ecirc;n quan nhiều hơn đến trao đổi dữ liệu. Cốt l&otilde;i của RDF l&agrave; kh&aacute;i niệm triple, gồm ba yếu tố đại diện cho hai vertice(đỉnh) được kết nối bởi một edge(cạnh). 3 yếu tố n&agrave;y sẽ mang &yacute; nghĩa: subject-predicate-object (chủ ngữ-vị ngữ- đối tượng). Subject v&agrave; object l&agrave; node. Predicate l&agrave; một edge, đại diện cho mối quan hệ giữa ch&uacute;ng. Node ở đ&acirc;y c&oacute; thể l&agrave; literal value(dạng chữ) hoặc URI, kh&aacute;c với m&ocirc; h&igrave;nh trước l&agrave; c&aacute;c node v&agrave; edge đều kh&ocirc;ng c&oacute; cấu tr&uacute;c b&ecirc;n trong( chứa 1 tập hợp key-value pair). alt text Hơi d&agrave;i d&ograve;ng, nhưng anh em chỉ cần nh&igrave;n v&agrave;o h&igrave;nh tr&ecirc;n v&agrave; &quot;hiểu&quot; l&agrave; ok rồi. N&oacute; đang thể hiện 1 đối tượng Me l&agrave; một Person c&oacute; t&ecirc;n Eric Miller, c&oacute; mail l&agrave; em@w3.org v&agrave; c&oacute; tiltle l&agrave; Dr. M&igrave;nh đ&atilde; giải th&iacute;ch đại kh&aacute;i về cấu tr&uacute;c của model n&agrave;y, giờ sẽ sang t&iacute;nh chất nh&eacute;.! Anh em nếu chỉ biết qua về Graph store th&igrave; sẽ dễ nhầm lẫn với RDBMS. Graph store được thiết kế cho dữ liệu c&oacute; quan hệ, nhưng structure của n&oacute; với RDBMS kh&aacute;c hẳn nhau. RDBMS th&igrave; rất khắt khe, c&oacute; constraints, v&agrave; 1 row c&oacute; thể chứa những foreign key tham chiếu đến c&aacute;c row v&agrave; table kh&aacute;c, khi query để lấy data của ch&uacute;ng ta phải join tất cả c&aacute;c h&agrave;ng trong những table đang retrieve data, rất l&agrave; nặng về t&iacute;nh to&aacute;n. V&igrave; điểm n&agrave;y n&ecirc;n NoSQL d&ugrave; sinh sau đẻ muộn nhưng lại được ch&agrave;o đ&oacute;n nhiệt t&igrave;nh v&igrave; t&iacute;nh đơn giản, flexible của n&oacute;, k&egrave;m theo high performance v&agrave; highly scale-out. Nhưng, lại thiếu s&oacute;t mất khả năng tạo mối quan hệ, mối li&ecirc;n kết giữa c&aacute;c data. Cuối c&ugrave;ng, m&ocirc; h&igrave;nh Graph Store đ&atilde; đ&aacute;p ứng điều đ&oacute;, m&agrave; vẫn giữ được performance tốt, tốt hơn RDBMS. Tại sao m&ocirc; h&igrave;nh Graph Store lại c&oacute; thể truy vấn real-time, nhanh hơn so với RDBMS? L&agrave; v&igrave; Graph Store lưu trữ mối quan hệ tr&ecirc;n từng record ri&ecirc;ng biệt. N&oacute; coi mỗi node, mỗi edge c&oacute; tầm quan trọng như nhau, được kết nối với nhau th&agrave;nh m&ocirc; h&igrave;nh đơn giản, cho ph&eacute;p ta truy cập trực tiếp v&agrave;o node m&agrave; ta muốn m&agrave; kh&ocirc;ng phải thực thi theo kiểu join của RDBMS. Nhưng n&oacute;i đi th&igrave; cũng phải n&oacute;i lại, RDBMS sẽ tốt về lưu trữ trong trường hợp data c&oacute; structure tương đối giống nhau, v&igrave; những column đ&atilde; nằm trong table definition rồi, c&aacute;c row th&ecirc;m v&agrave;o th&igrave; chứa value th&ocirc;i chứ kh&ocirc;ng chứa th&ocirc;ng tin của column nữa, c&ograve;n Graph th&igrave; sẽ lợi hơn trong trường hợp structure giữa c&aacute;c record kh&ocirc;ng cố định, t&ecirc;n column thay đổi. Hết c&aacute;c loại của NoSQL DBMBS rồi nhỉ? Ừ n&atilde;y n&oacute;i c&oacute; 4 loại th&ocirc;i m&agrave;. Giỡn th&ocirc;i, c&ograve;n nh&eacute;, ngo&agrave;i 4 loại ph&iacute;a tr&ecirc;n th&igrave; c&ograve;n một v&agrave;i loại c&oacute; thể kể đến như Search Engine. Search Engine giờ cũng kh&aacute; th&ocirc;ng dụng, l&agrave; một loại NoSQL DBMS chuy&ecirc;n dụng để t&igrave;m kiếm: t&igrave;m kiếm c&oacute; query phức tạp, full-text search, ranking v&agrave; gom nh&oacute;m kết quả t&igrave;m kiếm, geospatial search( vị tr&iacute; địa l&yacute;), thậm ch&iacute; l&agrave; t&igrave;m kiếm kh&ocirc;ng gian như GeoSeer, c&oacute; thể kể đến c&aacute;c DBMS nổi tiếng implement n&oacute; như Elasticsearch, Splunk, Solr. Search Engine kh&ocirc;ng nằm trong 1 trong 4 loại cơ bản của NoSQL DBMS m&agrave; n&oacute; nằm độc lập nha! Hết rồi chứ nhỉ? Ừ Lại giỡn đấy, c&ograve;n 1 &quot;loại&quot; nữa, n&oacute; hơi đặc biệt x&iacute;u, thực chất th&igrave; kh&ocirc;ng t&iacute;nh l&agrave; một loại DB đ&acirc;u, nhưng m&igrave;nh phải n&oacute;i về n&oacute; v&igrave; c&oacute; những l&uacute;c chọn DBMS anh em c&oacute; thể đau đầu v&igrave; c&ugrave;ng l&uacute;c muốn lợi &iacute;ch, t&iacute;nh năng của 2 3 m&ocirc; h&igrave;nh kể tr&ecirc;n chẳng hạn, th&igrave; anh em c&oacute; thể lựa chọn một trong những DBMS b&ecirc;n dưới. Multi-Model: Amazon DynamoDB: sử dụng 2 m&ocirc; h&igrave;nh l&agrave; Document store v&agrave; Key-value store. OrientDB: sử dụng 3 m&ocirc; h&igrave;nh l&agrave; Document store, Key-value store, Graph store. Microsoft Azure Cosmos DB: sử dụng cả 4 m&ocirc; h&igrave;nh tr&ecirc;n. M&igrave;nh cho c&aacute;i h&igrave;nh để anh em xem c&oacute; khớp với kiến thức n&atilde;y giờ kh&ocirc;ng nha: alt text Kết b&agrave;i: Đ&acirc;y l&agrave; part 1 của series Hiểu v&agrave; chọn database trong NoSQL DBMS. M&igrave;nh chỉ chia sẻ những kiến thức hạn hẹp m&agrave; m&igrave;nh hiểu, nhưng vẫn hy vọng b&agrave;i đọc n&agrave;y sẽ gi&uacute;p &iacute;ch cho anh em. Nếu c&oacute; g&igrave; bổ sung, g&oacute;p &yacute; th&igrave; anh em comment chỉ gi&uacute;p m&igrave;nh nh&eacute;. Hẹn gặp lại anh em trong Part 2 - CAP theorem- Sự thật v&agrave; ứng dụng. Ch&uacute;c anh em một buổi tối tốt l&agrave;nh!</p>\n",
      "total_views": 67,
      "status": true,
      "tags": [
        "Database", "NoSQL"
      ]
    },
    {
      "title": "Hiểu và chọn database trong NoSQL DBMS [Part2] - CAP theorem - sự thật và ứng dụng",
      "content": "<p>Ch&agrave;o anh em! Part 1 của Hiểu v&agrave; chọn database trong NoSQL DBMS m&igrave;nh đ&atilde; ph&acirc;n t&iacute;ch về c&aacute;c loại NoSQL DBMS, part 2 n&agrave;y m&igrave;nh sẽ đi đến CAP theorem(định l&yacute; CAP) - định l&yacute; m&agrave; người ta hay nhắc tới khi n&oacute;i về NoSQL DBMS. Sự thật l&agrave; định l&yacute; CAP gắn liền với c&aacute;c distributed system (hệ thống ph&acirc;n t&aacute;n), distributed data store(lưu trữ dữ liệu ph&acirc;n t&aacute;n). :flushed: Ủa m&igrave;nh hay nghe NoSQL DBMS gắn liền với định l&yacute; n&agrave;y m&agrave;, li&ecirc;n quan g&igrave; đến distributed system ở đ&acirc;y? L&yacute; do l&agrave;: NoSQL DBMS x&acirc;y dựng theo chiều ngang, nghĩa l&agrave; database sẽ chứa c&aacute;c replica v&agrave; bản th&acirc;n database cũng d&agrave;n trải ra nhiều mảnh (horizontal partition), tương tự như distributed system. M&igrave;nh sẽ c&oacute; một b&agrave;i n&oacute;i về cấu tr&uacute;c của NoSQL DBMS để anh em hiểu r&otilde; hơn. Quay trở lại b&agrave;i n&agrave;y, trước ti&ecirc;n, anh em n&ecirc;n biết 1 x&iacute;u về replication cũng như distributed system ở đ&acirc;y để dễ d&agrave;ng hiểu được phần m&igrave;nh sắp n&oacute;i nha! alt text 3 guarantee Consistency C&ograve;n c&oacute; thể coi l&agrave; linearizability. L&agrave; trạng th&aacute;i m&agrave; mọi data tr&ecirc;n c&aacute;c node đều đồng nhất với nhau. Mỗi node ở đ&acirc;y anh em hiểu l&agrave; 1 slave nh&eacute;. V&iacute; dụ như h&igrave;nh dưới. alt text Ở một thời điểm, trận b&oacute;ng đ&aacute; giữa Germany v&agrave; Argentina đ&atilde; kết th&uacute;c với tỉ số 1-0 nghi&ecirc;ng về Germany. Khi n&agrave;y Referee thực hiện một c&acirc;u lệnh insert kết quả trận b&oacute;ng n&agrave;y v&agrave;o databse. Sau khi đ&atilde; insert th&agrave;nh c&ocirc;ng v&agrave;o Master th&igrave; c&aacute;c slave cũng thay đổi theo. Nhưng c&aacute;c slave kh&ocirc;ng phải cập nhật th&agrave;nh c&ocirc;ng tại một thời điểm m&agrave; sẽ ch&ecirc;nh nhau một thời gian. Việc n&agrave;y tuỳ v&agrave;o latency của network, bandwith của network v&agrave; data transfer, số lượng message tr&ecirc;n queue, hoặc số lượng thread, lẫn c&aacute;c cấu h&igrave;nh kh&aacute;c của c&aacute;c slave. Dẫn đến tại một thời điểm Slave 1 đ&atilde; cập nhật được data rồi, nhưng Slave 2 th&igrave; chưa. V&ocirc; t&igrave;nh Alice v&agrave; Bob request đến 2 slave n&agrave;y v&agrave; nhận được kết quả kh&aacute;c nhau. Hậu quả th&igrave; tuỳ hệ thống v&agrave; business, trong trường hợp n&agrave;y sẽ kh&ocirc;ng nghi&ecirc;m trọng lắm, delay một ch&uacute;t cũng kh&ocirc;ng sao. Trước m&igrave;nh coi trực tiếp b&oacute;ng đ&aacute; trong ph&ograve;ng, C&ocirc;ng Phượng mới r&ecirc; b&oacute;ng l&ecirc;n giữa s&acirc;n m&agrave; đ&atilde; nghe tiếng h&ograve; reo h&uacute; h&uacute; từ qu&aacute;n nhậu vọng v&agrave;o mới đau k&igrave;a, ch&ecirc;nh 30s chứ chả chơi (quả n&agrave;y đi ngủ chứ b&oacute;ng banh g&igrave; nữa :unamused:). Nhưng, thử tưởng tượng 1 trường hợp th&uacute; vị x&iacute;u: Alice v&agrave; Bob l&agrave; bạn của nhau :laughing: th&igrave; Alice sẽ th&ocirc;ng b&aacute;o ngay cho Bod l&agrave; &quot;Germany thắng rồi ku ơi&quot;, Bob kiểm tra (l&uacute;c n&agrave;y balancer điều hướng request v&agrave;o Slave 2- bấy giờ chưa c&oacute; data mới) th&igrave; thấy trận đấu chưa kết th&uacute;c v&igrave; server sẽ n&oacute;i l&agrave; chưa c&oacute; final score. 2 anh bạn n&agrave;y sẽ c&oacute; thắc mắc ngay! Nếu bạn l&agrave; Bob th&igrave; sẽ l&agrave;m g&igrave;? Lặng lẽ check lại th&ecirc;m lần nữa v&agrave; thấy đ&uacute;ng l&agrave; Germany thắng thật, rồi kết luận &quot;Chắc n&atilde;y mạng của m&igrave;nh bị g&igrave; đấy!:confused:&quot; (cũng may l&agrave; Bob nghĩ do mạng, chứ n&oacute;i do hệ thống của m&igrave;nh th&igrave; m&eacute;o mồm:anger:) Ta c&oacute;: Tại thời điểm m&agrave; 2 database đưa ra 2 kết quả kh&aacute;c nhau, kh&ocirc;ng đồng nhất với nhau th&igrave; hệ thống kh&ocirc;ng thoả m&atilde;n t&iacute;nh consistency (C) trong định l&yacute; CAP. Availability Mỗi client đều nhận được phản hồi, bất kể c&oacute; một số node n&agrave;o đ&oacute; trong hệ thống c&oacute; vấn đề. V&iacute; dụ như hệ thống m&igrave;nh c&oacute; 3 replica m&agrave; 1 replica c&oacute; vấn đề th&igrave; khi 1 client gửi request tới server th&igrave; vẫn c&oacute; phản hồi , v&igrave; vẫn c&ograve;n c&aacute;c replica database kh&aacute;c handle cho m&igrave;nh. Đ&acirc;y cũng l&agrave; một trong những mục ti&ecirc;u, lợi &iacute;ch lớn nhất của replication. Partition tolerance Hệ thống vẫn tiếp tục hoạt động (read/ write), ngay cả khi một số node trong hệ thống c&oacute; vấn đề. V&iacute; dụ như hệ thống m&igrave;nh c&oacute; 3 replica. C&oacute; 1 replica bị lỗi đường truyền network, kh&ocirc;ng thể giao tiếp với replica kh&aacute;c, nhưng n&oacute; vẫn c&oacute; thể read/write b&igrave;nh thường v&agrave; c&aacute;c replica c&ograve;n lại cũng vậy. C&ograve;n trường hợp node n&agrave;y c&oacute; lỗi, c&oacute; thể l&agrave; database server bị sập hoặc đang reset, bị vấn đề về hardware, bug của application, d&iacute;nh virus hay c&oacute; thể hết dung lượng disk th&igrave; node n&agrave;y ngừng hoạt động, nhưng c&aacute;c node kh&aacute;c vẫn hoạt động v&agrave; to&agrave;n bộ hệ thống cũng vẫn hoạt động. Chỉ sở hữu 2 tr&ecirc;n 3 guarantee Hẳn l&agrave; anh em cũng biết l&agrave; với nguy&ecirc;n l&yacute; CAP theorem m&igrave;nh chỉ c&oacute; được 2 tr&ecirc;n 3 t&iacute;nh chất. Nhưng kh&ocirc;ng c&oacute; c&aacute;ch n&agrave;o c&oacute; cả 3 hả? Để xem! Đầu ti&ecirc;n giả sử ta chọn P đi. Vậy l&agrave; hệ thống của ta c&oacute; nhiều node, khi một node kh&ocirc;ng giao tiếp được th&igrave; node kh&aacute;c vẫn x&agrave;i được n&ecirc;n hệ thống vẫn hoạt động được. Tiếp theo chọn A đi! OK, khi một node c&oacute; vấn đề, th&igrave; hệ thống m&igrave;nh vẫn response data cho client được m&agrave;, đ&uacute;ng chứ? Vậy giờ ta c&oacute; AP. Tiếp, muốn c&oacute; C! Khi một node c&oacute; vấn đề như kh&ocirc;ng giao tiếp được với c&aacute;c node kh&aacute;c, nhưng vẫn hoạt động read/write b&igrave;nh thường, th&igrave; data giữa c&aacute;c node kh&ocirc;ng consistent. L&agrave;m sao m&agrave; consistent được khi m&agrave; kh&ocirc;ng giao tiếp với nhau được chứ, c&oacute; truyền nhận data mới của nhau đ&acirc;u! Vậy l&agrave; ta kh&ocirc;ng c&oacute; được CAP. Trở lại, ta c&oacute; C, tiếp theo ta chọn A hoặc P: Chọn P: khi một node kh&ocirc;ng giao tiếp được với node kh&aacute;c, nhưng ta vẫn muốn data tr&ecirc;n tất cả c&aacute;c node consistent để thoả m&atilde;n C th&igrave; chỉ c&oacute; c&aacute;ch l&agrave; tạm ngưng read/write tr&ecirc;n to&agrave;n hệ thống th&ocirc;i. Chứ giờ m&agrave; ghi data mới v&agrave;o th&igrave; sẽ kh&ocirc;ng consistent ngay! Vậy ta c&oacute; được CP, nhưng nếu l&agrave;m vậy th&igrave; hệ thống sẽ kh&ocirc;ng available (A). Vậy ta chỉ c&oacute; CP. C&ograve;n nếu vẫn muốn C th&igrave; hệ thống của ch&uacute;ng ta chỉ c&oacute; 1 node th&ocirc;i. L&uacute;c n&agrave;y t&iacute;nh availablity (A) sẽ thể hiện! Nhưng l&uacute;c n&agrave;y, hệ thống của ch&uacute;ng ta chỉ c&oacute; 1 node, lại kh&ocirc;ng thoả m&atilde;n P. Vậy ta chỉ c&oacute; CA. Vậy l&agrave; ta kh&ocirc;ng thể c&oacute; thoả m&atilde;n cả 3 t&iacute;nh chất của CAP theorem tr&ecirc;n 1 hệ thống. Trừ khi CAP theorem thay đổi, hoặc ta hiểu CAP theorem theo một c&aacute;ch kh&aacute;c :laughing:. Discuss về CAP theorem 1. Consistency a) So s&aacute;nh với Consistentcy trong ACID properties Consistency trong CAP theorem c&oacute; giống consistency trong ACID properties kh&ocirc;ng? Kh&ocirc;ng, ho&agrave;n to&agrave;n kh&ocirc;ng. Trong CAP theorem th&igrave; mọi node phải đảm bảo data consistent, c&ograve;n trong ACID properties th&igrave; khi một transaction ho&agrave;n th&agrave;nh, data trong hệ thống phải nhất qu&aacute;n so với trạng th&aacute;i trước khi transaction n&agrave;y thực thi, giữ được t&iacute;nh ch&iacute;nh x&aacute;c. b) Consistency trong CAP theorem c&oacute; phải l&agrave; 100% thời gian, l&uacute;c n&agrave;o c&aacute;c node cũng phải consistent kh&ocirc;ng? Kh&ocirc;ng, thay v&agrave;o đ&oacute;, ta ngầm hiểu l&agrave; Eventual consistency. Anh em c&oacute; thể kiểm tra lại, CAP theorem kh&ocirc;ng c&oacute; một từ n&agrave;o n&oacute;i về độ trễ. Cũng v&igrave; vậy, c&aacute;c CAP-availibility system c&oacute; thể response chậm t&ugrave;y &yacute; v&agrave; vẫn c&oacute; thể được gọi l&agrave; availability. Tuy nhi&ecirc;n, đ&oacute; l&agrave; nguy&ecirc;n l&yacute;, c&ograve;n ch&uacute;ng ta khi v&agrave;o 1 trang web m&agrave; 1 2 ph&uacute;t để tải trang th&igrave; ch&uacute;ng ta c&oacute; gọi l&agrave; &quot;available&quot; kh&ocirc;ng nhỉ :relieved: 2. CAP theorem v&agrave; ACID properties Nhắc đến 2 kh&aacute;i niệm n&agrave;y th&igrave; nhiều người sẽ n&oacute;i ngay: NoSQL DBMS gắn liền với CAP theorem, c&ograve;n RDBMS gắn liền với ACID properties. Anh em c&oacute; thể thấy những so s&aacute;nh như vậy c&oacute; rất nhiều tr&ecirc;n mạng. Nhưng cần phải biết, thực ra, CAP theorem đi liền với distributed system, c&ograve;n ACID properties gắn với transaction. NoSQL DBMS c&oacute; structure như distributed system n&ecirc;n mới gắn liền CAP theorem. C&ograve;n RDBMS th&igrave; rất mạnh về transaction, mọi RDBMS đều c&oacute; support transaction n&ecirc;n RDBMS mới gắn liền với ACID proerties như vậy. N&ecirc;n nhớ, ACID properties l&agrave; d&agrave;nh cho database transaction, kh&ocirc;ng phải d&agrave;nh cho RDBMS! Vậy NoSQL DBMS c&oacute; thể c&oacute; ACID properties kh&ocirc;ng? Một c&acirc;u hỏi nghe hơi ngớ ngẩn. Nhưng ta c&oacute; thể trả lời l&agrave;: với những NoSQL DBMS n&agrave;o c&oacute; hỗ trợ transaction. V&iacute; dụ như Neo4j, MongoDB.. 3. Sự đ&aacute;nh đổi Anh em nh&igrave;n lại h&igrave;nh CAP ph&iacute;a tr&ecirc;n nh&eacute;! Như đ&atilde; biết ta chỉ c&oacute; thể chọn 2 tr&ecirc;n 3 sự guarantee trong CAP theorem. Partition tolerance th&igrave; ta sẽ chọn, như ph&acirc;n t&iacute;ch hồi n&atilde;y của m&igrave;nh, nếu kh&ocirc;ng chọn Partition tolerance th&igrave; hệ thống của ta chẳng c&ograve;n l&agrave; distributed system nữa, m&agrave; gần như l&agrave; anh em đang chọn RDBMS rồi c&ograve;n g&igrave;:joy:. Phải xem x&eacute;t hệ thống của ch&uacute;ng ta cần Availablity hơn Consistency hay l&agrave; Consistency hơn Availability. V&agrave; k&egrave;m theo đ&oacute;, khi rơi v&agrave;o trường hợp rủi ro, ta sẽ c&oacute; c&aacute;ch handle như n&agrave;o để hạn chế t&aacute;c hại. Ngay cả Google, Facebook , hay Amazon cũng chỉ c&oacute; thể chọn 2/3 m&agrave; th&ocirc;i. Spanner của Google chọn hướng CP. Thời gian ngừng hoạt động l&agrave; 5,26 ph&uacute;t mỗi năm. HBase của Facebook chọn CP. Thời gian ngừng hoạt động lớn hơn một ch&uacute;t so với Google. Google v&agrave; Facebook chọn Consistency tr&ecirc;n Availibility, theo quan điểm &quot;D&ugrave; c&oacute; theo trường ph&aacute;i Avaibility th&igrave; cũng kh&ocirc;ng available 100% thời gian được, n&ecirc;n theo Consistency lu&ocirc;n!&quot; DynamoDB của Amazon chọn AP. Amazon muốn sở hữu Availibility, n&ecirc;n chấp nhận Consistency bị yếu, ấy m&agrave; Amazon vẫn n&oacute;i DynamoDB của họ l&agrave; strong consistency. V&igrave; họ đ&atilde; handle một số c&aacute;ch để l&agrave;m giải quyết bớt vấn đề n&agrave;y như vector clock v&agrave; calling application. 4. Sự thật về CAP C&oacute; l&uacute;c n&agrave;o anh em nh&igrave;n v&agrave;o định nghĩa của CAP theorem v&agrave; rồi cứ nhầm lẫn giữa Avaibility v&agrave; Partition tolerance kh&ocirc;ng? Thực tế, Availibility v&agrave; Partition tolerance kh&ocirc;ng thực sự t&aacute;ch biệt 100%, m&agrave; dẫm ch&acirc;n l&ecirc;n nhau. Trước giờ cũng đ&atilde; c&oacute; nhiều sự tranh luận về CAP theorem, cho rằng n&oacute; kh&ocirc;ng đ&uacute;ng. Thậm ch&iacute; một số cho rằng n&ecirc;n thay bằng PIE theorem. Rốt cuộc, kh&ocirc;ng n&ecirc;n tập trung qu&aacute; nhiều v&agrave;o định l&yacute; CAP. N&oacute; vẫn đ&uacute;ng, nhưng định l&yacute; th&igrave; cũng chỉ l&agrave; định l&yacute; m&agrave; th&ocirc;i. Ta cứ chăm chăm v&agrave;o định l&yacute; n&agrave;y m&agrave; dẫn đến việc bỏ qua c&aacute;c vấn đề quan trọng kh&aacute;c th&igrave; sẽ fail ngay. N&ecirc;n xem x&eacute;t rộng ra để c&oacute; những đ&aacute;nh đổi v&agrave; giải ph&aacute;p ph&ugrave; hợp. You shouldn&rsquo;t really care about the CAP theorem. C&acirc;u n&agrave;y của 1 b&aacute;c kỹ sư Google. M&igrave;nh th&igrave; kh&ocirc;ng chủ &yacute; như vậy đ&acirc;u, bỏ th&igrave; kh&ocirc;ng bỏ ho&agrave;n to&agrave;n, nhưng đừng tập trung qu&aacute;, sẽ bị lỗi lầm m&agrave; m&igrave;nh đ&atilde; ph&acirc;n t&iacute;ch ở tr&ecirc;n. Tổng kết về series Part 1 m&igrave;nh đ&atilde; n&oacute;i về c&aacute;ch hoạt động của c&aacute;c loại NoSQL DBMS, part 2 n&agrave;y m&igrave;nh n&oacute;i về c&aacute;ch xử l&yacute; của c&aacute;c NoSQL DBMS dựa tr&ecirc;n CAP theorem (c&oacute; thể xem lại h&igrave;nh của CAP theorem ở đầu b&agrave;i viết để thấy 1 DBMS m&igrave;nh quan t&acirc;m thuộc kiểu, sẽ biết được c&aacute;c trường hợp xử l&yacute; của DBMS đ&oacute; nha). Hi vọng anh em c&oacute; c&aacute;i nh&igrave;n tổng quan về mọi NoSQL DBMS, cũng như c&oacute; c&aacute;i nh&igrave;n s&acirc;u sắc về hệ thống database m&agrave; anh em đang l&agrave;m việc. Xa hơn, nếu chọn database th&igrave; anh em phải xem x&eacute;t nhiều vấn đề: Business của cả hệ thống sẽ như thế n&agrave;o? Sẽ c&oacute; thể c&oacute; những trường hợp &quot;kh&oacute; nhằn&quot; n&agrave;o xảy ra? Tuỳ business m&agrave; sẽ c&oacute; những y&ecirc;u cầu thiết yếu ri&ecirc;ng, c&oacute; khi th&igrave; đ&ograve;i hỏi về consistency, c&oacute; khi lại l&agrave; availability, c&oacute; khi lại l&agrave; performance,.. th&igrave; ta sẽ dựa tr&ecirc;n đ&oacute; để chọn m&ocirc; h&igrave;nh v&agrave; kiểu CAP-A hay CAP-C cho ph&ugrave; hợp. V&agrave; cũng phải đặt c&acirc;u hỏi l&agrave; trong tương lai, hệ thống sẽ thay đổi theo những t&igrave;nh huống n&agrave;o, th&igrave; DBMS của ch&uacute;ng ta c&oacute; ph&ugrave; hợp kh&ocirc;ng? C&oacute; nhiều kh&aacute;ch h&agrave;ng, nhiều data hơn, th&igrave; l&uacute;c đ&oacute; DBMS m&igrave;nh sẽ support scaling ổn kh&ocirc;ng? Tr&ecirc;n thực tế (l&agrave; ở production) th&igrave; c&aacute;i hệ thống của m&igrave;nh sẽ như thế n&agrave;o? Server của ch&uacute;ng ta sẽ đ&ograve;i hỏi cấu h&igrave;nh như thế n&agrave;o lẫn budget bỏ ra? Hệ thống m&igrave;nh sẽ build ở đ&acirc;u, tr&ecirc;n to&agrave;n thế giới hay ở một địa phương, để tưởng tượng architecture của hệ thống. Tiếp theo, budget c&oacute; cho ph&eacute;p ch&uacute;ng ta sở hữu những server c&oacute; cấu h&igrave;nh mạnh mẽ kh&ocirc;ng? Điều n&agrave;y lại ảnh hưởng đến DBMS m&agrave; ch&uacute;ng ta chọn. DBMS l&agrave; Open-source hay Proprietary? Điều n&agrave;y li&ecirc;n quan tới chi ph&iacute; phải trả cho licenses lẫn mức độ tin cậy v&agrave; mức độ support tận răng của DBMS. DBMS y&ecirc;u cầu Server OS như n&agrave;o? V&iacute; dụ như c&oacute; một số DBMS chỉ x&agrave;i được tr&ecirc;n Windows chứ kh&ocirc;ng x&agrave;i được tr&ecirc;n Linux, rồi một số lại đ&ograve;i hỏi c&agrave;i middleware hay platform ri&ecirc;ng, th&igrave; ta phải để &yacute; xem c&oacute; conflict hay kh&oacute; khăn kh&aacute;c kh&ocirc;ng ha. DBMS hỗ trợ những programming language n&agrave;o? V&iacute; dụ anh em l&agrave;m dự &aacute;n c&oacute; ng&ocirc;n ngữ C# m&agrave; c&aacute;i DBMS anh em chọn chỉ support C++ v&agrave; Go th&igrave; kh&oacute; nhằn đấy. Vẫn c&oacute; những library bind API giữa C# với C++ cho m&igrave;nh, nhưng cần phải xem x&eacute;t kỹ lưỡng v&igrave; thường th&igrave; những library n&agrave;y l&agrave; open-source, chưa biết nay mai c&oacute; chuyện g&igrave; xảy ra, v&iacute; dụ c&oacute; những API m&agrave; DBMS thay đổi hoặc th&ecirc;m mới những chắc g&igrave; library đ&atilde; hỗ trợ kịp thời? Trang web n&agrave;o để tham khảo? Trang DB Engine nha anh em, trang n&agrave;y cũng cho biết required server OS v&agrave; c&aacute;c lisences cho ph&eacute;p... Rất trực quan v&agrave; kh&aacute; đầy đủ! C&ograve;n nhiều nữa, nhưng tạm thời m&igrave;nh chỉ liệt k&ecirc; những điều m&agrave; m&igrave;nh thấy đ&aacute;ng được quan t&acirc;m nhất ở tr&ecirc;n đ&acirc;y. Tr&ecirc;n hết, ta phải x&aacute;c định hệ thống của ch&uacute;ng ta thực sự cần g&igrave; v&agrave; điều kiện cho ph&eacute;p, để c&oacute; thể quyết định, đưa ra những sự đ&aacute;nh đổi đ&uacute;ng đắn. Kết b&agrave;i M&igrave;nh dừng series n&agrave;y tại đ&acirc;y. Hi vọng series n&agrave;y sẽ gi&uacute;p anh em hiểu s&acirc;u hơn v&agrave; c&oacute; những c&aacute;i nh&igrave;n đa chiều về NoSQL DBMS! C&oacute; thiếu s&oacute;t g&igrave; th&igrave; anh em comment để gi&uacute;p m&igrave;nh ho&agrave;n thiện n&oacute; nh&eacute;! Th&acirc;n &aacute;i, v&agrave; hẹn gặp lại!</p>\n",
      "total_views": 153,
      "status": true,
      "tags": [
        "Database", "NoSQL"
      ]
    },
    {
      "title": "Sự tiến hóa của Javascript và các công cụ hỗ trợ ở Frontend",
      "content": "<p>Ra đời với mục đ&iacute;ch l&agrave; một ng&ocirc;n ngữ sẽ được thực thi ở browsers ph&iacute;a client-side, trong qu&aacute; tr&igrave;nh ph&aacute;t triển hơn 20 năm, Javascript đ&atilde; c&oacute; một bước tiến thần k&igrave; khi giờ đ&acirc;y n&oacute; được d&ugrave;ng cả trong việc x&acirc;y dựng c&aacute;c xử l&iacute; ở ph&iacute;a server th&ocirc;ng qua Node.js nữa. Tuy nhi&ecirc;n, việc bi&ecirc;n dịch được m&atilde; Javascript ở ph&iacute;a server-side l&agrave; một c&acirc;u chuyện ho&agrave;n to&agrave;n kh&aacute;c. Trong b&agrave;i n&agrave;y, ch&uacute;ng ta sẽ tập trung v&agrave;o qu&aacute; tr&igrave;nh ph&aacute;t triển của Javascript dưới vai tr&ograve; l&agrave; một ng&ocirc;n ngữ được thực thi ở ph&iacute;a client-side (tr&ecirc;n c&aacute;c browsers), c&aacute;ch m&agrave; n&oacute; đ&atilde; tiến h&oacute;a để khiến c&aacute;c lập tr&igrave;nh ph&iacute;a front-end đau đầu như thế n&agrave;o. alt text Nguồn ảnh: Here Nếu đ&atilde; từng l&agrave;m việc với Javascript ở c&aacute;i thời m&agrave; web c&ograve;n sơ khai, bạn sẽ thấy c&aacute;ch để &aacute;p dụng Javascript v&agrave;o hệ thống web của bạn kh&aacute; đơn giản: việc bạn cần l&agrave;m l&agrave; tạo một file javascript c&oacute; phần mở rộng l&agrave; *.js v&agrave; load v&agrave;o html th&ocirc;ng qua tag</p>\n\n<h1>Hello HTML world!</h1>\n\n<p>Đoạn m&atilde; đ&oacute;ng vai tr&ograve; load một file javascript ở thư mục c&ugrave;ng cấp với file html v&agrave; thực thi n&oacute; ở tr&ecirc;n browser khi trang web được load. Đ&acirc;y l&agrave; tất cả những g&igrave; ta cần phải l&agrave;m để sử dụng được javascript b&ecirc;n trong trang web, rất đơn giản v&agrave; trực quan phải kh&ocirc;ng n&agrave;o. H&atilde;y đi tới bước kế tiếp, ta cần thao t&aacute;c với một v&agrave;i dữ liệu dạng mảng trong javascript, những h&agrave;m c&oacute; sẵn th&igrave; kh&ocirc;ng đủ hữu dụng n&ecirc;n ta đ&agrave;nh sử dụng th&ecirc;m một thư viện b&ecirc;n ngo&agrave;i l&agrave; lodash để hỗ trợ. Thư viện lodash cung cấp một số c&ocirc;ng cụ hữu &iacute;ch như so s&aacute;nh 2 mảng chẳng hạn (trong javascript thuần kh&ocirc;ng c&oacute; h&agrave;m n&agrave;y): var array = [&#39;hello&#39;, &#39;goodbye&#39;]; var others = [&#39;hello&#39;, &#39;goodbye&#39;]; array == others; // javascript thuần &rarr; false _.isEqual(array, others); // d&ugrave;ng lodash &rarr; true C&acirc;u hỏi đặt ra l&agrave;: v&igrave; lodash l&agrave; một thư viện javascript được cung cấp bởi b&ecirc;n thứ 3, l&agrave;m thế n&agrave;o để th&ecirc;m lodash v&agrave;o trang web của bạn? H&atilde;y đi tới trang chủ của lodash v&agrave; xem hướng dẫn: alt text Với hướng dẫn n&agrave;y, ta thấy c&ocirc;ng việc phải l&agrave;m cũng kh&aacute; l&agrave; đơn giản: tải file lodash.js về m&aacute;y v&agrave; đặt trong thư mục source, sau đ&oacute; d&ugrave;ng tag</p>\n\n<h1>Hello HTML world!</h1>\n\n<p>Như vậy l&agrave; ta đ&atilde; c&oacute; thể d&ugrave;ng lodash thoải m&aacute;i trong file index.js rồi: //index.js _.trunc(&#39;hi-diddly-ho there, neighborino&#39;, 24); // &rarr; &#39;hi-diddly-ho there, n&hellip;&#39; Thật dễ d&agrave;ng phải kh&ocirc;ng n&agrave;o! Chỉ c&oacute; một lưu &yacute; l&agrave;: để sử dụng được lodash trong file index.js, ta cần phải d&ugrave;ng tag</p>\n\n<h1>Hello HTML world!</h1>\n\n<p>Như vậy c&oacute; thể thấy rằng, mặc d&ugrave; npm đ&atilde; gi&uacute;p ta trong việc quản l&iacute; v&agrave; download tự động c&aacute;c thư viện, vấn đề về &ldquo;load thư viện l&ecirc;n html&rdquo; vẫn c&ograve;n rất nhi&ecirc;u kh&ecirc; khi ta phải đi s&acirc;u v&agrave;o trong thư mục node_modules để t&igrave;m ra ch&iacute;nh x&aacute;c đường dẫn của thư viện. Đ&acirc;y l&agrave; một trong những điểm chưa tốt m&agrave; ta sẽ t&igrave;m c&aacute;ch cải thiện n&oacute;. Nhắc lại vấn đề import modules trong javascript v&agrave; sự cải tiến của nodejs Nhắc lại một ch&uacute;t về t&iacute;nh năng của ng&ocirc;n ngữ, những ng&ocirc;n ngữ lập tr&igrave;nh kh&aacute;c ở ph&iacute;a Server-side, t&iacute;nh năng import sourcecode từ một file n&agrave;y đến một file kh&aacute;c l&agrave; một t&iacute;nh năng đ&atilde; c&oacute; từ rất l&acirc;u rồi, lấy v&iacute; dụ với PHP, bạn c&oacute; thể sử dụng t&iacute;nh năng n&agrave;y qua h&agrave;m include hoặc include_once như sau: //DBConnection.php class DBConnection { // class body here } //index.php //Để sử dụng lớp DBConnection ta cần include ch&uacute;ng include &quot;DBConnection.php&quot; $db_connection = new DBConnection(); ... Thế nhưng với Javascript ở c&aacute;c phi&ecirc;n bản từ ES5 trở về trước, t&iacute;nh năng n&agrave;y kh&ocirc;ng hề tồn tại, c&oacute; thể v&igrave; ban đầu Javascript được thiết kế để chạy ở client-side. Điều n&agrave;y dẫn tới việc nếu bạn muốn sử dụng source code được viết ở một file n&agrave;o đ&oacute;, bạn cần phải load n&oacute; v&agrave;o html trước th&ocirc;ng qua tag</p>\n\n<h1>Hello HTML world!</h1>\n\n<p>Bạn thấy đ&oacute;, giờ ta chỉ cần load đ&uacute;ng file javascript cần sử dụng, c&aacute;c thư viện b&ecirc;n ngo&agrave;i m&agrave; ta cần d&ugrave;ng đều đ&atilde; được đ&oacute;ng g&oacute;i sẵn v&agrave;o file index_bundle.js rồi. Sau n&agrave;y, nếu c&oacute; phải sử dụng th&ecirc;m nhiều thư viện hơn nữa, ta chỉ cần tải ch&uacute;ng về th&ocirc;ng qua npm, d&ugrave;ng require trong file index.js để khai b&aacute;o sử dụng thư viện, v&agrave; cuối c&ugrave;ng l&agrave; d&ugrave;ng webpack đ&oacute;ng g&oacute;i lại th&agrave;nh một file javascript cuối c&ugrave;ng để sử dụng ở browser. Việc file index.html ở ph&iacute;a browser chỉ cần load 1 file duy nhất vừa gi&uacute;p cho việc quản l&iacute; source code dễ d&agrave;ng, vừa gi&uacute;p ta cải thiện được performance cho trang web nữa. Minh họa ở tr&ecirc;n chỉ v&iacute; dụ g&oacute;i gọn trong 1 file javascript cần đ&oacute;ng g&oacute;i (l&agrave; file index.js), sau n&agrave;y nếu c&oacute; nhiều file cần đ&oacute;ng g&oacute;i hơn, bạn c&oacute; thể cấu h&igrave;nh webpack th&ocirc;ng qua file webpack.config.js, bạn c&oacute; thể t&igrave;m hiểu chi tiết về n&oacute; ở tr&ecirc;n trang chủ của webpack nh&eacute;. Chức năng biến đổi ng&ocirc;n ngữ (transpile) trong javascript Cho đến l&uacute;c n&agrave;y, mọi chuyện c&oacute; vẻ đ&atilde; kh&aacute; đầy đủ để bạn c&oacute; thể bắt đầu l&agrave;m việc với javascript hiện đại. Tuy nhi&ecirc;n, trong thực tế lại ph&aacute;t sinh th&ecirc;m một vấn đề nữa: bản th&acirc;n javascript c&oacute; rất nhiều c&aacute;c phi&ecirc;n bản kh&aacute;c nhau (ES5, ES6, Typescript, &hellip;) v&agrave; c&aacute;c tr&igrave;nh duyệt ng&agrave;y nay kh&ocirc;ng phải c&aacute;i n&agrave;o cũng hỗ trợ hết tất cả, đ&oacute; l&agrave; chưa n&oacute;i tới vấn đề người d&ugrave;ng đang sử dụng c&aacute;c browser phi&ecirc;n bản cũ. Nếu như bạn lập tr&igrave;nh bằng c&uacute; ph&aacute;p của ES6, hoặc Typescript (bạn c&oacute; thể hiểu đơn giản Typescript l&agrave; javascript phi&ecirc;n bản đ&atilde; mở rộng t&iacute;nh năng), nhiều khả năng l&agrave; t&iacute;nh tương th&iacute;ch với tr&igrave;nh duyệt của người d&ugrave;ng l&agrave; kh&ocirc;ng cao. Từ đ&acirc;y ph&aacute;t sinh b&agrave;i to&aacute;n: ta cần chuyển đổi những m&atilde; nguồn javascript theo c&aacute;c chuẩn hiện đại về c&aacute;c dạng javascript phi&ecirc;n bản cũ hơn để hỗ trợ cho những phi&ecirc;n bản browser cũ hơn của người d&ugrave;ng. Babel xuất hiện như l&agrave; một c&ocirc;ng cụ gi&uacute;p ta thực hiện điều n&agrave;y. Để th&ecirc;m babel v&agrave;o project, ta sẽ c&agrave;i đặt n&oacute; th&ocirc;ng qua npm như sau: npm install --save-dev @babel/core @babel/preset-env babel-loader Với lệnh n&agrave;y, ch&uacute;ng ta đ&atilde; th&ecirc;m 3 packages ch&iacute;nh l&agrave;: @babel/core: phần core của babel @babel/preset-env: phần định nghĩa c&aacute;c t&iacute;nh năng javascript c&oacute; thể chuyển đổi babel-loader: l&agrave; phần gi&uacute;p ta t&iacute;ch hợp babel v&agrave;o webpack Để t&iacute;ch hợp babel với webpack, ta sẽ cần sử dụng webpack.config.js, khi đ&oacute; cấu h&igrave;nh của ta sẽ c&oacute; dạng như sau: module.exports = { module: { rules: [ { test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: { loader: &#39;babel-loader&#39;, options: { presets: [&#39;@babel/preset-env&#39;] } } } ] } }; Với cấu h&igrave;nh n&agrave;y, ta đ&atilde; chỉ định việc webpack sẽ sử dụng babel-loader v&agrave; preset l&agrave; @babel/preset-env để c&oacute; thể d&ugrave;ng babel biến đổi c&aacute;c file code theo c&uacute; ph&aacute;p ES6 về c&aacute;c dạng c&uacute; ph&aacute;p thấp hơn nhằm tăng t&iacute;nh tương th&iacute;ch với tr&igrave;nh duyệt. Bạn c&oacute; thể c&agrave;i đặt th&ecirc;m nhiều c&aacute;c presets kh&aacute;c trong trường hợp bạn d&ugrave;ng nhiều hơn c&uacute; ph&aacute;p của ES6 (vd: Typescript, React, sử dụng async/await, &hellip;) Nh&igrave;n chung, mặc d&ugrave; cần phải cấu h&igrave;nh phức tạp l&agrave; thế, mục đ&iacute;nh ch&iacute;nh của ta vẫn l&agrave;: d&ugrave;ng webpack để đ&oacute;ng g&oacute;i tất cả những th&agrave;nh phần cần thiết, v&agrave; chuyển đổi ch&uacute;ng th&agrave;nh dạng c&oacute; thể d&ugrave;ng được ở ph&iacute;a browser, sau đ&oacute; xuất kết quả ra file output (vd: index_bundle.js) để ta nạp v&agrave;o trang html. Task runner l&agrave; g&igrave;? Tại sao n&oacute; lại tồn tại? Bạn c&oacute; thể sẽ thắc mắc: qu&aacute;i, đ&atilde; qu&aacute; nhiều thứ mới xuất hiện khi l&agrave;m việc với Javascript rồi, vẫn c&ograve;n nữa sao? Tin buồn l&agrave; vẫn c&ograve;n nhiều thứ xung quanh hệ sinh th&aacute;i javascript. Tin vui l&agrave;: đ&acirc;y l&agrave; kh&aacute;i niệm lớn cuối c&ugrave;ng trong b&agrave;i, v&agrave; m&igrave;nh nghĩ rằng nhi&ecirc;u đ&acirc;y l&agrave; đủ để tung ho&agrave;nh thế giới JS rồi. Sau tất cả c&aacute;c qu&aacute; tr&igrave;nh để build javascript từ khi lập tr&igrave;nh vi&ecirc;n viết code, cho tới khi đ&oacute;ng g&oacute;i n&oacute; để c&oacute; thể chạy được ở ph&iacute;a browser, c&aacute;c c&ocirc;ng cụ hỗ trợ gần như đ&atilde; đầy đủ. Chỉ c&ograve;n lại 2 c&acirc;u hỏi: Thứ nhất: n&atilde;y giờ, để thực hiện build/đ&oacute;ng g&oacute;i (gọi l&agrave; 1 task), ta phải chạy lệnh webpack thủ c&ocirc;ng, c&oacute; c&aacute;ch n&agrave;o để n&oacute; tự động chạy mỗi lần ta sửa code hay kh&ocirc;ng. Thứ hai: ngo&agrave;i webpack, nếu ta cũng cần thực hiện c&aacute;c nhiệm vụ kh&aacute;c th&igrave; thế n&agrave;o (vd: build v&agrave; đ&oacute;ng g&oacute;i file css, thực hiện cấu h&igrave;nh hệ thống, &hellip;) C&aacute;c task runner gi&uacute;p ta thực hiện những điều tr&ecirc;n: chạy một l&uacute;c nhiều task v&agrave; tự động k&iacute;ch hoạt task nếu ph&aacute;t hiện sự thay đổi của source code. C&oacute; nhiều task runner gi&uacute;p ta thực hiện điều n&agrave;y. Thời gian trước đ&acirc;y Grunt hoặc Gulp được sử dụng rất nhiều, nhưng giờ đ&acirc;y đang c&oacute; xu hướng dịch chuyển sang d&ugrave;ng npm script. Những c&ocirc;ng cụ n&agrave;y chỉ kh&aacute;c nhau về mặt c&uacute; ph&aacute;p, c&ograve;n lại &yacute; tưởng của ch&uacute;ng l&agrave; tương đối giống nhau. Minh họa với npm script, ta sẽ cấu h&igrave;nh lại mục scripts trong file package.json để c&oacute; thể thực thi như một dạng task runner: alt text Nội dung của file tools/build.js c&oacute; dạng như sau: const minifyLegacyJS = require(&#39;./tasks/minify_legacy_js&#39;); const webpack = require(&#39;./tasks/webpack&#39;); const clean = require(&#39;./tasks/clean&#39;); const run = async () =&gt; { const build_tasks = [clean, minifyLegacyJS, webpack]; const dev_tasks = [clean, webpack]; const tasks = isProduction() ? build_tasks : dev_tasks; for (const task of tasks) { await task(); } }; run(); Như vậy, mỗi khi cần thực hiện chạy build code ra dạng production hay ở mode development, ta chỉ cần d&ugrave;ng d&ograve;ng lệnh: //build ở dạng production npm run build //hoặc build ở mode development npm run dev Khi đ&oacute; task runner sẽ thực thi h&agrave;ng loạt c&aacute;c c&ocirc;ng việc cho ta, từ đ&oacute; gi&uacute;p giảm thiểu số d&ograve;ng lệnh m&agrave; một lập tr&igrave;nh vi&ecirc;n cần phải gọi để c&oacute; thể build ra được sản phẩm ho&agrave;n chỉnh. Tất nhi&ecirc;n l&agrave; để sử dụng được task runner, ta cũng cần viết lại config cho webpack v&agrave; từng task m&agrave; ta muốn thực hiện theo c&uacute; ph&aacute;p tương th&iacute;ch với task runner tương ứng. Một l&iacute; do m&agrave; npm scripts được ưa chuộng sử dụng hơn l&agrave; v&igrave; c&uacute; ph&aacute;p của n&oacute; rất giống với việc quản l&iacute; modules trong Node.js, từ đ&oacute; giảm thiểu việc phải học c&uacute; ph&aacute;p mới cũng như dễ d&agrave;ng bảo tr&igrave; nếu c&oacute; sự thay đổi sau n&agrave;y. T&oacute;m lại Ch&uacute;ng ta đ&atilde; đi được một chặng đường kh&aacute; d&agrave;i kể từ khi bắt đầu, việc sử dụng javascript để lập tr&igrave;nh ph&iacute;a frontend ng&agrave;y nay đ&atilde; trở n&ecirc;n phức tạp hơn rất nhiều so với trước đ&acirc;y, điều n&agrave;y khiến cho lập tr&igrave;nh vi&ecirc;n frontend cần phải biết th&ecirc;m rất nhiều kĩ năng v&agrave; c&ocirc;ng cụ để c&oacute; thể l&agrave;m việc được. Bắt đầu từ việc sử dụng file javascript được load thuần t&uacute;y trong file html, sau đ&oacute; ta d&ugrave;ng npm như l&agrave; một c&ocirc;ng cụ để kiểm so&aacute;t c&aacute;c thư viện d&ugrave;ng ngo&agrave;i. Để c&oacute; thể sử dụng c&uacute; ph&aacute;p import/export linh hoạt, ch&uacute;ng ta đ&atilde; phải vay mượn c&uacute; ph&aacute;p của Node.js (hoặc mới hơn l&agrave; ES6 đ&atilde; hỗ trợ) v&agrave; cần phải thực hiện đ&oacute;ng g&oacute;i modules bằng webpack để c&oacute; thể sử dụng được m&atilde; nguồn ở ph&iacute;a client-side. Việc &aacute;p dụng Babel v&agrave; Task runner v&agrave;o cũng gi&uacute;p ch&uacute;ng ta nhiều hơn trong việc đảm bảo t&iacute;nh tương th&iacute;ch cũng như qu&aacute; tr&igrave;nh build source code ra dạng production. Mặc d&ugrave; c&oacute; rất nhiều c&aacute;c c&ocirc;ng cụ v&agrave; kh&aacute;i niệm mới m&agrave; lập tr&igrave;nh vi&ecirc;n phải học hỏi, tin tốt l&agrave; giờ đ&acirc;y c&aacute;c c&ocirc;ng cụ n&agrave;y dần trưởng th&agrave;nh v&agrave; ổn định hơn nhiều so với thời gian trước đ&acirc;y. Việc hiểu được vai tr&ograve; của từng c&ocirc;ng cụ cũng như l&iacute; do tại sao n&oacute; ra đời sẽ gi&uacute;p bạn bắt nhịp được với xu hướng nếu c&oacute; những sự đổi mới xảy ra. Hi vọng l&agrave; nội dung t&oacute;m tắt ngắn gọn n&agrave;y c&oacute; thể gi&uacute;p &iacute;ch cho mọi người trong qu&aacute; tr&igrave;nh ph&aacute;t triển của m&igrave;nh.</p>\n",
      "total_views": 780,
      "status": true,
      "tags": [
        "Javascript"
      ]
    },
    {
      "title": "Hiểu về HTTPS trong 5 phút",
      "content": "<p>Mấy h&ocirc;m nay c&oacute; dịp &ocirc;n lại về HTTPS, mặc d&ugrave; đ&atilde; c&oacute; nhiều t&agrave;i liệu n&oacute;i về giao thức n&agrave;y nhưng hầu hết ch&uacute;ng thường được m&ocirc; tả bằng ng&ocirc;n ngữ kĩ thuật tương đối phức tạp, v&igrave; vậy sẵn tiện m&igrave;nh viết một bản t&oacute;m tắt nhỏ về giao thức bảo mật n&agrave;y theo c&aacute;ch đơn giản nhất c&oacute; thể. Về cơ bản, HTTP hay HTTPS l&agrave; những phương thức giao tiếp giữa 2 b&ecirc;n (giữa client v&agrave; server), kh&ocirc;ng cần đi qu&aacute; s&acirc;u v&agrave;o chi tiết, h&atilde;y h&igrave;nh dung việc giao tiếp n&agrave;y l&agrave; một cuộc trao đổi thư từ giữa 2 người. Lấy v&iacute; dụ với ch&agrave;ng Romeo v&agrave; người y&ecirc;u l&agrave; n&agrave;ng Juliet. Như vậy, qu&aacute; tr&igrave;nh trao đổi gồm 3 đối tượng ch&iacute;nh: 2 người cần trao đổi thư từ (Romeo &amp; Juliet) + người giao thư (k&ecirc;nh kết nối). Bắt đầu với c&aacute;ch đơn giản nhất Nếu Romeo muốn gửi thư cho Juliet, rất đơn giản, anh ta chỉ cần viết nội dung v&agrave;o một l&aacute; thư, sau đ&oacute; nhờ người đưa thư giao cho Juliet. Khi Juliet nhận được thư, n&agrave;ng đọc, v&agrave; như vậy l&agrave; qu&aacute; tr&igrave;nh li&ecirc;n lạc ho&agrave;n tất trọn vẹn. alt text (Trường hợp gửi thư th&ocirc;ng thường &ndash; HTTP (Đơn giản nhưng dễ bị tấn c&ocirc;ng man-in-the-midle) ) Nhưng, sẽ thế n&agrave;o nếu &ocirc;ng Capulet (cha của Juliet) chen ngang v&agrave;o đoạn giữa &ndash; trước khi người đưa thư trao thư cho Juliet (Kiểu tấn c&ocirc;ng man-in-the-middle). Với HTTP, nội dung thư kh&ocirc;ng được m&atilde; ho&aacute;, &ocirc;ng Capulet c&oacute; thể sửa nội dung thư trước khi trao lại cho con g&aacute;i m&igrave;nh, Juliet sẽ kh&ocirc;ng thể biết được l&aacute; thư m&igrave;nh nhận đ&atilde; bị sửa hay chưa. Như vậy, qu&aacute; tr&igrave;nh trao đổi c&oacute; thể xuất hiện sai lệch kh&ocirc;ng thể kiểm tra được (điều n&agrave;y thực sự nguy hiểm). Đ&acirc;y ch&iacute;nh l&agrave; vấn đề m&agrave; HTTPS muốn giải quyết. Romeo v&agrave; Juliet phải m&atilde; ho&aacute; th&ocirc;ng tin Romeo v&agrave; Juliet đ&atilde; nghĩ ra 1 c&aacute;ch để che giấu đi th&ocirc;ng điệp m&agrave; 2 người trao đổi, họ sẽ m&atilde; ho&aacute; l&aacute; thư trước khi gửi. C&aacute;ch m&atilde; ho&aacute; như sau: dịch bảng chữ c&aacute;i về ph&iacute;a sau 1 k&iacute; tự (m&atilde; ho&aacute; tức l&agrave; biến đổi th&ocirc;ng tin theo 1 c&aacute;ch n&agrave;o đ&oacute; để n&oacute; kh&aacute;c đi so với ban đầu). Như vậy, nếu th&ocirc;ng điệp l&agrave; &ldquo;I love you&rdquo;, th&igrave; Romeo sẽ viết th&agrave;nh &ldquo;J mpwf zpv&rdquo;. Chỉ c&oacute; Romeo v&agrave; Juliet biết được c&aacute;ch để giải m&atilde;, v&agrave; như vậy, &ocirc;ng Capulet sẽ bất lực khi muốn thay đổi nội dung l&aacute; thư, bất cứ sự thay đổi n&agrave;o cũng sẽ bị cả 2 ph&aacute;t hiện. Với quy ước đ&atilde; định (ta gọi c&aacute;ch giải m&atilde; l&agrave; kho&aacute; &ndash; key), n&agrave;ng Juliet chỉ cần dịch chuyển bảng chữ c&aacute;i đi l&agrave; sẽ giải m&atilde; ra được th&ocirc;ng điệp ban đầu, l&agrave; &ldquo;I love you&rdquo;. alt text Qu&aacute; tr&igrave;nh m&atilde; ho&aacute; n&agrave;y được gọi l&agrave; &ldquo;m&atilde; ho&aacute; đối xứng&rdquo; (symmetric key cryptography), tức l&agrave;: khi biết được c&aacute;ch m&atilde; ho&aacute;, sẽ biết được c&aacute;ch giải m&atilde;. Vấn đề đ&atilde; được giải quyết chưa? Vẫn chưa &hellip; L&agrave;m thế n&agrave;o để Romeo v&agrave; Juliet thống nhất được kho&aacute; (key)? C&aacute;ch m&atilde; ho&aacute; đối xứng tương đối an to&agrave;n nếu kho&aacute; chỉ được giữ bởi 2 b&ecirc;n nhận v&agrave; gửi. Vấn đề l&agrave;: Bởi v&igrave; Romeo v&agrave; Juliet kh&ocirc;ng thể gặp trực tiếp nhau, l&agrave;m sao họ n&oacute;i cho nhau biết được c&aacute;ch họ sẽ m&atilde; ho&aacute; l&agrave; g&igrave; (kho&aacute; l&agrave; g&igrave;)? Bởi v&igrave; vấn đề n&agrave;y, ta sẽ phải thay đổi ho&agrave;n to&agrave;n c&aacute;ch để gửi v&agrave; nhận thư giữa 2 người: d&ugrave;ng chiếc hộp b&iacute; mật. Chiếc hộp b&iacute; mật Romeo v&agrave; Juliet quyết định sẽ thực hiện việc trao đổi theo một c&aacute;ch ho&agrave;n to&agrave;n mới. Khi m&agrave; Romeo muốn gửi thư cho Juliet, họ sẽ thực hiện theo quy tr&igrave;nh sau: Romeo n&oacute;i với người đưa thư rằng anh muốn gửi thư cho Juliet, v&agrave; người đưa thư sẽ n&oacute;i với Juliet điều đ&oacute; (L&uacute;c n&agrave;y, th&ocirc;ng điệp ri&ecirc;ng tư vẫn chưa được gửi). Tức l&agrave; ph&aacute;t đi t&iacute;n hiệu muốn gửi thư. Juliet đưa cho người đưa thư một chiếc hộp với t&igrave;nh trạng mở kho&aacute;, chỉ c&oacute; n&agrave;ng nắm giữ chiếc kho&aacute; mở. Người đưa thư quay trở lại với Romeo, v&agrave; Romeo sẽ bỏ l&aacute; thư cần gửi v&agrave;o chiếc hộp v&agrave; kho&aacute; lại. Chiếc hộp với t&igrave;nh trạng kho&aacute; sẽ được người đưa thư chuyển ngược lại cho Juliet. Cuối c&ugrave;ng, Juliet nhận được chiếc hộp, n&agrave;ng d&ugrave;ng kho&aacute; ri&ecirc;ng mở ra v&agrave; đọc nội dung m&agrave; Romeo đ&atilde; gửi. Bằng c&aacute;ch n&agrave;y, &ocirc;ng Capulet (vai tr&ograve; man-in-the-midle) d&ugrave; c&oacute; lấy được chiếc hộp cũng kh&ocirc;ng thể mở ra để đọc nội dung l&aacute; thư b&ecirc;n trong. Juliet l&uacute;c n&agrave;y c&oacute; thể y&ecirc;n t&acirc;m rằng nội dung thư trao đổi được bảo mật v&agrave; an to&agrave;n. alt text (Kĩ thuật trao đổi c&oacute; m&atilde; ho&aacute; bất đối xứng) Một c&aacute;ch kĩ thuật, ta c&oacute; thể gọi c&aacute;ch m&atilde; ho&aacute; n&agrave;y l&agrave; &ldquo;m&atilde; ho&aacute; bất đối xứng&rdquo; (asymetric key cryptography), tức l&agrave; người thực hiện m&atilde; ho&aacute; chưa chắc đ&atilde; giải m&atilde; ngược lại được (Romeo kho&aacute; hộp lại được nhưng kh&ocirc;ng thể mở ra lại, v&igrave; Juliet l&agrave; người duy nhất giữ kho&aacute;). C&oacute; thể h&igrave;nh dung n&ocirc;m na rằng, chiếc hộp l&agrave; public key, v&agrave; ch&igrave;a kho&aacute; l&agrave; private key. L&agrave;m thế n&agrave;o biết được chiếc hộp l&agrave; của Juliet m&agrave; kh&ocirc;ng phải giả mạo? Nếu bạn tinh &yacute;, th&igrave; c&oacute; thể nhận ra rằng, c&aacute;ch giao tiếp ở tr&ecirc;n vẫn tồn tại 1 vấn đề c&ograve;n kh&uacute;c mắc: bởi v&igrave; 2 người kh&ocirc;ng c&oacute; cơ hội gặp trực tiếp, l&agrave;m thế n&agrave;o Romeo biết được chiếc hộp kia l&agrave; của Juliet m&agrave; kh&ocirc;ng phải của một man-in-the-midle n&agrave;o kh&aacute;c? C&acirc;u trả lời l&agrave;: Juliet sẽ tạo 1 chữ k&iacute; (signature) ở chiếc hộp, v&agrave; Romeo sẽ kiểm tra xem chiếc hộp gửi đến c&oacute; tồn tại chữ k&iacute; của n&agrave;ng Juliet hay kh&ocirc;ng. Lại một c&acirc;u hỏi nữa: L&agrave;m thế n&agrave;o biết được chữ k&iacute; l&agrave; thật? Thay đổi c&aacute;ch l&agrave;m ở tr&ecirc;n 1 ch&uacute;t, ta sẽ c&oacute; c&aacute;ch giải quyết: thay v&igrave; Juliet sẽ k&iacute; t&ecirc;n, th&igrave; một người kh&aacute;c (c&oacute; uy t&iacute;n cao) sẽ k&iacute; t&ecirc;n x&aacute;c nhận rằng chiếc hộp đ&uacute;ng l&agrave; của Juliet k&iacute; t&ecirc;n. Người thực hiện k&iacute; t&ecirc;n thay mặt n&agrave;y phải l&agrave; một người c&oacute; uy t&iacute;n cao v&agrave; được mọi người c&ocirc;ng nhận, ta giả sử rằng trong trường hợp Romeo v&agrave; Juliet, người cấp x&aacute;c thực cho chiếc hộp ch&iacute;nh l&agrave; Cha sở nh&agrave; thờ (nếu bạn c&oacute; đọc qua truyện Romeo &amp; Juliet th&igrave; sẽ biết c&oacute; một vị cha sở c&oacute; uy t&iacute;n trong v&ugrave;ng đ&atilde; l&agrave;m chứng cho 2 người kết h&ocirc;n). Khi cấp chứng chỉ x&aacute;c thực, cha sở sẽ kiểm tra chiếc hộp đ&uacute;ng l&agrave; của Juliet, v&agrave; sẽ đ&aacute;nh dấu x&aacute;c thực v&agrave;o chiếc hộp n&agrave;y. Khi đ&oacute; Romeo v&agrave; Juliet sẽ biết ch&iacute;nh x&aacute;c rằng chiếc hộp l&agrave; b&iacute; mật v&agrave; hợp lệ giữa 2 người m&agrave; kh&ocirc;ng cần phải gặp nhau trực tiếp để x&aacute;c nhận. alt text (M&ocirc; h&igrave;nh x&aacute;c thực kho&aacute; trong thực tế) Trong thực tế kĩ thuật, người cha sở trong v&iacute; dụ n&agrave;y ch&iacute;nh l&agrave; c&aacute;c &ldquo;đơn vị cung cấp chứng thực số&rdquo; (certification authority), c&aacute;c chữ k&iacute; x&aacute;c thực ch&iacute;nh l&agrave; c&aacute;c &ldquo;chứng chỉ số&rdquo; (certificate) m&agrave; nh&agrave; cung cấp dịch vụ x&aacute;c thực cấp cho website của bạn. Bởi v&igrave; t&iacute;nh chất định danh, mỗi &ldquo;chứng chỉ số&rdquo; l&agrave; ri&ecirc;ng biệt v&agrave; duy nhất. Romeo trong thực tế ch&iacute;nh l&agrave; tr&igrave;nh duyệt web của bạn, v&agrave; Juliet ch&iacute;nh l&agrave; c&aacute;c trang web m&agrave; bạn truy cập đến. Khi bạn thực hiện truy vấn tới trang web n&agrave;o đ&oacute;, server sẽ trả về th&ocirc;ng tin m&atilde; ho&aacute; v&agrave; chứng chỉ số cho browser. C&aacute;c browser c&oacute; hỗ trợ HTTPS sẽ tự động kiểm chứng c&aacute;c certificate n&agrave;y. Đến đ&acirc;y th&igrave; hẳn l&agrave; bạn đ&atilde; h&igrave;nh dung được tổng quan về HTTPS l&agrave; g&igrave; rồi. Chiếc hộp v&agrave; vấn đề về hiệu suất N&oacute;i th&ecirc;m một ch&uacute;t, mặc d&ugrave; việc gửi nhận c&aacute;c nội dung thư từ th&ocirc;ng qua chiếc hộp b&iacute; mật đ&atilde; giải quyết được vấn đề về độ bảo mật, nhưng c&aacute;ch n&agrave;y c&oacute; vẻ như đ&atilde; tăng số bước l&ecirc;n nhiều lần so với th&ocirc;ng thường, c&oacute; c&aacute;ch n&agrave;o để hạn chế việc d&ugrave;ng hộp m&agrave; th&ocirc;ng tin vẫn được đảm bảo hay kh&ocirc;ng? C&acirc;u trả lời l&agrave;: Kết hợp cả 2 kiểu m&atilde; ho&aacute; đối xứng (gửi th&ocirc;ng điệp trực tiếp đ&atilde; được m&atilde; ho&aacute;) v&agrave; bất đối xứng (gửi th&ocirc;ng điệp th&ocirc;ng qua chiếc hộp b&iacute; mật): M&atilde; ho&aacute; bất đối xứng được thực thi lần đầu ti&ecirc;n khi ta tạo kết nối giữa client v&agrave; server, lần &ldquo;giao tiếp&rdquo; đầu ti&ecirc;n n&agrave;y 2 b&ecirc;n sẽ thống nhất c&aacute;ch thức của m&atilde; ho&aacute; đối xứng được d&ugrave;ng cho c&aacute;c lần giao tiếp tiếp theo. Khi đ&atilde; thống nhất c&aacute;ch m&atilde; ho&aacute; đối xứng rồi, c&aacute;c lần giao tiếp sau chỉ cần sử dụng c&aacute;ch m&atilde; ho&aacute; n&agrave;y m&agrave; kh&ocirc;ng cần d&ugrave;ng th&ecirc;m chiếc hộp b&iacute; mật nữa. Hết rồi, tổng quan về HTTPS chỉ c&oacute; bấy nhi&ecirc;u đ&oacute; th&ocirc;i. Ch&uacute;c vui! alt text</p>\n",
      "total_views": 53,
      "status": true,
      "tags": [
        "Messenger", "Chrome Extension", "Facebook"
      ]
    },
    {
      "title": "Callback function và Higher-order function trong Javascript",
      "content": "<p>rong b&agrave;i n&agrave;y m&igrave;nh sẽ tr&igrave;nh b&agrave;y về một trong những kh&aacute;i niệm cốt l&otilde;i v&agrave; mạnh mẽ l&agrave;m n&ecirc;n Javascript. H&atilde;y nhớ rằng, trong Javascript, một h&agrave;m cũng ch&iacute;nh l&agrave; 1 object, bởi thế h&agrave;m sẽ mang nhiều t&iacute;nh chất giống c&aacute;c kiểu dữ liệu th&ocirc;ng thường kh&aacute;c như Number, String, Array, &hellip; do vậy ch&uacute;ng ta c&oacute; thể thực hiện những việc như: lưu trữ h&agrave;m trong 1 biến, truyền h&agrave;m như một tham số v&agrave;o của h&agrave;m kh&aacute;c, tạo ra 1 h&agrave;m b&ecirc;n trong h&agrave;m, v&agrave; return h&agrave;m như 1 gi&aacute; trị trả về. Ch&iacute;nh bởi v&igrave; khả năng truyền 1 h&agrave;m như l&agrave; tham số đầu v&agrave;o của một h&agrave;m kh&aacute;c (ta gọi l&agrave; &ldquo;h&agrave;m-kh&aacute;c&rdquo; để ph&acirc;n biệt), sau n&oacute; được gọi thực thi b&ecirc;n trong &ldquo;h&agrave;m-kh&aacute;c&rdquo; n&agrave;y, m&agrave; ta c&oacute; kh&aacute;i niệm callback function &ndash; mang h&agrave;m &yacute; &ldquo;h&agrave;m được gọi thực thi sau&rdquo;. Ngo&agrave;i ra, ta gọi &ldquo;h&agrave;m-kh&aacute;c&rdquo; n&agrave;y l&agrave; h&agrave;m higher-order function. Kh&aacute;i niệm truyền h&agrave;m như một tham số thực ra kh&ocirc;ng hề mới, n&oacute; l&agrave; một kh&aacute;i niệm của lập-tr&igrave;nh-h&agrave;m (functional programming). Nếu c&aacute;c bạn đ&atilde; từng học qua C/C++ th&igrave; chắc cũng đ&atilde; biết về kh&aacute;i niệm &ldquo;con trỏ h&agrave;m&rdquo;, kh&aacute;i niệm callback function thực ra kế thừa từ đ&oacute;, chỉ c&oacute; điều, độ phổ biến của callback function trong Javascript l&agrave; lớn hơn rất nhiều. H&agrave;m higher-order v&agrave; h&agrave;m callback l&agrave; g&igrave;? N&oacute;i một c&aacute;ch đơn giản nhất th&igrave;: H&agrave;m higher-order (higher-order function) l&agrave; h&agrave;m c&oacute; hoạt động dựa tr&ecirc;n 1 h&agrave;m kh&aacute;c, tức l&agrave;: n&oacute; c&oacute; thể nhận h&agrave;m (function) l&agrave;m tham số đầu v&agrave;o, hoặc sẽ return ra 1 h&agrave;m kh&aacute;c. Một trong 2 điều kiện đ&oacute; xảy ra th&igrave; được gọi l&agrave; h&agrave;m higher-order. H&agrave;m callback l&agrave;m h&agrave;m được truyền v&agrave;o &ldquo;h&agrave;m-kh&aacute;c&rdquo; như một tham số đầu v&agrave;o, sau đ&oacute; sẽ được gọi k&iacute;ch hoạt b&ecirc;n trong &ldquo;h&agrave;m-kh&aacute;c&rdquo; n&agrave;y. Nghe c&oacute; vẻ kh&oacute; hiểu, nhưng h&atilde;y xem x&eacute;t c&aacute;c minh hoạ trực quan hơn sau đ&acirc;y: function mapArrayString2Length (originalArray, itemFunction) { var newArray = []; var newValue; var i; var len; for (i = 0, len = originalArray.length; i &lt; len; i++) { newValue = itemFunction(originalArray[ i ]); newArray.push(newValue); } return newArray; } function findLength (str) { return str.length } Ta thấy, h&agrave;m mapArrayString2Length() c&oacute; nhận 1 tham số l&agrave; h&agrave;m (tham số itemFunction), như vậy h&agrave;m mapArrayString2Length() được gọi l&agrave; h&agrave;m higher-order. Ngo&agrave;i ra h&agrave;m findLength() được truyền v&agrave;o như l&agrave; 1 tham số, do đ&oacute; ta gọi h&agrave;m findLength() hoặc tham số itemFunction l&agrave; h&agrave;m callback. Chạy thử đoạn code tr&ecirc;n sẽ cho kết quả như sau: var arr_name = [ &#39;Ronaldo&#39;, &#39;Messi&#39;, &#39;Suarez&#39; ]; var arr_length = map( arr_name, findLength ); // [7, 5, 6] Ngo&agrave;i ra, h&atilde;y thử xem th&ecirc;m một v&iacute; dụ về h&agrave;m higher-order c&oacute; trả về 1 h&agrave;m kh&aacute;c sau đ&acirc;y: function makeMultiplier( multNum ) { return function( num ) { return multNum * num }; } //Truyền &quot;hệ số nh&acirc;n&quot; tuỳ &yacute; để tạo ra c&aacute;c h&agrave;m kh&aacute;c nhau var doubler = makeMultiplier(2); //Hệ số nh&acirc;n l&agrave; 2 var _3x2_ = doubler(3); //6 var _4x2_ = doubler(4); //8 H&agrave;m makeMultiplier() cũng được coi l&agrave; 1 higher-order function. Callback thường được d&ugrave;ng ở chỗ n&agrave;o trong Javascript? Trong Js, nếu x&eacute;t ở ph&iacute;a client, ngo&agrave;i những đoạn code xử l&iacute; tuần tự th&ocirc;ng thường, ta c&oacute; 2 hoạt động tương đối kh&aacute;c biệt so với những ng&ocirc;n ngữ server kh&aacute;c, đ&oacute; l&agrave;: Lắng nghe event: điển h&igrave;nh như lắng nghe sự kiện click chuột, lắng nghe sự kiện ph&iacute;m enter, &hellip; Xử l&iacute; bất đồng bộ: Đặc trưng nổi bật của JS l&agrave; khả năng xử l&iacute; bất đồng bộ, c&oacute; thể kể đến v&agrave;i hoạt động như: gọi AJAX, đọc file dạng async, &hellip; Về phần code xử l&iacute; lắng nghe event, nếu bạn d&ugrave;ng jQuery th&igrave; những callback function sẽ c&oacute; dạng như thế n&agrave;y: //Lắng nghe click event, h&agrave;m xử l&iacute; ta truyền v&agrave;o ch&iacute;nh l&agrave; 1 callback $(&quot;#btn_1&quot;).click(function() { alert(&quot;Btn 1 Clicked&quot;); }); Ngo&agrave;i ra, nếu bạn gọi AJAX, hoặc c&aacute;c xử l&iacute; bất đồng bộ tương tự như thế, bạn cũng sẽ sử dụng callback rất nhiều: function successCallback( jqXHR ) { // Do something if success } function errorCallback( jqXHR ) { // Do something if success } $.ajax({ url: &quot;http://fiddle.jshell.net/favicon.png&quot;, success: successCallback, error: errorCallback }); Bạn c&oacute; hiểu Callback hoạt động như thế n&agrave;o? Như đ&atilde; n&oacute;i ban đầu, h&agrave;m trong javascript cũng ch&iacute;nh l&agrave; đối tượng object, ch&uacute;ng ta c&oacute; thể truyền h&agrave;m v&agrave;o tham số tương tự như c&aacute;ch ch&uacute;ng ta vẫn l&agrave;m với c&aacute;c kiểu dữ liệu kh&aacute;c vậy. H&atilde;y để &yacute; rằng, sự kh&aacute;c biệt quyết định 1 h&agrave;m c&oacute; được thực thi hay kh&ocirc;ng ch&iacute;nh l&agrave; cặp dấu ngoặc (), giả sử ta khai b&aacute;o 1 h&agrave;m như sau: function doSomething( input ) { // Do something } Khi đ&oacute;, nếu ta chỉ đơn thuần gọi t&ecirc;n h&agrave;m doSomething m&agrave; kh&ocirc;ng c&oacute; cặp dấu ngoặc, th&igrave; đơn thuần l&agrave; ta vừa gọi tới định nghĩa của h&agrave;m, khi ta gọi doSomething() &ndash; c&oacute; cặp dấu ngoặc &ndash; th&igrave; khi đ&oacute; h&agrave;m mới được thực thi. V&igrave; thế, khi ta truyền h&agrave;m đi, ta chỉ đơn thuần sử dụng t&ecirc;n h&agrave;m m&agrave; kh&ocirc;ng c&oacute; dấu ngoặc &ndash; tức l&agrave; chỉ truyền đi định nghĩa h&agrave;m &ndash; c&oacute; định nghĩa của h&agrave;m th&ocirc;ng qua tham số r&ugrave;i, th&igrave; h&agrave;m higher-order muốn sử dụng callback l&uacute;c n&agrave;o cũng được (k&iacute;ch hoạt bằng c&aacute;ch th&ecirc;m cặp dấu ngoặc). Một v&agrave;i vấn đề gặp phải khi sử dụng callback function Do viện d&ugrave;ng h&agrave;m trong Javascript tương đối linh hoạt, do vậy ta sẽ thường gặp hai vấn đề ch&iacute;nh khi sử dụng callback như sau: đảm bảo context của con trỏ this trong callback, v&agrave; địa ngục callback (callback hell). Đừng vội hoảng sợ, ta đều sẽ c&oacute; c&ocirc;ng cụ để đối ph&oacute; với việc n&agrave;y. Đảm bảo context của con trỏ this trong callback C&oacute; thể bạn đ&atilde; biết, khi một h&agrave;m được k&iacute;ch hoạt, bản th&acirc;n n&oacute; sẽ c&oacute; một gi&aacute; trị tham chiếu tới đối tượng vừa gọi n&oacute;, gi&aacute; trị n&oacute; nằm ở con trỏ this. Như mọi người đ&atilde; thấy ở tr&ecirc;n, ta c&oacute; thể truyền h&agrave;m callback đi bất k&igrave; đ&acirc;u ta muốn, tức l&agrave; đối tượng k&iacute;ch hoạt h&agrave;m callback n&agrave;y ch&iacute;nh l&agrave; h&agrave;m higher-order chứa n&oacute;. Tuy nhi&ecirc;n, trong nhiều trường hợp khi thiết kế h&agrave;m callback, người d&ugrave;ng mong muốn con trỏ this của h&agrave;m callback l&agrave; 1 đối tượng cụ thể n&agrave;o kh&aacute;c chứ kh&ocirc;ng phải l&agrave; h&agrave;m higher-order, vậy ta phải xử l&iacute; thế n&agrave;o? (Xem thử minh hoạ sau đ&acirc;y) var counter = { count_number: 0, count_up: function(){ this.count_number += 1; } }; jQuery(&#39;#button_count&#39;).click( counter.count_up ); //viết thế n&agrave;y chương tr&igrave;nh sẽ chạy kh&ocirc;ng đ&uacute;ng Đoạn code tr&ecirc;n bắt sự kiện click chuột v&agrave;o n&uacute;t button_count để c&oacute; thể tăng biến đếm của counter, h&agrave;m count_up được truyền v&agrave;o như 1 h&agrave;m callback, v&agrave; vấn đề ch&iacute;nh l&agrave; ở điểm n&agrave;y: khi sự kiện click chuột v&agrave;o button_count được k&iacute;ch hoạt, h&agrave;m count_up được gọi nhưng n&oacute; kh&ocirc;ng thể t&igrave;m thấy biến this.count_number. L&yacute; do l&agrave; con trỏ this của h&agrave;m count_up đang trỏ tới h&agrave;m higher-order gọi n&oacute; chứ kh&ocirc;ng phải đối tượng counter. Để giải quyết vấn đề n&agrave;y, ta phải chỉ định r&otilde; context của h&agrave;m callback ngay từ khi truyền v&agrave;o. Javascript cung cấp cho ta 3 c&ocirc;ng cụ l&agrave; bind(), call() v&agrave; apply(), bạn c&oacute; thể t&igrave;m hiểu kĩ hơn về những c&ocirc;ng cụ n&agrave;y trong b&agrave;i viết kh&aacute;c của m&igrave;nh ở LINK N&Agrave;Y, c&ograve;n cụ thể lần n&agrave;y th&igrave; ta sẽ d&ugrave;ng bind(). jQuery(&#39;#button_count&#39;).click( counter.count_up.bind( counter ) ); Rất nhiều bug xảy ra khi ta kh&ocirc;ng chủ động kiểm so&aacute;t tốt context của h&agrave;m callback khi gọi, v&igrave; vậy h&atilde;y ch&uacute; &yacute; tới việc n&agrave;y mỗi khi c&oacute; &yacute; định sử dụng callback. Địa ngục callback (callback hell) Như ta đ&atilde; biết, h&agrave;m callback được thực thi b&ecirc;n trong 1 h&agrave;m kh&aacute;c, nếu ta tiếp tục c&oacute; h&agrave;m callback b&ecirc;n trong một callback kh&aacute;c th&igrave; thế n&agrave;o? V&ograve;ng lặp v&ocirc; tận &ldquo;callback b&ecirc;n trong callback b&ecirc;n trong callback &hellip; &rdquo; sẽ c&oacute; khả năng xảy ra. Thứ qu&aacute;i quỷ n&agrave;y được gọi l&agrave; callback hell &ndash; địa ngục callback, ta sẽ rất hay gặp vấn đề n&agrave;y trong khi xử l&iacute; c&aacute;c lệnh bất đồng bộ, kiểu như: p_client.open(function(err, p_client) { p_client.dropDatabase(function(err, done) { p_client.createCollection(&#39;test_custom_key&#39;, function(err, collection) { collection.insert({&#39;a&#39;:1}, function(err, docs) { // ... // v&agrave; nhiều callback nữa }); }); }); }); Khi callback hell xuất hiện, logic xử l&iacute; của chương tr&igrave;nh sẽ trở n&ecirc;n cực k&igrave; phức tạp v&agrave; kh&oacute; nắm bắt, khi c&oacute; lỗi xảy ra ta rất kh&oacute; để debug cũng như giải quyết. B&ecirc;n cạnh đ&oacute;, callback hell cũng l&agrave;m cho t&iacute;nh thẩm mĩ của code giảm đi đ&aacute;ng kể, kh&oacute; đọc, kh&oacute; maintain, &hellip; Để giải quyết, ta c&oacute; 2 c&aacute;ch sau đ&acirc;y: Nếu vẫn sử dụng callback: ta n&ecirc;n khai b&aacute;o từng h&agrave;m callback ri&ecirc;ng biệt với t&ecirc;n cụ thể, sau đ&oacute; gọi h&agrave;m callback đầu ti&ecirc;n. C&aacute;ch n&agrave;y tuy l&agrave;m thẩm mĩ code tr&ocirc;ng tốt hơn một ch&uacute;t nhưng thực tế th&igrave; code vẫn c&ograve;n rất tệ v&agrave; kh&oacute; đọc. Sử dụng kĩ thuật chạy bất đồng bộ kh&aacute;c: c&oacute; thể d&ugrave;ng kĩ thuật promise, async v&agrave; await, &hellip; C&aacute;c kĩ thuật n&agrave;y giải quyết kh&aacute; triệt để callback hell, m&igrave;nh khuy&ecirc;n mọi người n&ecirc;n t&igrave;m hiểu c&aacute;c kĩ thuật n&agrave;y. Chỉ mất 1 ch&uacute;t thời gian t&igrave;m hiểu nhưng lợi &iacute;ch c&oacute; được l&agrave; rất rất nhiều. Tổng kết Xuy&ecirc;n xuốt phần tr&igrave;nh b&agrave;y vừa rồi, mọi người đ&atilde; c&oacute; thể hiểu được kh&aacute;i niệm h&agrave;m callback trong Javascript l&agrave; g&igrave;, thấy được sự linh hoạt v&agrave; t&iacute;nh mạnh mẽ của n&oacute;, ngo&agrave;i ra những chỗ thường được ứng dụng kĩ thuật callback cũng đ&atilde; được tr&igrave;nh b&agrave;y. H&agrave;m callback rất linh hoạt v&agrave; hữu dụng, tuy nhi&ecirc;n n&oacute; cũng c&oacute; những hạn chế nhất định, hi vọng mọi người c&oacute; thể nắm được những hạn chế của n&oacute; v&agrave; một v&agrave;i c&aacute;ch khắc phục phổ biến v&agrave; hiệu quả. Ch&uacute;c c&aacute;c anh em code javascript vui vẻ :smile: vcttai 10-07-2017</p>\n",
      "total_views": 945,
      "status": true,
      "tags": [
        "Messenger", "JavaScript", "Facebook"
      ]
    },
    {
      "title": "Con trỏ this trong Javascript",
      "content": "<p>Con trỏ this c&oacute; lẽ l&agrave; một kh&aacute;i niệm kh&ocirc;ng mấy xa lạ trong lập tr&igrave;nh hướng đối tượng, n&oacute; l&agrave; một thể hiện cho đối tượng đang chứa đoạn m&atilde; lệnh đang được thực thi, hiểu n&ocirc;m na kiểu ng&ocirc;n ngữ con người l&agrave; thế n&agrave;y: Nam học b&agrave;i rất chăm chỉ v&igrave; sẽ c&oacute; một b&agrave;i kiểm tra v&agrave;o cuối tuần, b&agrave;i kiểm tra n&agrave;y rất quan trọng đối với Nam. C&oacute; thể biểu diễn c&acirc;u n&oacute;i n&agrave;y bằng một c&aacute;ch kh&aacute;c như sau: Nam học b&agrave;i rất chăm chỉ v&igrave; sẽ c&oacute; một b&agrave;i kiểm tra v&agrave;o cuối tuần n&agrave;y, b&agrave;i kiểm tra n&agrave;y rất quan trọng đối với anh ấy. Hai c&acirc;u tr&ecirc;n ho&agrave;n to&agrave;n đồng nghĩa với nhau, mặc d&ugrave; kh&ocirc;ng n&oacute;i r&otilde; r&agrave;ng nhưng tất cả ch&uacute;ng ta đều hiểu &ldquo;anh ấy&rdquo; ch&iacute;nh l&agrave; &ldquo;Nam&rdquo;. Con trỏ this cũng c&oacute; &yacute; nghĩa tương tự như thế. Nếu n&oacute;i theo ng&ocirc;n ngữ con người, th&igrave; con trỏ this ch&iacute;nh l&agrave; một đại từ nh&acirc;n xưng nhằm &aacute;m chỉ một đối tượng cụ thể đ&atilde; được chỉ r&otilde; ở ngữ cảnh trước đ&oacute;. Con trỏ this được sử dụng rất nhiều trong c&aacute;c đoạn m&atilde; JS, v&agrave; n&oacute; cũng l&agrave; một trong những kh&aacute;i niệm g&acirc;y ra nhiều sự hiểu lầm (dẫn đến bug) nhất trong ng&ocirc;n ngữ n&agrave;y. Sẽ l&agrave; hơi mất c&ocirc;ng nếu ta muốn t&igrave;m hiểu đầy đủ về n&oacute;, nhưng một khi đ&atilde; hiểu về n&oacute;, ta sẽ thấy c&ocirc;ng sức ta bỏ ra kh&ocirc;ng ph&iacute; một ch&uacute;t n&agrave;o. Nhắc lại về con trỏ this Trong c&aacute;c ng&ocirc;n ngữ lập tr&igrave;nh như C++, C#, Java, PHP hay cả Javascript, con trỏ this thường được sử dụng để chỉ đến object chứa phương thức đang được gọi thực thi, tr&ocirc;ng ra th&igrave; c&aacute;ch d&ugrave;ng n&agrave;y c&oacute; vẻ tường minh v&agrave; dễ hiểu, c&aacute;c đoạn m&atilde; kiểu đ&oacute; thường c&oacute; dạng như: class student { String name; . . . String getName(){ return this.name; } } student Hocsinh1 = new student(); String _name = Hocsinh1.getName(); Khi đoạn code tr&ecirc;n được bi&ecirc;n dịch v&agrave; h&agrave;m getName() được gọi, th&igrave; con trỏ this trong h&agrave;m getName() được hiểu l&agrave; đối tượng Hocsinh1 v&agrave; this.name ch&iacute;nh l&agrave; chỉ định tới thuộc t&iacute;nh name của đối tượng Hocsinh1 đ&oacute;. Cũng giống như đại từ nh&acirc;n xưng trong ng&ocirc;n ngữ n&oacute;i, this đại diện cho đối tượng (object) ở trong một ngữ cảnh (context) được nhắc đến trước đ&oacute;. Ch&uacute;ng ta cũng sẽ b&agrave;n s&acirc;u hơn về kh&aacute;i niệm object v&agrave; context ở những phần tiếp theo xem sao n&agrave;o. Cơ bản về con trỏ this trong Javascript Cần n&oacute;i qua một ch&uacute;t về h&agrave;m (function) ở trong Javascript, như ta đ&atilde; biết th&igrave; trong JS một h&agrave;m cũng ch&iacute;nh l&agrave; một đối tượng (object), v&agrave; đối tượng th&igrave; sẽ c&oacute; những thuộc t&iacute;nh của ri&ecirc;ng n&oacute;. Trong JS, khi một h&agrave;m được gọi, th&igrave; n&oacute; sẽ c&oacute; một thuộc t&iacute;nh l&agrave; this, v&agrave; thuộc t&iacute;nh this n&agrave;y chứa gi&aacute; trị về một đối tượng đang gọi tới h&agrave;m n&agrave;y. Tức l&agrave;, khi một function được gọi (tạm gọi l&agrave; function A), th&igrave; con trỏ this chứa gi&aacute; trị của đối tượng gọi tới A, v&agrave; ta c&oacute; thể th&ocirc;ng qua con trỏ this n&agrave;y để lấy c&aacute;c gi&aacute; trị thuộc t&iacute;nh kh&aacute;c nằm trong đối tượng vừa gọi tới A. var Hocsinh1 = { name: &ldquo;John&rdquo;, getName: function(){ return this.name; } }; var _name = Hocsinh1.getName(); this được khai b&aacute;o trong h&agrave;m getName(), v&agrave; h&agrave;m getName() l&agrave; h&agrave;m sẽ được gọi tới bởi đối tượng Hocsinh1, do đ&oacute; this ở đ&acirc;y được hiểu l&agrave; sẽ mang gi&aacute; trị tham chiếu tới đối tượng Hocsinh1. Tới đ&acirc;y th&igrave; c&aacute;ch d&ugrave;ng con trỏ this trong Javascript l&agrave; tương đồng với c&aacute;c ng&ocirc;n ngữ kh&aacute;c. Tuy nhi&ecirc;n, ch&uacute;ng ta sẽ xem x&eacute;t 4 trường hợp m&agrave; con trỏ this trở n&ecirc;n mơ hồ hơn so với v&iacute; dụ ở tr&ecirc;n: Con trỏ this trong việc sử dụng h&agrave;m callback Con trỏ this b&ecirc;n trong closure Con trỏ this trong trường hợp g&aacute;n h&agrave;m cho một biến kh&aacute;c Con trỏ this trong h&agrave;m mượn (borrowing methods) 1. Con trỏ this trong sử dụng h&agrave;m callback C&oacute; thể n&oacute;i n&ocirc;m na h&agrave;m callback l&agrave; việc ch&uacute;ng ta truyền 1 h&agrave;m với vai tr&ograve; như một tham số v&agrave;o một h&agrave;m kh&aacute;c để c&oacute; thể k&iacute;ch hoạt h&agrave;m đ&oacute; sau n&agrave;y. X&eacute;t v&iacute; dụ sau: //Định nghĩa 1 đối tượng với phương thức hiển thị thuộc t&iacute;nh ra m&agrave;n h&igrave;nh var Hocsinh = { name: &ldquo;John&rdquo;, printName: function(){ console.log(this.name); } }; //Bắt sự kiện click chuột l&ecirc;n button, sẽ thực thi h&agrave;m hiển thị t&ecirc;n của Hocsinh l&ecirc;n m&agrave;n h&igrave;nh $(&lsquo;button&rsquo;).click(Hocsinh.printName); //kq: undefined Khi người d&ugrave;ng click chuột v&agrave;o button th&igrave; h&agrave;m printName() sẽ được gọi để hiển thị t&ecirc;n của Hocsinh l&ecirc;n m&agrave;n h&igrave;nh. Tuy nhi&ecirc;n đoạn code tr&ecirc;n sẽ kh&ocirc;ng thể chạy đ&uacute;ng như mong muốn. L&iacute; do bởi v&igrave; khi sự kiện click được k&iacute;ch hoạt, th&igrave; sự kiện n&agrave;y đang được g&aacute;n tới đối tượng $(&lsquo;button&rsquo;). Do đ&oacute; khi h&agrave;m Hocsinh.printName() được k&iacute;ch hoạt, con trỏ this đang tham chiếu tới $(&lsquo;button&rsquo;) chứ kh&ocirc;ng phải đối tượng Hocsinh, dẫn tới việc gọi this.name l&agrave; v&ocirc; nghĩa. Để đoạn code tr&ecirc;n chạy đ&uacute;ng như mong muốn &ndash; in ra được name của Hocsinh &ndash; th&igrave; ta phải đảm bảo được context của h&agrave;m callback Hocsinh.printName l&agrave; ch&iacute;nh đối tượng Hocsinh l&uacute;c h&agrave;m n&agrave;y được gọi. Cụ thể trong trường hợp n&agrave;y ch&uacute;ng ta c&oacute; thể d&ugrave;ng h&agrave;m Bind() để gắn context v&agrave;o h&agrave;m callback đ&oacute;. //Thay v&igrave; viết $(&lsquo;button&rsquo;).click( Hocsinh.printName ); //Ch&uacute;ng ta sẽ viết $(&lsquo;button&rsquo;).click( Hocsinh.printName.Bind( Hocsinh ) ); Gợi &yacute;: mọi người c&oacute; thể t&igrave;m hiểu th&ecirc;m về h&agrave;m Apply() v&agrave; Call(), cũng d&ugrave;ng để thay đổi context trong JS. 2. Con trỏ this trong closure N&oacute;i một c&aacute;ch ngắn gọn th&igrave; closure l&agrave; một h&agrave;m con (inner function) nằm b&ecirc;n trong 1 h&agrave;m kh&aacute;c (outer function). Ta đ&atilde; biết rằng closure th&igrave; kh&ocirc;ng thể truy cập tới con trỏ this của h&agrave;m cha (outer function), do đ&oacute; sẽ c&oacute; thể xuất hiện trường hợp như sau: var user = { tournament:&quot;The Masters&quot;, data: [ {name:&quot;T. Woods&quot;, age:37}, {name:&quot;P. Mickelson&quot;, age:43} ], clickHandler: function () { //Sử dụng con trỏ this ở đ&acirc;y th&igrave; OK, this đang mang gi&aacute; trị tham chiếu tới đối tượng &ldquo;user&rdquo; this.data.forEach (function (person) { //Tuy nhi&ecirc;n, trong closure n&agrave;y th&igrave; this kh&ocirc;ng c&ograve;n tham chiếu tới đối tượng &ldquo;user&rdquo; nữa // H&agrave;m inner function n&agrave;y kh&ocirc;ng thể truy cập tới this của outer function console.log (person.name + &quot; is playing at &quot; + this.tournament); }) } } user.clickHandler(); Kết quả của đoạn m&atilde; tr&ecirc;n như sau: //Ch&uacute; &yacute; kết quả undefined T. Woods is playing at undefined P. Mickelson is playing at undefined Để sửa lỗi cho trường hợp n&agrave;y, c&aacute;c javascript developer thường giải quyết bằng việc g&aacute;n gi&aacute; trị của biến this v&agrave;o một biến trung gian trước khi gọi closure: var user = { tournament:&quot;The Masters&quot;, data: [ {name:&quot;T. Woods&quot;, age:37}, {name:&quot;P. Mickelson&quot;, age:43} ], clickHandler: function () { var self = this; // &lt;===== thay đổi ở d&ograve;ng n&agrave;y n&egrave; this.data.forEach (function (person) { //Ta sẽ d&ugrave;ng biến self như một biến b&igrave;nh thường trong h&agrave;m closure console.log (person.name + &quot; is playing at &quot; + self.tournament); }); } } user.clickHandler(); Đoạn code tr&ecirc;n tr&ocirc;ng c&oacute; vẻ k&igrave; lạ đối với những người &iacute;t code bằng Javascript trước đ&acirc;y, tuy nhi&ecirc;n đ&acirc;y l&agrave; một t&igrave;nh huống xảy ra kh&aacute; thường xuy&ecirc;n trong Javascript. 3. Con trỏ this trong trường hợp g&aacute;n h&agrave;m cho một biến kh&aacute;c Trường hợp ta g&aacute;n h&agrave;m cho một biến kh&aacute;c, cũng sẽ xảy ra t&igrave;nh trạng thay đổi context của h&agrave;m nếu được gọi. Ta x&eacute;t v&iacute; dụ sau: //Định nghĩa 1 đối tượng với phương thức hiển thị thuộc t&iacute;nh ra m&agrave;n h&igrave;nh var name = &ldquo;Peter&rdquo;; var Hocsinh = { name: &ldquo;John&rdquo;, printName: function(){ console.log(this.name); } }; //G&aacute;n h&agrave;m Hocsinh.printName v&agrave;o một biến Var printHocsinhName = Hocsinh.printName; //Gọi h&agrave;m printHocsinhName để hiển thị t&ecirc;n học sinh printHocsinhName(); //kết quả: Peter (nhưng mong muốn l&agrave; ra John m&agrave;???) Cũng tương tự như c&aacute;c trường hợp đ&atilde; ph&acirc;n t&iacute;ch ở tr&ecirc;n, context của h&agrave;m Hocsinh.printName đ&atilde; bị thay đổi khi ta thực hiện g&aacute;n h&agrave;m cho đối tượng kh&aacute;c. Để giữ nguy&ecirc;n được context l&agrave; biến Hocsinh th&igrave; ta sẽ sửa lại code như sau: //G&aacute;n h&agrave;m Hocsinh.printName v&agrave;o một biến Var printHocsinhName = Hocsinh.printName.bind(Hocsinh); //Gọi h&agrave;m printHocsinhName để hiển thị t&ecirc;n học sinh printHocsinhName(); //kết quả: John Nhớ sử dụng bind() để g&aacute;n đ&uacute;ng context nh&eacute;. 4. Con trỏ this trong h&agrave;m mượn (borrowing methods) H&agrave;m mượn (borrowing method) l&agrave; một trong những kh&aacute;i niệm độc đ&aacute;o của Javascript. Để hiểu r&otilde; được n&oacute; c&oacute; lẽ cần th&ecirc;m một b&agrave;i viết ri&ecirc;ng, tuy nhi&ecirc;n m&igrave;nh sẽ đưa ra v&iacute; dụ về việc n&oacute; thay đổi context của con trỏ this như thế n&agrave;o. X&eacute;t v&iacute; dụ sau: // Ch&uacute;ng ta c&oacute; 2 đối tượng, 1 đối tượng c&oacute; h&agrave;m computeAvg() v&agrave; 1 đối tượng th&igrave; kh&ocirc;ng // Ch&uacute;ng ta sẽ thực hiện mượn h&agrave;m n&agrave;y var gameController = { scores: [10, 15, 20], avgScore: null, players: [ {name: &quot;Tommy&quot;, playerID: 987, age: 23}, {name: &quot;Pau&quot;, playerID: 87, age: 33} ] }; var appController = { scores: [30, 40, 50], avgScore: null, computeAvg: function () { var sumOfScores = this.scores.reduce (function (prev, cur, index, array) { return prev + cur; }); this.avgScore = sumOfScores / this.scores.length; } }; Ta muốn mượn h&agrave;m computeAvg() của đối tượng appController để t&iacute;nh điểm trung b&igrave;nh cho đối tượng gameController. Muốn l&agrave;m được điều n&agrave;y ta cần phải thay đổi context của h&agrave;m computeAvg() sang th&agrave;nh đối tượng gameController khi chạy, h&agrave;m apply() trong JS sẽ gi&uacute;p ta l&agrave;m được điều n&agrave;y: appController.computeAvg.apply(gameController); console.log(gameController.avgScore); Như vậy ta vừa thực hiện d&ugrave;ng h&agrave;m mượn (borrowing method) v&agrave; thay đổi context để thực hiện. Tổng kết Qua v&agrave;i chia sẻ tr&ecirc;n đ&acirc;y, hi vọng mọi người c&oacute; thể hiểu r&otilde; hơn về con trỏ this trong lập tr&igrave;nh Javascript. Ch&uacute;ng ta c&oacute; trong tay c&aacute;c c&ocirc;ng cụ l&agrave; c&aacute;c h&agrave;m như apply(), bind(), call() để kiểm so&aacute;t con trỏ this trong nhiều t&igrave;nh huống kh&aacute;c nhau. Bạn c&oacute; thể xem th&ecirc;m về những thứ đ&oacute; ở Đ&Acirc;Y. Quy tắc cốt l&otilde;i cần nhớ khi l&agrave;m việc với con trỏ this l&agrave;: lu&ocirc;n ch&uacute; tới context của con trỏ this khi h&agrave;m được gọi, đảm bảo ch&uacute;ng ta đang sử dụng đ&uacute;ng context của h&agrave;m như &yacute; muốn. Ch&uacute;c th&agrave;nh c&ocirc;ng. Th&acirc;n!</p>\n",
      "total_views": 456,
      "status": true,
      "tags": [
        "Programing", "Javascript", "Pointer"
      ]
    },
    {
      "title": "Xây dựng ứng dụng realtime messaging bằng Firebase xử lí 100k request/s",
      "content": "<p>Hiện nay c&aacute;c ứng dụng live stream mọc l&ecirc;n như nấm, một trong số đ&oacute; c&oacute; thể được kể đến như Bigo, Facebook live, Tiktok, Youtube &hellip; Trong khi live stream th&igrave; người d&ugrave;ng c&oacute; thể thả tim, like, comment &hellip; V&agrave; tất cả những chức năng đ&oacute; ho&agrave;n to&agrave;n l&agrave; realtime. Vậy l&agrave;m thế n&agrave;o c&oacute; thể l&agrave;m được t&iacute;nh năng realtime như thế? V&agrave; c&oacute; thể xử l&iacute; được h&agrave;ng triệu, h&agrave;ng tỉ request/s như vậy chắc cũng nhiều người quan t&acirc;m, v&agrave; bản th&acirc;n m&igrave;nh cũng thế. Cũng muốn vọc vạch xem c&ocirc;ng nghệ đằng sau những ứng dụng đ&oacute; như thế n&agrave;o. Trong l&uacute;c t&igrave;m hiểu th&igrave; đọc thấy 1 b&agrave;i rất hay m&agrave; kĩ sư Mercari đ&atilde; chia sẻ. V&agrave; b&ecirc;n họ sử dụng Firebase Realtime Database để giải quyết b&agrave;i to&aacute;n n&agrave;y. C&ugrave;ng nhau t&igrave;m hiểu xem cụ thể sẽ l&agrave;m như thế n&agrave;o để c&oacute; thể x&acirc;y dựng được ứng dụng realtime messaging xử l&iacute; được h&agrave;ng tỉ request/s như vậy. Phạm vi b&agrave;i to&aacute;n H&igrave;nh ảnh b&ecirc;n tr&ecirc;n m&igrave;nh chụp được th&ocirc;ng qua ứng dụng Bigo (thi thoảng ngắm g&aacute;i :D). Ai d&ugrave;ng Bigo hay Facebook live rồi cũng đều biết ngo&agrave;i t&iacute;nh năng live stream ra th&igrave; c&ograve;n 1 v&agrave;i t&iacute;nh năng kh&aacute;c nữa như gửi comment, like, gửi tim, tặng coin &hellip; V&agrave; tất cả những thứ n&agrave;y đều realtime. N&ecirc;n h&ocirc;m nay m&igrave;nh chỉ tập trung v&agrave;o những t&iacute;nh năng realtime như comment, like, gửi tim &hellip; Firebase Realtime Database l&agrave; g&igrave;? L&agrave; sản phẩm của Google (ch&iacute;nh x&aacute;c l&agrave; được Google mua lại) L&agrave; cơ sở dữ liệu NoSQL được lưu trữ v&agrave; quản l&iacute; tr&ecirc;n đ&aacute;m m&acirc;y. Dữ liệu được lưu đưới dạng JSON. Client c&oacute; thể subscribe dữ liệu 1 c&aacute;ch realtime. Tại thời điểm hiện tại (2019/07/06) th&igrave; firebase realtime database xử l&iacute; được 1 triệu request đồng thời v&agrave; 10k write/s. Tương lai số lượng n&agrave;y c&oacute; thể tăng l&ecirc;n. Số liệu tham khảo ở đ&acirc;y. Ngo&agrave;i t&iacute;nh năng của 1 database ra th&igrave; n&oacute; c&ograve;n c&oacute; 1 số t&iacute;nh năng kh&aacute;c nữa như: T&iacute;nh năng Authentication th&ocirc;ng qua Facebook, Google, Twitter &hellip; C&oacute; thể c&agrave;i đặt rule để ph&acirc;n quyền xem ai được read, write đến resource của database. V&iacute; dụ như ai login mới c&oacute; quyền read, write chẳng hạn. Bởi v&igrave; Firebase được d&ugrave;ng ở ph&iacute;a client (web, mobile) n&ecirc;n việc decode để lấy ra key của firebase l&agrave; điều ho&agrave;n to&agrave;n dễ d&agrave;ng. Do đ&oacute; nếu kh&ocirc;ng c&agrave;i đặt rule 1 c&aacute;ch cẩn thận th&igrave; c&oacute; thể sẽ bị b&ecirc;n thứ 3 read, write t&agrave;i nguy&ecirc;n 1 c&aacute;ch dễ d&agrave;ng. Kiến tr&uacute;c hệ thống Kiến tr&uacute;c kh&aacute; l&agrave; simple phải kh&ocirc;ng n&agrave;o. B&acirc;y giờ m&igrave;nh sẽ đi giải th&iacute;ch từng bộ phận trong kiến tr&uacute;c n&agrave;y. Đầu ti&ecirc;n khi người d&ugrave;ng thực hiện comment, like th&igrave; khi đ&oacute; sẽ gửi request đến API Server để xử l&iacute;. Tại sao ở bước n&agrave;y kh&ocirc;ng gửi trực tiếp đến Firebase m&agrave; phải th&ocirc;ng qua API Server để l&agrave;m g&igrave;? Bởi v&igrave; ngo&agrave;i mục đ&iacute;ch insert data đến firebase database c&ograve;n c&oacute; 1 số nhiệm vụ kh&aacute; quan trọng kh&aacute;c nữa như authentication người d&ugrave;ng, detect tấn c&ocirc;ng x&acirc;m nhập &hellip; N&ecirc;n việc xử l&iacute; những logic phức tạp đ&oacute; bắt buộc phải th&ocirc;ng qua API Server. Sau khi API Server nhận được request từ ph&iacute;a người d&ugrave;ng. Khi đ&oacute; n&oacute; sẽ thực hiện việc chuyển data đ&oacute; v&agrave;o queue để xử l&iacute; th&ocirc;ng qua worker. Worker sẽ lấy dữ liệu từ queue ra v&agrave; thực hiện insert data đến Firebase th&ocirc;ng qua REST API của Firebase. Tại sao từ API Server kh&ocirc;ng gửi data trực tiếp đến Firebase? Ch&uacute;ng ta h&atilde;y lu&ocirc;n lu&ocirc;n nhớ 1 điều l&agrave; ngo&agrave;i m&igrave;nh ra kh&ocirc;ng bao giờ được tin tưởng bất k&igrave; thằng n&agrave;o cả (Don&rsquo;t trust each other). Nếu API Server gửi request trực tiếp đến Firebase th&igrave; c&oacute; vấn đề g&igrave; xảy ra ở đ&acirc;y? Chẳng may l&uacute;c n&agrave;y firebase database bị down. Khi đ&oacute; API Server sẽ kh&ocirc;ng thể gửi request được nữa v&agrave; c&oacute; thể g&acirc;y ra lỗi. Khi đ&oacute; ph&iacute;a client cũng bị lỗi theo. V&agrave; l&agrave;m cho trải nghiệm người d&ugrave;ng bị gi&aacute;n đoạn. Do đ&oacute; mới th&ocirc;ng qua queue để xử l&iacute;. Nếu m&agrave; Firebase Database c&oacute; bị down đi chăng nữa th&igrave; job đ&oacute; sẽ bị failed v&agrave; sẽ được retries lại ngay sau đ&oacute;. Hơn nữa nhờ cơ chế work-queue n&agrave;y gi&uacute;p ch&uacute;ng ta scalable kh&aacute; tốt ở chỗ n&agrave;y. Về Queue th&igrave; hiện nay c&oacute; rất nhiều như Kafka, Q4M &hellip; Về c&aacute; nh&acirc;n m&igrave;nh th&iacute;ch nhất thằng Kafka v&igrave; n&oacute; lu&ocirc;n lu&ocirc;n đảm bảo đ&uacute;ng thứ tự xử l&iacute;. V&agrave; hơn nữa n&oacute; lại ph&acirc;n t&aacute;n nữa n&ecirc;n t&iacute;nh mở rộng của n&oacute; kh&aacute; l&agrave; cao. V&agrave; cuối c&ugrave;ng ph&iacute;a Client chỉ cần Subscribe event từ Firebase Realtime Database l&agrave; c&oacute; thể nhận dữ liệu 1 c&aacute;ch realtime rồi. Ở bước n&agrave;y ch&uacute;ng ta sẽ kh&ocirc;ng xử l&iacute; g&igrave; cả v&agrave; chỉ cho hiển thị dữ liệu th&ocirc;i. Như thế tốc độ sẽ kh&aacute; l&agrave; nhanh. Về t&iacute;nh mở rộng của Firebase Realtime Database Đầu ti&ecirc;n m&igrave;nh muốn nhấn mạnh 1 điều l&agrave; Firebase Realtime Database kh&ocirc;ng thể scale up với scale out được nh&eacute;. Do đ&oacute; trước khi đưa n&oacute; v&agrave;o hệ thống th&igrave; ch&uacute;ng ta cần test tải kĩ c&agrave;ng trước xem cần bao nhi&ecirc;u con database th&igrave; hợp l&iacute;, dựa v&agrave;o tuỳ t&igrave;nh h&igrave;nh m&agrave; sẽ tiến h&agrave;nh sharding để đ&aacute;p ứng được số lượng request đề ra. Như phần tr&ecirc;n m&igrave;nh c&oacute; n&oacute;i, firebase realtime database hiện tại chỉ cho ph&eacute;p 1 triệu request đồng thời v&agrave; 10k write/s. Do đ&oacute; để kh&ocirc;ng vượt qu&aacute; ngưỡng n&agrave;y th&igrave; sharding l&agrave; điều ho&agrave;n to&agrave;n cần thiết. Ch&uacute;ng ta sẽ sharding database theo liveID. Như trong v&iacute; dụ tr&ecirc;n th&igrave; với live_id=1 v&agrave; 4 sẽ cho trong db1, live_id = 2 v&agrave; 5 sẽ cho trong db2, v&agrave; live_id=3 v&agrave; 6 sẽ cho trong db3 Nếu chia như thế th&igrave; ch&uacute;ng ta c&oacute; thể xử l&iacute; được 3 triệu request đồng thời v&agrave; 30k write/s. Ở đ&acirc;y c&oacute; 1 điểm chắc nhiều người cũng đang thắc mắc. V&iacute; dụ live_id=1 (của 1 em g&aacute;i xinh xắn n&agrave;o đ&oacute;) c&oacute; tới h&agrave;ng triệu anh v&agrave;o xem live v&agrave; comment. Nếu số lượng request đ&oacute; vượt qu&aacute; 1 triệu th&igrave; sẽ bị block lại v&agrave; kh&ocirc;ng gửi đc nữa. V&iacute; dụ như ai đ&oacute; thả tim li&ecirc;n tục chăng hạn &hellip; Vậy ở chỗ n&agrave;y n&ecirc;n l&agrave;m thế n&agrave;o để c&oacute; thể hạn chế được điều đ&oacute;? C&oacute; 1 solution kh&aacute; đơn giản. V&iacute; dụ như chức năng like chẳng hạn. Khi ấn like ch&uacute;ng ta sẽ kh&ocirc;ng send ngay đến firebase m&agrave; sẽ đợi khoảng 10s sau đ&oacute; mới send chẳng hạn. (Cứ miễn l&agrave;m sao m&agrave; kh&ocirc;ng l&agrave;m giảm trải nghiệm của người d&ugrave;ng l&agrave; được). Để thực hiện được logic n&agrave;y ch&uacute;ng ta c&oacute; thể sử dụng Redis hoặc memcached để lưu lại live_id với timestamp tương ứng. Sau khoảng 10s từ l&uacute;c insert v&agrave;o redis th&igrave; sẽ kh&ocirc;ng l&agrave;m g&igrave; cả, sau 10s th&igrave; sẽ insert data đến firebase. $memcachd = new \\Sample\\MemcachedClient(); $firebase_client = new \\Sample\\FirebaseClient(); $like_counter = new \\Sample\\LikeCounter(); $live_id = \\HttpParameter::get(&#39;live_id&#39;); $like_count = $like_counter-&gt;increment($live_id); if ($memcached-&gt;get(&#39;key-prefix-like-&#39; . $live_id)) { // Skip } else { $firebase_client-&gt;updateLikeCount($like_count); $memcached-&gt;add(&#39;key-prefix-like-&#39; . $live_id, true, 10); // 10s } Ngo&agrave;i ra m&igrave;nh nhấn mạnh 1 điều l&agrave; do Firebase được d&ugrave;ng ph&iacute;a client (như web, mobile) n&ecirc;n việc lộ key của firebase l&agrave; điều kh&ocirc;ng thể tr&aacute;nh khỏi. Do đ&oacute; việc c&agrave;i đặt rule để ph&acirc;n quyền người d&ugrave;ng access đến resource l&agrave; điều v&ocirc; c&ugrave;ng cần thiết v&agrave; ở b&agrave;i n&agrave;y m&igrave;nh sẽ kh&ocirc;ng đi s&acirc;u v&agrave;o nữa. Mọi người c&oacute; thể t&igrave;m hiểu th&ecirc;m về Firebase Realtime Database Rule ở đ&acirc;y nh&eacute;. Như h&igrave;nh ảnh b&ecirc;n tr&ecirc;n l&agrave; 1 v&iacute; dụ về lộ key firebase ở ph&iacute;a javascript. Kết luận Theo như c&aacute;c anh Mercari chia sẻ th&igrave; sau khi release t&iacute;nh năng live stream đ&oacute; th&igrave; đến b&acirc;y giờ cũng được 2 năm rồi m&agrave; chưa lần n&agrave;o Firebase bị down cả. Firebase quả thực rất mạnh. Nếu ai muốn dev thật nhanh hoặc muốn l&agrave;m bản prototype th&igrave; c&oacute; lẽ Firebase l&agrave; 1 sự lựa chọn đ&uacute;ng đắn. Với loại truyền thống th&igrave; ch&uacute;ng ta sẽ cần phải c&oacute; DB, v&agrave; chuẩn bị API ph&iacute;a backend để thao t&aacute;c với dữ liệu trong DB. Nhưng Firebase th&igrave; kh&aacute;c, n&oacute; cung cấp cho ta DB v&agrave; API để thao t&aacute;c đến DB rồi. Do đ&oacute; kh&ocirc;ng cần phải dev API l&agrave;m g&igrave; cho mệt. Cứ d&ugrave;ng Firebase SDK l&agrave; xong. Ngo&agrave;i ra m&igrave;nh nhấn mạnh 1 điều l&agrave; do Firebase được d&ugrave;ng ph&iacute;a client (như web, mobile) n&ecirc;n việc lộ key của firebase l&agrave; điều kh&ocirc;ng thể tr&aacute;nh khỏi. Do đ&oacute; việc c&agrave;i đặt rule để ph&acirc;n quyền người d&ugrave;ng access đến resource l&agrave; điều v&ocirc; c&ugrave;ng cần thiết v&agrave; ở b&agrave;i n&agrave;y m&igrave;nh sẽ kh&ocirc;ng đi s&acirc;u v&agrave;o nữa. Mọi người c&oacute; thể t&igrave;m hiểu th&ecirc;m về Firebase Realtime Database Rule ở đ&acirc;y nh&eacute;. Hiện tại sắp tới c&ocirc;ng ty m&igrave;nh cũng đang chuẩn bị l&agrave;m 1 service mới v&agrave; sếp y&ecirc;u cầu 2 th&aacute;ng phải xong. Team m&igrave;nh cũng quyết định chọn Firebase cho giải ph&aacute;p lần n&agrave;y. Nguồn: https://nghethuatcoding.com/2019/07/07/xay-dung-ung-dung-realtime-messaging-bang-firebase-xu-li-100k-request-s/</p>\n",
      "total_views": 456,
      "status": true,
      "tags": [
        "Firebase", "Application", "Realtime"
      ]
    },
    {
      "title": "Discord đã lưu trữ hàng tỉ messages mỗi ngày như thế nào",
      "content": "<p>M&igrave;nh biết đến Discord c&aacute;ch đ&acirc;y khoảng 2 năm, tại thời điểm m&agrave; gi&aacute; bitcoin tăng khủng khiếp ấy. Khi đ&oacute; kh&ocirc;ng biết mọc ở đ&acirc;u lắm thầy ph&aacute;n bitcoin qu&aacute;, k&eacute;o theo c&ugrave;ng c&aacute;c group cho k&egrave;o (thu ph&iacute;) tr&ecirc;n Discord cũng dần dần mọc ra từ đ&oacute;. Kh&ocirc;ng chỉ c&aacute;c anh t&acirc;y l&ocirc;ng m&agrave; ngay cả Việt Nam m&igrave;nh cũng rất nhiều. M&agrave; th&ocirc;i đi v&agrave;o vấn đề ch&iacute;nh đ&atilde;. Về số lượng messages tr&ecirc;n Discord theo thống k&ecirc; như sau: v&agrave;o th&aacute;ng 7 năm 2017, số lượng messages 1 ng&agrave;y l&agrave; 40 triệu. Nhưng đến th&aacute;ng 12 th&igrave; đ&atilde; đạt 120 triệu messages 1 ng&agrave;y. Sự tăng trưởng kh&aacute; l&agrave; nhanh chỉ trong v&ograve;ng 5 th&aacute;ng. V&agrave; đến b&acirc;y giờ chắc phải hơn 1 tỉ messages 1 ng&agrave;y. Vậy c&ugrave;ng nhau đi t&igrave;m hiểu xem họ đ&atilde; lưu đống messages khổng lồ đ&oacute; như thế n&agrave;o nh&eacute;. Bối cảnh Discord l&agrave; 1 ứng dụng chat. N&oacute; giống như slack ấy. Cũng tạo được team, group ri&ecirc;ng. Ph&acirc;n quyền người d&ugrave;ng, gọi điện, gửi tin nhắn, cung cấp API đủ cả. Discord được ra đời đầu ti&ecirc;n v&agrave;o năm 2015, v&agrave; họ chỉ code trong v&ograve;ng đ&uacute;ng 2 th&aacute;ng (2 th&aacute;ng code xong cũng thấy pro thật). Khi đ&oacute; họ sử dụng MongoDB để lưu trữ dữ liệu. Tại thời điểm n&agrave;y họ chỉ lưu dữ liệu tr&ecirc;n 1 replica MongoDB duy nhất th&ocirc;i, v&agrave; kh&ocirc;ng muốn sử dụng sharding trong MongoDB v&igrave; n&oacute; qu&aacute; phức tạp, 1 phần v&igrave; bản th&acirc;n Discord cũng kh&ocirc;ng chắc chắn về mức độ ổn định của n&oacute;. C&ograve;n 1 điều m&igrave;nh thấy kh&aacute; th&uacute; vị về Discord đ&oacute; l&agrave; về văn ho&aacute; c&ocirc;ng ty: L&agrave;m thế n&agrave;o th&igrave; l&agrave;m nhưng service phải được build thật nhanh để tung ra thị trường, xem phản ứng của người d&ugrave;ng. Tuy nhi&ecirc;n cũng cần phải c&oacute; 1 đường lui đến 1 solution mạnh mẽ hơn. C&ocirc;ng ty m&igrave;nh cũng đang đi theo hướng n&agrave;y. Cũng build thật nhanh, v&agrave; lu&ocirc;n lu&ocirc;n c&oacute; giải ph&aacute;p c&ocirc;ng nghệ tốt hơn khi đối mặt với big data. Về messages được lưu trong collection của MongoDB với bộ index l&agrave; channel_id v&agrave; created_at. Giai đoạn đầu với dữ liệu c&ograve;n nhỏ, MongoDB chạy kh&aacute; l&agrave; mượt m&agrave;. Tuy nhi&ecirc;n, v&agrave;o đầu th&aacute;ng 12 khi dữ liệu messages đạt đến 120 triệu messages tr&ecirc;n 1 ng&agrave;y th&igrave; đ&atilde; xảy ra 1 số vấn đề như sau: data v&agrave; index kh&ocirc;ng thể fit đầy v&agrave;o RAM (dữ liệu to thế m&agrave; chỉ d&ugrave;ng 1 node th&igrave; kh&oacute; c&oacute; thể fit đầy RAM được) Thời gian latency bắt đầu k&eacute;o d&agrave;i ra. Đ&atilde; đến l&uacute;c cần phải chuyển sang 1 database mới ph&ugrave; hợp hơn với logic hiện tại. Vấn đề đang gặp phải Phần voice chat l&agrave;m server chịu tải kh&aacute; lớn, đến nỗi kh&ocirc;ng thể gửi được message. số lượng message loại n&agrave;y chỉ tầm khoảng 1k messages mỗi năm. Kh&aacute; l&agrave; &iacute;t. Phần private message (trong group private) cũng l&agrave;m kh&aacute; nặng server. Loại messages n&agrave;y mỗi năm đạt từ 100k đến 1 triệu messages. C&aacute;c group private n&agrave;y c&oacute; số lượng member kh&ocirc;ng nhiều, chỉ tầm 100 member th&ocirc;i. C&aacute;c message trong public group th&igrave; được gửi kh&aacute; l&agrave; nhiều. C&aacute;c public group n&agrave;y c&oacute; số lượng th&agrave;nh vi&ecirc;n lớn hơn, tầm khoảng 1000 người. Tổng messages trong 1 năm khoảng 1 triệu v&agrave; gửi thường xuy&ecirc;n hơn. Y&ecirc;u cầu về mặt hệ thống Khi chọn database mới th&igrave; cần phải đ&aacute;p ứng được những y&ecirc;u cầu sau: Khả năng mở rộng Chịu lỗi tốt Kh&ocirc;ng mất nhiều c&ocirc;ng trong qu&aacute; tr&igrave;nh bảo tr&igrave; Đ&atilde; c&oacute; nhiều c&ocirc;ng ty lớn d&ugrave;ng C&oacute; thể dự đo&aacute;n được hiệu năng. Kh&ocirc;ng muốn cache message trong Redis hay Memcached. Open source (muốn tự m&igrave;nh control được hệ thống m&agrave; kh&ocirc;ng phải phụ thuộc v&agrave;o b&ecirc;n thứ 3) Từ những y&ecirc;u cầu tr&ecirc;n th&igrave; chỉ c&oacute; Cassandra l&agrave; ph&ugrave; hợp nhất. Cassandra c&oacute; thể dễ d&agrave;ng th&ecirc;m, xo&aacute; node để tăng hiệu năng. V&agrave; c&aacute;c node đồng bộ dữ liệu với nhau th&ocirc;ng qua cơ chế P2P (peer to peer) n&ecirc;n khi 1 node c&oacute; bị chết đi chăng nữa th&igrave; c&aacute;c node kh&aacute;c vẫn chứa dữ liệu n&ecirc;n độ chịu lỗi kh&aacute; cao. Ngo&agrave;i ra c&ograve;n c&oacute; c&aacute;c c&ocirc;ng ty lớn đang d&ugrave;ng như Netflix, Apple, Facebook, Twitter với h&agrave;ng ngh&igrave;n node n&ecirc;n c&oacute; thể tự tin về hiệu năng của n&oacute;. Nếu bạn n&agrave;o chưa biết về Cassandra th&igrave; c&oacute; thể tham khảo tại đ&acirc;y. Data Modeling Cơ chế tổ chức data trong Cassandra như sau: Được tổ chức dưới dạng KKV (key key value) store. Trong đ&oacute;, tổ hợp của 2 chữ K n&agrave;y l&agrave; kho&aacute; ch&iacute;nh: Chữ K đầu ti&ecirc;n l&agrave; partition key. Partition gồm nhiều row, mỗi row được định danh bởi K thứ 2 (được gọi l&agrave; cluster key). Cluster key n&agrave;y cũng đ&oacute;ng vai tr&ograve; l&agrave; kho&aacute; ch&iacute;nh trong partition. Message được index trong MongoDB sử dụng channel_id v&agrave; created_at. Trong đ&oacute; channel_id l&agrave; partition key bởi v&igrave; tất quả query đều thao t&aacute;c trong channel. Nhưng m&agrave; created_at kh&ocirc;ng thể l&agrave; cluster key được v&igrave; c&oacute; thể 2 message đều được tạo ra c&ugrave;ng thời điểm. Nhưng thật may mỗi ID trong Discord lu&ocirc;n lu&ocirc;n duy nhất (v&igrave; sử dụng cơ chế Snowflake của twitter). Khi đ&oacute; kho&aacute; ch&iacute;nh sẽ trở th&agrave;nh (channel_id, message_id). Trong đ&oacute; message_id ch&iacute;nh l&agrave; snowflake. Điều đ&oacute; gi&uacute;p ta dễ d&agrave;ng lấy được message dựa v&agrave;o channel_id. Khi đ&oacute; cấu tr&uacute;c bảng messages sẽ như sau: CREATE TABLE messages ( channel_id bigint, message_id bigint, author_id bigint, content text, PRIMARY KEY (channel_id, message_id) ) WITH CLUSTERING ORDER BY (message_id DESC); Khi import data from MongoDB sang Cassandra th&igrave; gặp phải 1 vấn đề sau. Đ&oacute; l&agrave; xuất hiện cảnh b&aacute;o k&iacute;ch thước partition đ&atilde; vượt qu&aacute; 100MB. (C&oacute; lẽ dữ liệu trong 1 partition c&oacute; k&iacute;ch thước lớn kh&ocirc;ng được ph&acirc;n t&aacute;n sang c&aacute;c cluster b&ecirc;n cạnh n&ecirc;n bị cảnh b&aacute;o n&agrave;y chăng?) Do đ&oacute; m&agrave; cần chia nhỏ dữ liệu ra để fit vừa 100MB. Họ kiểm tra 1 channel to nhất Discord thấy messages trong 10 ng&agrave;y sẽ c&oacute; k&iacute;ch thước tầm 100MB. Do đ&oacute; quyết định cho messages v&agrave;o từng bucket với khoảng thời gian l&agrave; 10 ng&agrave;y. Cụ thể như sau: DISCORD_EPOCH = 1420070400000 // thời điểm l&uacute;c 12:00 1/1/2015 BUCKET_SIZE = 1000 * 60 * 60 * 24 * 10 // tin nhắn trong 10 ng&agrave;y def make_bucket(snowflake): if snowflake is None: timestamp = int(time.time() * 1000) - DISCORD_EPOCH else: # When a Snowflake is created it contains the number of # seconds since the DISCORD_EPOCH. timestamp = snowflake_id &gt;&gt; 22 return int(timestamp / BUCKET_SIZE) def make_buckets(start_id, end_id=None): return range(make_bucket(start_id), make_bucket(end_id) + 1) Khi đ&oacute; primary key sẽ trở th&agrave;nh: ((channel_id, bucket), message_id) CREATE TABLE messages ( channel_id bigint, bucket int, message_id bigint, author_id bigint, content text, PRIMARY KEY ((channel_id, bucket), message_id) ) WITH CLUSTERING ORDER BY (message_id DESC); Để query lấy messages gần đ&acirc;y th&igrave; chỉ cần tạo ra 1 bucket từ current_time cho đến channel_id (v&igrave; channel_id được tạo ra bởi Snowflake, m&agrave; channel thường được tạo trước sau đ&oacute; mới đến message n&ecirc;n c&oacute; thể coi channel_id như message đầu ti&ecirc;n). V&agrave; ch&uacute;ng ta sẽ query tuần tự trong partition để lấy đủ message th&igrave; th&ocirc;i. Hiệu năng Quả đ&uacute;ng như đồn đại, tốc độ write lu&ocirc;n lu&ocirc;n nhanh hơn tốc độ read. Write mất khoảng 0.5ms trong khi read mất tầm khoảng 5ms. Mặc d&ugrave; read chậm hơn thật nhưng m&agrave; chỉ mất đến milisecond th&igrave; vẫn nhanh ch&aacute;n. Đ&acirc;y l&agrave; kết quả khi muốn xem 1 tin nhắn c&aacute;ch đ&acirc;y 1 năm. Kết quả b&ecirc;n tr&ecirc;n được test ở trong 1 channel to nhất Discord (c&oacute; tr&ecirc;n 1k th&agrave;nh vi&ecirc;n). Tốc độ quả rất l&agrave; nhanh. 1 điều ngạc nhi&ecirc;n đ&atilde; xảy ra Cassandra hoạt động kh&aacute; su&ocirc;n sẻ suốt 6 th&aacute;ng v&agrave; đến 1 ng&agrave;y c&oacute; 1 việc xảy ra. Họ ph&aacute;t hiện ra 1 k&ecirc;nh mất tầm 20s để load dữ liệu. Tại sao lại load l&acirc;u như vậy? Khi v&agrave;o kiểm tra thấy k&ecirc;nh n&agrave;y chỉ c&ograve;n duy nhất 1 tin nhắn. Kiểm tra thấy admin của channel n&agrave;y đ&atilde; d&ugrave;ng api discord để xo&aacute; h&agrave;ng triệu messages đi. Như ch&uacute;ng ta đ&atilde; biết, việc xo&aacute; dữ liệu trong Cassandra sẽ kh&ocirc;ng như trong Mysql. L&agrave; n&oacute; sẽ kh&ocirc;ng xo&aacute; ngay. M&agrave; n&oacute; sẽ gắn 1 c&aacute;i cờ gọi l&agrave; tombstones đến dữ liệu muốn xo&aacute;. Khi query để lấy dữ liệu, n&oacute; sẽ check xem dữ liệu c&oacute; gắn cờ n&agrave;y kh&ocirc;ng v&agrave; trả về dữ liệu. Do đ&oacute; mặc d&ugrave; channel chỉ c&oacute; 1 message duy nhất m&agrave; phải mất đến 20s để load. Qu&aacute; l&agrave; l&acirc;u. V&agrave; họ đ&atilde; giải quyết bằng c&aacute;ch: Giảm lifespan của tombstones từ 10 ng&agrave;y xuống c&ograve;n 2 ng&agrave;y. V&igrave; họ thực hiện chạy Cassandra repairs v&agrave;o mỗi buổi tối để dọn dẹp dữ liệu, tăng t&iacute;nh nhất qu&aacute;n của hệ thống. Kết luận Qua b&agrave;i n&agrave;y chắc c&aacute;c bạn cũng biết được Cassandra n&oacute; được sử dụng trong c&aacute;c hệ thống big data như thế n&agrave;o. Về Cassandra m&igrave;nh th&iacute;ch nhất l&agrave; t&iacute;nh dễ mở rộng (c&agrave;ng th&ecirc;m node th&igrave; hiệu năng c&agrave;ng cao) v&agrave; mức độ chịu lỗi thấp của n&oacute;. N&ecirc;n nếu bạn n&agrave;o đang c&oacute; &yacute; định đưa Cassandra v&agrave;o hệ thống th&igrave; m&igrave;nh thấy c&oacute; thể sẽ l&agrave; 1 sự lựa chọn đ&uacute;ng đắn. Nguồn: https://nghethuatcoding.com/2019/06/01/discord-da-luu-tru-hang-ti-messages-moi-ngay-nhu-the-nao/</p>\n",
      "total_views": 907,
      "status": true,
      "tags": [
        "Messenger", "Chrome Extension", "Facebook"
      ]
    },
    {
      "title": "Các kĩ sư ZOZO đã tạo ứng dụng Survey realtime xử lý 1000 người đồng thời như thế nào",
      "content": "<p>Chắc hẳn nhiều người cũng đ&atilde; từng l&agrave;m 1 ứng dụng trả lời Survey bằng việc sử dụng thư viện hay service b&ecirc;n thứ 3 như Google Form. Nếu kh&ocirc;ng c&oacute; y&ecirc;u cầu g&igrave; đặc biệt th&igrave; Google Form quả thực qu&aacute; đủ. Nhưng m&agrave; để hiển thị kết quả Survey bằng realtime th&igrave; c&oacute; lẽ Google Form kh&ocirc;ng phải l&agrave; sự lựa chọn hợp l&yacute;. Vậy c&ugrave;ng xem c&aacute;c kĩ sư ZOZO đ&atilde; tạo ra ứng dụng Survey realtime như thế n&agrave;o nh&eacute;. Bối cảnh ZOZO l&agrave; 1 trang web b&aacute;n h&agrave;ng online gần như lớn nhất Nhật Bản. C&ocirc;ng ty được th&agrave;nh lập v&agrave;o năm 1998, đến nay đ&atilde; đạt hơn 1000 nh&acirc;n vi&ecirc;n. Đa số c&aacute;c c&ocirc;ng ty Nhật bản, họ thường tổ chức bữa tiệc tổng kết cuối năm để b&aacute;o c&aacute;o t&igrave;nh h&igrave;nh t&agrave;i ch&iacute;nh, giới thiệu dịch vụ c&ocirc;ng ty đang vận h&agrave;nh đến to&agrave;n thể nh&acirc;n vi&ecirc;n. V&agrave; ZOZO cũng vậy. V&agrave;o buổi tổng kết cuối năm, họ quay video giới thiệu về dịch vụ trong c&ocirc;ng ty. V&agrave; mỗi khi kết th&uacute;c 1 phần n&agrave;o đ&oacute; trong video, họ tổ chức 1 c&aacute;i Survey thăm d&ograve; &yacute; kiến của to&agrave;n bộ nh&acirc;n vi&ecirc;n, v&agrave; sẽ hiển thị kết quả ra m&agrave;n h&igrave;nh 1 c&aacute;ch realtime. V&agrave; c&aacute;i Survey n&agrave;y sẽ được ch&egrave;n v&agrave;o giữa c&aacute;c đoạn trong video. Đ&acirc;y l&agrave; to&agrave;n bộ khung cảnh hội trường l&uacute;c đ&oacute;. C&ocirc;ng ty to c&oacute; kh&aacute;c, hội trường tr&ocirc;ng ho&agrave;nh tr&aacute;ng qu&aacute;. alt text alt text alt text alt text alt text Điều kiện khi thực hiện Survey Trước buổi tổng kết 2 tuần th&igrave; đ&atilde; nhận được 1 số request từ b&ecirc;n admin như sau: Ở hội trường sẽ thực hiện l&agrave;m survey ở tr&ecirc;n web 1 c&aacute;ch realtime, kết quả thống k&ecirc; sẽ hiển thị ngay lập tức tr&ecirc;n m&agrave;n h&igrave;nh hội trường. C&acirc;u trả lời chỉ c&oacute; YES hoặc NO C&oacute; khoảng từ 7 đến 8 c&acirc;u hỏi C&oacute; thể trả lời th&ocirc;ng qua smartphone bằng c&aacute;ch qu&eacute;t m&atilde; QR Code Muốn hiển thị kết quả tr&ecirc;n m&agrave;n h&igrave;nh hội trường với UI dễ nh&igrave;n, bắt mắt. C&acirc;u hỏi v&agrave; c&acirc;u trả lời sẽ thực hiện giữa c&aacute;c đoạn video. Hướng giải quyết Sau khi nhận được 1 số request từ b&ecirc;n admin, c&aacute;c kĩ sư ZOZO đ&atilde; đưa ra 1 số giải ph&aacute;p như sau: D&ugrave;ng tool Polly tr&ecirc;n Slack, mọi người v&agrave;o đ&oacute; trả lời Survey. Rồi th&ocirc;ng qua Slack API sẽ thống k&ecirc; v&agrave; hiển thị kết quả l&ecirc;n m&agrave;n h&igrave;nh. Ở c&ocirc;ng ty cũng c&oacute; người kh&ocirc;ng c&oacute; account slack n&ecirc;n việc thực hiện l&agrave; kh&ocirc;ng thể. =&gt; Loại D&ugrave;ng 1 dịch vụ của b&ecirc;n thứ 3 chuy&ecirc;n về Survey đ&oacute; l&agrave; respon. Nhưng m&agrave; tool n&agrave;y lại kh&ocirc;ng biết l&agrave; c&oacute; thể dễ d&agrave;ng customize được hay kh&ocirc;ng, với cả thời gian lần n&agrave;y chỉ c&oacute; 2 tuần n&ecirc;n c&oacute; thể sẽ kh&ocirc;ng thể l&agrave;m xong ho&agrave;n to&agrave;n được =&gt; Loại Team Frontend đang vận h&agrave;nh zozo sẽ đảm nhiệm. V&igrave; team n&agrave;y đ&atilde; từng c&oacute; kinh nghiệm với Firebase, hơn nữa Firebase c&oacute; thể thống k&ecirc; kết quả realtime. N&ecirc;n team đ&atilde; quyết định chọn Firebase để giải quyết vấn đề n&agrave;y. Tổng kết lại điều kiện khi l&agrave;m Survey Sau khi chọn Firebase l&agrave;m giải ph&aacute;p ch&iacute;nh, th&igrave; m&igrave;nh sẽ tổng hợp lại y&ecirc;u cầu khi l&agrave;m Survey như sau: C&oacute; tổng từ 7 đến 8 c&acirc;u hỏi Ch&egrave;n c&acirc;u hỏi v&agrave;o giữa c&aacute;c đoạn trong video Đ&aacute;p &aacute;n trả lời sẽ c&oacute; 2 lựa chọn l&agrave; YES v&agrave; NO C&oacute; thể quy&eacute;t m&atilde; QR code để hiển thị trang web Survey. Kết quả trả lời Survey sẽ được thống k&ecirc; v&agrave; hiển thị ra m&agrave;n h&igrave;nh hội trường ngay lập tức Khi chuyển sang c&acirc;u hỏi tiếp theo sẽ kh&ocirc;ng reload lại page Việc thay đổi c&acirc;u hỏi sẽ được thực hiện th&ocirc;ng qua m&agrave;n h&igrave;nh quản l&yacute; Tr&ecirc;n smartphone chỉ được trả lời 1 lần duy nhất, v&agrave; kh&ocirc;ng thể xo&aacute; Thời gian trả lời c&acirc;u hỏi l&agrave; 15s (Thời gian hiển thị c&acirc;u hỏi l&agrave; 10s, c&ograve;n 5s sẽ hiển thị count down) Kết quả sẽ hiển thị tỉ lệ phần trăm của YES/NO Những việc cần chuẩn bị Để buổi tổng kết kh&ocirc;ng c&oacute; vấn đề g&igrave; xảy ra, c&aacute;c kĩ sư ZOZO đ&atilde; tổng kết lại quy m&ocirc; hệ thống v&agrave; những việc cần thiết n&ecirc;n chuẩn bị như sau: Số lượng người tham gia: 1000 người Chuẩn bị mạng Internet c&oacute; thể chịu được 1000 người Spec về độ ph&acirc;n giải m&agrave;n h&igrave;nh: 1920&times;1080 Số lượng m&agrave;n h&igrave;nh: 4 m&agrave;n h&igrave;nh Buổi h&ocirc;m đ&oacute; c&oacute; thể demo được kh&ocirc;ng? =&gt; Từ 15:00 c&oacute; thể demo được từ 30~40p Thực hiện việc test tải hệ thống (với quy m&ocirc; l&agrave; 1000 người) Nếu c&oacute; bug xảy ra th&igrave; l&agrave;m thế n&agrave;o? =&gt; Chuẩn bị 1 slide về to&agrave;n c&aacute;c c&acirc;u hỏi, v&agrave; nhờ mọi người l&agrave;m tr&ecirc;n đ&oacute;. Thực hiện test việc hiển thị tr&ecirc;n 1 số loại smartphone C&ocirc;ng nghệ sử dụng V&igrave; team Frontend ZOZO quyết định tự build lấy n&ecirc;n họ đ&atilde; quyết định chọn 1 số c&ocirc;ng nghệ dưới đ&acirc;y: Data Management: Firebase Frontend: Vuejs Animation khi hiển thị kết quả: Tweenmax Design m&agrave;n h&igrave;nh ZOZO đ&atilde; chuẩn bị ra 3 m&agrave;n h&igrave;nh: M&agrave;n h&igrave;nh trả lời c&acirc;u hỏi Mỗi người d&ugrave;ng sẽ trả lời c&acirc;u hỏi tr&ecirc;n smartphone Sẽ enable/disable m&agrave;n h&igrave;nh khi c&acirc;u hỏi bắt đầu v&agrave; kết th&uacute;c M&agrave;n h&igrave;nh kết quả Hiển thị c&acirc;u hỏi v&agrave; kết quả ra m&agrave;n h&igrave;nh M&agrave;n h&igrave;nh quản l&yacute; M&agrave;n h&igrave;nh d&ugrave;ng cho Admin thể thay đổi được c&acirc;u hỏi Khi thay đổi c&acirc;u hỏi th&igrave; cũng setting lu&ocirc;n thời gian kết th&uacute;c c&acirc;u hỏi Setting Firebase Điều kiện: Cần phải c&oacute; t&agrave;i khoản Google. Đầu ti&ecirc;n cần login v&agrave;o trong t&agrave;i khoản Google, sau đ&oacute; từ Firebase Console sẽ tạo ra 1 project. Nhập t&ecirc;n project Check v&agrave;o những mục điều khoản sau đ&oacute; ấn v&agrave;o n&uacute;t Create Project Sau khi tạo xong sẽ đi đến m&agrave;n h&igrave;nh Project Dashboard. Mặc định th&igrave; đang d&ugrave;ng Plan l&agrave; Spark. Với ứng dụng n&agrave;o &iacute;t request th&igrave; m&igrave;nh thấy plan n&agrave;y cũng đủ d&ugrave;ng. Nhưng m&agrave; do quy m&ocirc; lần n&agrave;y l&agrave; 1000 người, n&ecirc;n để an to&agrave;n ZOZO đ&atilde; quyết định d&ugrave;ng plan Blaze (Pay as you go &ndash; d&ugrave;ng đến đ&acirc;u trả tiền đến đ&oacute;) Setting FireStore Tiếp theo m&igrave;nh sẽ đi c&agrave;i đặt thằng FireStore. Ở menu b&ecirc;n tr&aacute;i m&agrave;n h&igrave;nh, chọn Develop -&gt; Database Về chỗ Security rules: Do lần n&agrave;y thực hiện ở trong c&ocirc;ng ty n&ecirc;n kh&ocirc;ng cần để &yacute; đến security cũng được. Do đ&oacute; sẽ chọn Start in test mode. Sau khi tạo xong th&igrave; 1 database (Giống như RDS) đ&atilde; được tạo ra. FireStore l&agrave; NoSQL n&ecirc;n kh&ocirc;ng cần thiết phải tạo schema. Bước tiếp theo m&igrave;nh sẽ li&ecirc;n kết với phần Web Application. Trong m&agrave;n h&igrave;nh ch&iacute;nh, ch&uacute;ng ta click v&agrave;o c&aacute;i n&uacute;t ở trong h&igrave;nh ảnh b&ecirc;n dưới. V&agrave; thực hiện theo c&aacute;c bước trong h&igrave;nh, cuối c&ugrave;ng ch&uacute;ng ta sẽ add c&aacute;i đoạn javascript v&agrave;o trong file src/main.js. Do ở ph&iacute;a Application m&igrave;nh vẫn chưa tạo, ở đ&acirc;y m&igrave;nh sẽ tạo bằng VueJs. Về c&aacute;ch tạo ứng dụng VueJS ở tr&ecirc;n mạng kh&aacute; nhiều n&ecirc;n ở đ&acirc;y m&igrave;nh sẽ kh&ocirc;ng n&oacute;i lại nữa. C&aacute;c bạn c&oacute; thể Google để t&igrave;m hiểu nh&eacute;. Sau khi c&oacute; ứng dụng VueJS rồi th&igrave; bước tiếp theo l&agrave; nh&uacute;ng đoạn Javascript ph&iacute;a tr&ecirc;n v&agrave;o file src/main.js. Setting Firebase Hosting Về hosting của web application, ZOZO cũng quyết định d&ugrave;ng lu&ocirc;n hosting của firebase. So với Firestore th&igrave; Firebase Hosting c&agrave;i đặt kh&aacute; đơn giản. Ở menu, chọn Develop -&gt; Hosting. Sau đ&oacute; ấn v&agrave;o n&uacute;t Get Started v&agrave; thực hiện 1 số c&acirc;u lệnh ở b&ecirc;n dưới m&agrave;n h&igrave;nh. $ firebase login $ firebase init hosting Sau khi thực hiện xong 2 c&acirc;u lệnh tr&ecirc;n th&igrave; ch&uacute;ng ta sẽ thấy 1 file được tạo ra đ&oacute; l&agrave; firebase.json. Trong file n&agrave;y th&igrave; hosting.public đ&oacute; ch&iacute;nh l&agrave; đối tượng sẽ được deploy. Nhưng do VueJS đang sử dụng webpack để build, v&agrave; thư mục sau khi build xong l&agrave; dist n&ecirc;n trong firebase.json ch&uacute;ng ta sẽ chuyển hosting.public th&agrave;nh dist. Cụ thể sẽ như sau: { &quot;hosting&quot;: { &quot;public&quot;: &quot;dist&quot;, &quot;ignore&quot;: [ &quot;firebase.json&quot;, &quot;**/.*&quot;, &quot;**/node_modules/**&quot; ], &quot;rewrites&quot;: [ { &quot;source&quot;: &quot;**&quot;, &quot;destination&quot;: &quot;/index.html&quot; } ] } } Tiếp theo ch&uacute;ng ta c&ugrave;ng thực hiện deploy firebase nh&eacute;: $ npm run build $ firebase deploy Sau khi deploy xong th&igrave; ở m&agrave;n h&igrave;nh Hosting sẽ hiển thị ra domain đ&atilde; được deploy, v&agrave; c&oacute; thể access được từ URL đ&oacute;. Vậy việc c&agrave;i đặt Firebase đến đ&acirc;y l&agrave; kết th&uacute;c. Li&ecirc;n kết m&agrave;n h&igrave;nh với Firestore Tiếp theo ch&uacute;ng ta đến bước li&ecirc;n kết m&agrave;n h&igrave;nh web với firestore nh&eacute;. Cấu tr&uacute;c của FireStore sẽ đặt như sau: id của c&acirc;u hỏi hiện tại thời gian kết th&uacute;c c&acirc;u trả lời c&acirc;u trả lời của người d&ugrave;ng ・Thực tế cấu tr&uacute;c dữ liệu kh&ocirc;ng phải dạng JSON, nhưng để dễ hiểu m&igrave;nh sẽ viết lại dưới dạng JSON { &quot;questions&quot;: { &quot;current&quot;: { &quot;id&quot;: 1, // id c&acirc;u hỏi hiện tại &quot;endTime&quot;: 1545906141 // thời gian kết th&uacute;c c&acirc;u trả lời }, }, &quot;votes&quot;: { // c&acirc;u trả lời của mỗi người d&ugrave;ng &quot;001EjYAwtSMXlrWWTP5r&quot;: { // (ID m&agrave; Firestore đ&atilde; sinh ra) &quot;answerId&quot;: 0, // id c&acirc;u trả lời &quot;questionId&quot;: 2 // id c&acirc;u hỏi }, &quot;004gO0YzXUJ2bNFSbc5y&quot;: { &quot;answerId&quot;: 1, &quot;questionId&quot;: 3 }, . . . } } ・Update dữ liệu tại m&agrave;n h&igrave;nh kết quả import firebase from &#39;firebase&#39; export default { . . . created() { // this.db = firebase.firestore() this.unsubscribe = this.db.collection(&#39;questions&#39;).doc(&#39;current&#39;) .onSnapshot((doc) =&gt; { const currentQuestion = doc.data() // =&gt; // { // &quot;id&quot;: 1, // &quot;endTime&quot;: 1545906141 // } }) } . . . } ・C&acirc;u trả lời của mỗi người d&ugrave;ng: import firebase from &#39;firebase&#39; const db = firebase.firestore() export default { . . . created() { // this.db = firebase.firestore() this.db.collection(&#39;votes&#39;).onSnapshot((collection) =&gt; { this.votes = collection.docChanges().reduce((votes, c) =&gt; { const vote = c.doc.data() // =&gt; // { // &quot;answerId&quot;: 0, // &quot;questionId&quot;: 2 // } return { ...votes, [vote.questionId]: [...(votes[vote.questionId] || []), vote] } }, this.votes) // =&gt; // { // . // . // . // &quot;2&quot;: [ // thống k&ecirc; dựa v&agrave;o từng id của c&acirc;u hỏi // { // &quot;answerId&quot;: 0, // &quot;questionId&quot;: 2 // }, // . // . // . // ], // &quot;3&quot;: [ // { // &quot;answerId&quot;: 1, // &quot;questionId&quot;: 3 // }, // . // . // . // ], // . // . // . // } }) } } Tại m&agrave;n h&igrave;nh kết quả sẽ đi thống k&ecirc; dữ liệu dựa v&agrave;o từng id c&acirc;u hỏi. Đối với dữ liệu của c&acirc;u trả lời, để l&agrave;m tối thiểu cost n&ecirc;n ZOZO đ&atilde; sử dụng h&agrave;m docChanges() để chỉ lấy c&aacute;i sự kh&aacute;c nhau của từng kết quả. ・ Ở m&agrave;n h&igrave;nh Admin, sẽ tiến h&agrave;nh việc ghi dữ liệu c&acirc;u hỏi v&agrave;o trong FireStore import firebase from &#39;firebase&#39; import moment from &#39;moment&#39; export default { . . . methods: { setQuestion() { db.collection(&#39;questions&#39;).doc(&#39;current&#39;).set({ id: questionId, endTime: moment().add(questionTime, &#39;second&#39;).unix() }) } } . . . } Ở m&agrave;n h&igrave;nh Admin khi m&agrave; bắt đầu 1 c&acirc;u hỏi, khi đ&oacute; n&oacute; sẽ ghi question_id với endTime v&agrave;o trong FireStore. Sau khi ghi v&agrave;o FireStore xong, ngay lập tức sẽ gửi th&ocirc;ng b&aacute;o đến to&agrave;n bộ smartphone v&agrave; thời gian bắt đầu c&acirc;u hỏi sẽ được bắt đầu. V&agrave; khi thời gian kết th&uacute;c, m&agrave;n h&igrave;nh hiển thị c&acirc;u hỏi sẽ bị mất đi v&agrave; sẽ đi đến m&agrave;n h&igrave;nh kết quả. OK, vậy phần li&ecirc;n kết FireStore với m&agrave;n h&igrave;nh đến đ&acirc;y đ&atilde; xong. V&agrave; đ&acirc;y l&agrave; ph&ograve;ng điều h&agrave;nh buổi tổng kết. Nh&igrave;n đ&atilde; thấy sự chuy&ecirc;n nghiệp rồi. Đ&uacute;ng l&agrave; nước ngo&agrave;i c&oacute; kh&aacute;c. Họ l&agrave;m g&igrave; cũng thấy chuy&ecirc;n nghiệp Về Pricing của Firebase Sau khi event kết th&uacute;c, v&agrave;o m&agrave;n h&igrave;nh Firebase để x&aacute;c nhận xem mất bao nhi&ecirc;u tiền. 0.02$ L&agrave;m đc 1 ứng dụng như vậy m&agrave; chỉ mất c&oacute; 0.02$. Qu&aacute; kinh khủng. Tổng kết Nếu bạn n&agrave;o đang c&oacute; &yacute; định l&agrave;m 1 ứng dụng trả lời survey realtime th&igrave; c&oacute; thể tham khảo b&agrave;i viết n&agrave;y nh&eacute;. Ch&uacute;c c&aacute;c bạn th&agrave;nh c&ocirc;ng.</p>\n",
      "total_views": 235,
      "status": true,
      "tags": [
        "Firebase", "Survey realtime"
      ]
    }
  ]
}